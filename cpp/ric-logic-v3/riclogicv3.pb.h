// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: ric-logic-v3/riclogicv3.proto

#ifndef PROTOBUF_INCLUDED_ric_2dlogic_2dv3_2friclogicv3_2eproto
#define PROTOBUF_INCLUDED_ric_2dlogic_2dv3_2friclogicv3_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3007000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3007000 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/inlined_string_field.h>
#include <google/protobuf/metadata.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/map.h>  // IWYU pragma: export
#include <google/protobuf/map_entry.h>
#include <google/protobuf/map_field_inl.h>
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_ric_2dlogic_2dv3_2friclogicv3_2eproto

// Internal implementation detail -- do not use these members.
struct TableStruct_ric_2dlogic_2dv3_2friclogicv3_2eproto {
  static const ::google::protobuf::internal::ParseTableField entries[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::google::protobuf::internal::AuxillaryParseTableField aux[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::google::protobuf::internal::ParseTable schema[33]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::google::protobuf::internal::FieldMetadata field_metadata[];
  static const ::google::protobuf::internal::SerializationTable serialization_table[];
  static const ::google::protobuf::uint32 offsets[];
};
void AddDescriptors_ric_2dlogic_2dv3_2friclogicv3_2eproto();
namespace ric {
namespace logic {
namespace v3 {
class ActionResult;
class ActionResultDefaultTypeInternal;
extern ActionResultDefaultTypeInternal _ActionResult_default_instance_;
class AutomatonEvent;
class AutomatonEventDefaultTypeInternal;
extern AutomatonEventDefaultTypeInternal _AutomatonEvent_default_instance_;
class AutomatonInfo;
class AutomatonInfoDefaultTypeInternal;
extern AutomatonInfoDefaultTypeInternal _AutomatonInfo_default_instance_;
class AutomatonInfo_VarsEntry_DoNotUse;
class AutomatonInfo_VarsEntry_DoNotUseDefaultTypeInternal;
extern AutomatonInfo_VarsEntry_DoNotUseDefaultTypeInternal _AutomatonInfo_VarsEntry_DoNotUse_default_instance_;
class AutomatonStats;
class AutomatonStatsDefaultTypeInternal;
extern AutomatonStatsDefaultTypeInternal _AutomatonStats_default_instance_;
class AutomatonVarValue;
class AutomatonVarValueDefaultTypeInternal;
extern AutomatonVarValueDefaultTypeInternal _AutomatonVarValue_default_instance_;
class EmitEventRequest;
class EmitEventRequestDefaultTypeInternal;
extern EmitEventRequestDefaultTypeInternal _EmitEventRequest_default_instance_;
class EmitEventResponse;
class EmitEventResponseDefaultTypeInternal;
extern EmitEventResponseDefaultTypeInternal _EmitEventResponse_default_instance_;
class GetAutomatonsRequest;
class GetAutomatonsRequestDefaultTypeInternal;
extern GetAutomatonsRequestDefaultTypeInternal _GetAutomatonsRequest_default_instance_;
class GetAutomatonsResponse;
class GetAutomatonsResponseDefaultTypeInternal;
extern GetAutomatonsResponseDefaultTypeInternal _GetAutomatonsResponse_default_instance_;
class GetInstanceInfoRequest;
class GetInstanceInfoRequestDefaultTypeInternal;
extern GetInstanceInfoRequestDefaultTypeInternal _GetInstanceInfoRequest_default_instance_;
class GetInstanceInfoResponse;
class GetInstanceInfoResponseDefaultTypeInternal;
extern GetInstanceInfoResponseDefaultTypeInternal _GetInstanceInfoResponse_default_instance_;
class GetRuntimeInfoRequest;
class GetRuntimeInfoRequestDefaultTypeInternal;
extern GetRuntimeInfoRequestDefaultTypeInternal _GetRuntimeInfoRequest_default_instance_;
class LogEntry;
class LogEntryDefaultTypeInternal;
extern LogEntryDefaultTypeInternal _LogEntry_default_instance_;
class RunAutomatonRequest;
class RunAutomatonRequestDefaultTypeInternal;
extern RunAutomatonRequestDefaultTypeInternal _RunAutomatonRequest_default_instance_;
class RunAutomatonRequest_VarsEntry_DoNotUse;
class RunAutomatonRequest_VarsEntry_DoNotUseDefaultTypeInternal;
extern RunAutomatonRequest_VarsEntry_DoNotUseDefaultTypeInternal _RunAutomatonRequest_VarsEntry_DoNotUse_default_instance_;
class StartAutomatonMultiRequest;
class StartAutomatonMultiRequestDefaultTypeInternal;
extern StartAutomatonMultiRequestDefaultTypeInternal _StartAutomatonMultiRequest_default_instance_;
class StartAutomatonRequest;
class StartAutomatonRequestDefaultTypeInternal;
extern StartAutomatonRequestDefaultTypeInternal _StartAutomatonRequest_default_instance_;
class StartAutomatonRequest_VarsEntry_DoNotUse;
class StartAutomatonRequest_VarsEntry_DoNotUseDefaultTypeInternal;
extern StartAutomatonRequest_VarsEntry_DoNotUseDefaultTypeInternal _StartAutomatonRequest_VarsEntry_DoNotUse_default_instance_;
class StartAutomatonResponse;
class StartAutomatonResponseDefaultTypeInternal;
extern StartAutomatonResponseDefaultTypeInternal _StartAutomatonResponse_default_instance_;
class StatsCounter;
class StatsCounterDefaultTypeInternal;
extern StatsCounterDefaultTypeInternal _StatsCounter_default_instance_;
class StopAutomatonRequest;
class StopAutomatonRequestDefaultTypeInternal;
extern StopAutomatonRequestDefaultTypeInternal _StopAutomatonRequest_default_instance_;
class StopAutomatonResponse;
class StopAutomatonResponseDefaultTypeInternal;
extern StopAutomatonResponseDefaultTypeInternal _StopAutomatonResponse_default_instance_;
class TouchEventSubscriptionRequest;
class TouchEventSubscriptionRequestDefaultTypeInternal;
extern TouchEventSubscriptionRequestDefaultTypeInternal _TouchEventSubscriptionRequest_default_instance_;
class TouchEventSubscriptionResponse;
class TouchEventSubscriptionResponseDefaultTypeInternal;
extern TouchEventSubscriptionResponseDefaultTypeInternal _TouchEventSubscriptionResponse_default_instance_;
class UpdateAutomatonVarsRequest;
class UpdateAutomatonVarsRequestDefaultTypeInternal;
extern UpdateAutomatonVarsRequestDefaultTypeInternal _UpdateAutomatonVarsRequest_default_instance_;
class UpdateAutomatonVarsRequest_VarsEntry_DoNotUse;
class UpdateAutomatonVarsRequest_VarsEntry_DoNotUseDefaultTypeInternal;
extern UpdateAutomatonVarsRequest_VarsEntry_DoNotUseDefaultTypeInternal _UpdateAutomatonVarsRequest_VarsEntry_DoNotUse_default_instance_;
class UpdateAutomatonVarsResponse;
class UpdateAutomatonVarsResponseDefaultTypeInternal;
extern UpdateAutomatonVarsResponseDefaultTypeInternal _UpdateAutomatonVarsResponse_default_instance_;
class UpdateAutomatonVarsResponse_VarsEntry_DoNotUse;
class UpdateAutomatonVarsResponse_VarsEntry_DoNotUseDefaultTypeInternal;
extern UpdateAutomatonVarsResponse_VarsEntry_DoNotUseDefaultTypeInternal _UpdateAutomatonVarsResponse_VarsEntry_DoNotUse_default_instance_;
class UserContext;
class UserContextDefaultTypeInternal;
extern UserContextDefaultTypeInternal _UserContext_default_instance_;
class WaitCondition;
class WaitConditionDefaultTypeInternal;
extern WaitConditionDefaultTypeInternal _WaitCondition_default_instance_;
class WaitEventRequest;
class WaitEventRequestDefaultTypeInternal;
extern WaitEventRequestDefaultTypeInternal _WaitEventRequest_default_instance_;
class WaitEventResponse;
class WaitEventResponseDefaultTypeInternal;
extern WaitEventResponseDefaultTypeInternal _WaitEventResponse_default_instance_;
}  // namespace v3
}  // namespace logic
}  // namespace ric
namespace google {
namespace protobuf {
template<> ::ric::logic::v3::ActionResult* Arena::CreateMaybeMessage<::ric::logic::v3::ActionResult>(Arena*);
template<> ::ric::logic::v3::AutomatonEvent* Arena::CreateMaybeMessage<::ric::logic::v3::AutomatonEvent>(Arena*);
template<> ::ric::logic::v3::AutomatonInfo* Arena::CreateMaybeMessage<::ric::logic::v3::AutomatonInfo>(Arena*);
template<> ::ric::logic::v3::AutomatonInfo_VarsEntry_DoNotUse* Arena::CreateMaybeMessage<::ric::logic::v3::AutomatonInfo_VarsEntry_DoNotUse>(Arena*);
template<> ::ric::logic::v3::AutomatonStats* Arena::CreateMaybeMessage<::ric::logic::v3::AutomatonStats>(Arena*);
template<> ::ric::logic::v3::AutomatonVarValue* Arena::CreateMaybeMessage<::ric::logic::v3::AutomatonVarValue>(Arena*);
template<> ::ric::logic::v3::EmitEventRequest* Arena::CreateMaybeMessage<::ric::logic::v3::EmitEventRequest>(Arena*);
template<> ::ric::logic::v3::EmitEventResponse* Arena::CreateMaybeMessage<::ric::logic::v3::EmitEventResponse>(Arena*);
template<> ::ric::logic::v3::GetAutomatonsRequest* Arena::CreateMaybeMessage<::ric::logic::v3::GetAutomatonsRequest>(Arena*);
template<> ::ric::logic::v3::GetAutomatonsResponse* Arena::CreateMaybeMessage<::ric::logic::v3::GetAutomatonsResponse>(Arena*);
template<> ::ric::logic::v3::GetInstanceInfoRequest* Arena::CreateMaybeMessage<::ric::logic::v3::GetInstanceInfoRequest>(Arena*);
template<> ::ric::logic::v3::GetInstanceInfoResponse* Arena::CreateMaybeMessage<::ric::logic::v3::GetInstanceInfoResponse>(Arena*);
template<> ::ric::logic::v3::GetRuntimeInfoRequest* Arena::CreateMaybeMessage<::ric::logic::v3::GetRuntimeInfoRequest>(Arena*);
template<> ::ric::logic::v3::LogEntry* Arena::CreateMaybeMessage<::ric::logic::v3::LogEntry>(Arena*);
template<> ::ric::logic::v3::RunAutomatonRequest* Arena::CreateMaybeMessage<::ric::logic::v3::RunAutomatonRequest>(Arena*);
template<> ::ric::logic::v3::RunAutomatonRequest_VarsEntry_DoNotUse* Arena::CreateMaybeMessage<::ric::logic::v3::RunAutomatonRequest_VarsEntry_DoNotUse>(Arena*);
template<> ::ric::logic::v3::StartAutomatonMultiRequest* Arena::CreateMaybeMessage<::ric::logic::v3::StartAutomatonMultiRequest>(Arena*);
template<> ::ric::logic::v3::StartAutomatonRequest* Arena::CreateMaybeMessage<::ric::logic::v3::StartAutomatonRequest>(Arena*);
template<> ::ric::logic::v3::StartAutomatonRequest_VarsEntry_DoNotUse* Arena::CreateMaybeMessage<::ric::logic::v3::StartAutomatonRequest_VarsEntry_DoNotUse>(Arena*);
template<> ::ric::logic::v3::StartAutomatonResponse* Arena::CreateMaybeMessage<::ric::logic::v3::StartAutomatonResponse>(Arena*);
template<> ::ric::logic::v3::StatsCounter* Arena::CreateMaybeMessage<::ric::logic::v3::StatsCounter>(Arena*);
template<> ::ric::logic::v3::StopAutomatonRequest* Arena::CreateMaybeMessage<::ric::logic::v3::StopAutomatonRequest>(Arena*);
template<> ::ric::logic::v3::StopAutomatonResponse* Arena::CreateMaybeMessage<::ric::logic::v3::StopAutomatonResponse>(Arena*);
template<> ::ric::logic::v3::TouchEventSubscriptionRequest* Arena::CreateMaybeMessage<::ric::logic::v3::TouchEventSubscriptionRequest>(Arena*);
template<> ::ric::logic::v3::TouchEventSubscriptionResponse* Arena::CreateMaybeMessage<::ric::logic::v3::TouchEventSubscriptionResponse>(Arena*);
template<> ::ric::logic::v3::UpdateAutomatonVarsRequest* Arena::CreateMaybeMessage<::ric::logic::v3::UpdateAutomatonVarsRequest>(Arena*);
template<> ::ric::logic::v3::UpdateAutomatonVarsRequest_VarsEntry_DoNotUse* Arena::CreateMaybeMessage<::ric::logic::v3::UpdateAutomatonVarsRequest_VarsEntry_DoNotUse>(Arena*);
template<> ::ric::logic::v3::UpdateAutomatonVarsResponse* Arena::CreateMaybeMessage<::ric::logic::v3::UpdateAutomatonVarsResponse>(Arena*);
template<> ::ric::logic::v3::UpdateAutomatonVarsResponse_VarsEntry_DoNotUse* Arena::CreateMaybeMessage<::ric::logic::v3::UpdateAutomatonVarsResponse_VarsEntry_DoNotUse>(Arena*);
template<> ::ric::logic::v3::UserContext* Arena::CreateMaybeMessage<::ric::logic::v3::UserContext>(Arena*);
template<> ::ric::logic::v3::WaitCondition* Arena::CreateMaybeMessage<::ric::logic::v3::WaitCondition>(Arena*);
template<> ::ric::logic::v3::WaitEventRequest* Arena::CreateMaybeMessage<::ric::logic::v3::WaitEventRequest>(Arena*);
template<> ::ric::logic::v3::WaitEventResponse* Arena::CreateMaybeMessage<::ric::logic::v3::WaitEventResponse>(Arena*);
}  // namespace protobuf
}  // namespace google
namespace ric {
namespace logic {
namespace v3 {

// ===================================================================

class UserContext final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:ric.logic.v3.UserContext) */ {
 public:
  UserContext();
  virtual ~UserContext();

  UserContext(const UserContext& from);

  inline UserContext& operator=(const UserContext& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  UserContext(UserContext&& from) noexcept
    : UserContext() {
    *this = ::std::move(from);
  }

  inline UserContext& operator=(UserContext&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const UserContext& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const UserContext* internal_default_instance() {
    return reinterpret_cast<const UserContext*>(
               &_UserContext_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  void Swap(UserContext* other);
  friend void swap(UserContext& a, UserContext& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline UserContext* New() const final {
    return CreateMaybeMessage<UserContext>(nullptr);
  }

  UserContext* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<UserContext>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const UserContext& from);
  void MergeFrom(const UserContext& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(UserContext* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string group_id = 1;
  void clear_group_id();
  static const int kGroupIdFieldNumber = 1;
  const ::std::string& group_id() const;
  void set_group_id(const ::std::string& value);
  #if LANG_CXX11
  void set_group_id(::std::string&& value);
  #endif
  void set_group_id(const char* value);
  void set_group_id(const char* value, size_t size);
  ::std::string* mutable_group_id();
  ::std::string* release_group_id();
  void set_allocated_group_id(::std::string* group_id);

  // string user_id = 2;
  void clear_user_id();
  static const int kUserIdFieldNumber = 2;
  const ::std::string& user_id() const;
  void set_user_id(const ::std::string& value);
  #if LANG_CXX11
  void set_user_id(::std::string&& value);
  #endif
  void set_user_id(const char* value);
  void set_user_id(const char* value, size_t size);
  ::std::string* mutable_user_id();
  ::std::string* release_user_id();
  void set_allocated_user_id(::std::string* user_id);

  // string span_id = 3;
  void clear_span_id();
  static const int kSpanIdFieldNumber = 3;
  const ::std::string& span_id() const;
  void set_span_id(const ::std::string& value);
  #if LANG_CXX11
  void set_span_id(::std::string&& value);
  #endif
  void set_span_id(const char* value);
  void set_span_id(const char* value, size_t size);
  ::std::string* mutable_span_id();
  ::std::string* release_span_id();
  void set_allocated_span_id(::std::string* span_id);

  // @@protoc_insertion_point(class_scope:ric.logic.v3.UserContext)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr group_id_;
  ::google::protobuf::internal::ArenaStringPtr user_id_;
  ::google::protobuf::internal::ArenaStringPtr span_id_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_ric_2dlogic_2dv3_2friclogicv3_2eproto;
};
// -------------------------------------------------------------------

class StatsCounter final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:ric.logic.v3.StatsCounter) */ {
 public:
  StatsCounter();
  virtual ~StatsCounter();

  StatsCounter(const StatsCounter& from);

  inline StatsCounter& operator=(const StatsCounter& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  StatsCounter(StatsCounter&& from) noexcept
    : StatsCounter() {
    *this = ::std::move(from);
  }

  inline StatsCounter& operator=(StatsCounter&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const StatsCounter& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const StatsCounter* internal_default_instance() {
    return reinterpret_cast<const StatsCounter*>(
               &_StatsCounter_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  void Swap(StatsCounter* other);
  friend void swap(StatsCounter& a, StatsCounter& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline StatsCounter* New() const final {
    return CreateMaybeMessage<StatsCounter>(nullptr);
  }

  StatsCounter* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<StatsCounter>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const StatsCounter& from);
  void MergeFrom(const StatsCounter& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(StatsCounter* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // int64 count = 1;
  void clear_count();
  static const int kCountFieldNumber = 1;
  ::google::protobuf::int64 count() const;
  void set_count(::google::protobuf::int64 value);

  // float mean = 2;
  void clear_mean();
  static const int kMeanFieldNumber = 2;
  float mean() const;
  void set_mean(float value);

  // @@protoc_insertion_point(class_scope:ric.logic.v3.StatsCounter)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::int64 count_;
  float mean_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_ric_2dlogic_2dv3_2friclogicv3_2eproto;
};
// -------------------------------------------------------------------

class AutomatonStats final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:ric.logic.v3.AutomatonStats) */ {
 public:
  AutomatonStats();
  virtual ~AutomatonStats();

  AutomatonStats(const AutomatonStats& from);

  inline AutomatonStats& operator=(const AutomatonStats& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  AutomatonStats(AutomatonStats&& from) noexcept
    : AutomatonStats() {
    *this = ::std::move(from);
  }

  inline AutomatonStats& operator=(AutomatonStats&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const AutomatonStats& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const AutomatonStats* internal_default_instance() {
    return reinterpret_cast<const AutomatonStats*>(
               &_AutomatonStats_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  void Swap(AutomatonStats* other);
  friend void swap(AutomatonStats& a, AutomatonStats& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline AutomatonStats* New() const final {
    return CreateMaybeMessage<AutomatonStats>(nullptr);
  }

  AutomatonStats* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<AutomatonStats>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const AutomatonStats& from);
  void MergeFrom(const AutomatonStats& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(AutomatonStats* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string halted = 8;
  void clear_halted();
  static const int kHaltedFieldNumber = 8;
  const ::std::string& halted() const;
  void set_halted(const ::std::string& value);
  #if LANG_CXX11
  void set_halted(::std::string&& value);
  #endif
  void set_halted(const char* value);
  void set_halted(const char* value, size_t size);
  ::std::string* mutable_halted();
  ::std::string* release_halted();
  void set_allocated_halted(::std::string* halted);

  // .ric.logic.v3.StatsCounter transitions = 4;
  bool has_transitions() const;
  void clear_transitions();
  static const int kTransitionsFieldNumber = 4;
  const ::ric::logic::v3::StatsCounter& transitions() const;
  ::ric::logic::v3::StatsCounter* release_transitions();
  ::ric::logic::v3::StatsCounter* mutable_transitions();
  void set_allocated_transitions(::ric::logic::v3::StatsCounter* transitions);

  // .ric.logic.v3.StatsCounter actions = 5;
  bool has_actions() const;
  void clear_actions();
  static const int kActionsFieldNumber = 5;
  const ::ric::logic::v3::StatsCounter& actions() const;
  ::ric::logic::v3::StatsCounter* release_actions();
  ::ric::logic::v3::StatsCounter* mutable_actions();
  void set_allocated_actions(::ric::logic::v3::StatsCounter* actions);

  // .ric.logic.v3.StatsCounter packets = 6;
  bool has_packets() const;
  void clear_packets();
  static const int kPacketsFieldNumber = 6;
  const ::ric::logic::v3::StatsCounter& packets() const;
  ::ric::logic::v3::StatsCounter* release_packets();
  ::ric::logic::v3::StatsCounter* mutable_packets();
  void set_allocated_packets(::ric::logic::v3::StatsCounter* packets);

  // .ric.logic.v3.StatsCounter events = 7;
  bool has_events() const;
  void clear_events();
  static const int kEventsFieldNumber = 7;
  const ::ric::logic::v3::StatsCounter& events() const;
  ::ric::logic::v3::StatsCounter* release_events();
  ::ric::logic::v3::StatsCounter* mutable_events();
  void set_allocated_events(::ric::logic::v3::StatsCounter* events);

  // int64 started_at = 1;
  void clear_started_at();
  static const int kStartedAtFieldNumber = 1;
  ::google::protobuf::int64 started_at() const;
  void set_started_at(::google::protobuf::int64 value);

  // int64 stopped_at = 2;
  void clear_stopped_at();
  static const int kStoppedAtFieldNumber = 2;
  ::google::protobuf::int64 stopped_at() const;
  void set_stopped_at(::google::protobuf::int64 value);

  // int64 transitioned_at = 3;
  void clear_transitioned_at();
  static const int kTransitionedAtFieldNumber = 3;
  ::google::protobuf::int64 transitioned_at() const;
  void set_transitioned_at(::google::protobuf::int64 value);

  // @@protoc_insertion_point(class_scope:ric.logic.v3.AutomatonStats)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr halted_;
  ::ric::logic::v3::StatsCounter* transitions_;
  ::ric::logic::v3::StatsCounter* actions_;
  ::ric::logic::v3::StatsCounter* packets_;
  ::ric::logic::v3::StatsCounter* events_;
  ::google::protobuf::int64 started_at_;
  ::google::protobuf::int64 stopped_at_;
  ::google::protobuf::int64 transitioned_at_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_ric_2dlogic_2dv3_2friclogicv3_2eproto;
};
// -------------------------------------------------------------------

class AutomatonVarValue final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:ric.logic.v3.AutomatonVarValue) */ {
 public:
  AutomatonVarValue();
  virtual ~AutomatonVarValue();

  AutomatonVarValue(const AutomatonVarValue& from);

  inline AutomatonVarValue& operator=(const AutomatonVarValue& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  AutomatonVarValue(AutomatonVarValue&& from) noexcept
    : AutomatonVarValue() {
    *this = ::std::move(from);
  }

  inline AutomatonVarValue& operator=(AutomatonVarValue&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const AutomatonVarValue& default_instance();

  enum TypeCase {
    kStringVal = 1,
    kDoubleVal = 2,
    kBoolVal = 3,
    TYPE_NOT_SET = 0,
  };

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const AutomatonVarValue* internal_default_instance() {
    return reinterpret_cast<const AutomatonVarValue*>(
               &_AutomatonVarValue_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  void Swap(AutomatonVarValue* other);
  friend void swap(AutomatonVarValue& a, AutomatonVarValue& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline AutomatonVarValue* New() const final {
    return CreateMaybeMessage<AutomatonVarValue>(nullptr);
  }

  AutomatonVarValue* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<AutomatonVarValue>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const AutomatonVarValue& from);
  void MergeFrom(const AutomatonVarValue& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(AutomatonVarValue* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string string_val = 1;
  private:
  bool has_string_val() const;
  public:
  void clear_string_val();
  static const int kStringValFieldNumber = 1;
  const ::std::string& string_val() const;
  void set_string_val(const ::std::string& value);
  #if LANG_CXX11
  void set_string_val(::std::string&& value);
  #endif
  void set_string_val(const char* value);
  void set_string_val(const char* value, size_t size);
  ::std::string* mutable_string_val();
  ::std::string* release_string_val();
  void set_allocated_string_val(::std::string* string_val);

  // double double_val = 2;
  private:
  bool has_double_val() const;
  public:
  void clear_double_val();
  static const int kDoubleValFieldNumber = 2;
  double double_val() const;
  void set_double_val(double value);

  // bool bool_val = 3;
  private:
  bool has_bool_val() const;
  public:
  void clear_bool_val();
  static const int kBoolValFieldNumber = 3;
  bool bool_val() const;
  void set_bool_val(bool value);

  void clear_type();
  TypeCase type_case() const;
  // @@protoc_insertion_point(class_scope:ric.logic.v3.AutomatonVarValue)
 private:
  class HasBitSetters;
  void set_has_string_val();
  void set_has_double_val();
  void set_has_bool_val();

  inline bool has_type() const;
  inline void clear_has_type();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  union TypeUnion {
    TypeUnion() {}
    ::google::protobuf::internal::ArenaStringPtr string_val_;
    double double_val_;
    bool bool_val_;
  } type_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::uint32 _oneof_case_[1];

  friend struct ::TableStruct_ric_2dlogic_2dv3_2friclogicv3_2eproto;
};
// -------------------------------------------------------------------

class AutomatonInfo_VarsEntry_DoNotUse : public ::google::protobuf::internal::MapEntry<AutomatonInfo_VarsEntry_DoNotUse, 
    ::std::string, ::ric::logic::v3::AutomatonVarValue,
    ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
    ::google::protobuf::internal::WireFormatLite::TYPE_MESSAGE,
    0 > {
public:
#if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
static bool _ParseMap(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
#endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  typedef ::google::protobuf::internal::MapEntry<AutomatonInfo_VarsEntry_DoNotUse, 
    ::std::string, ::ric::logic::v3::AutomatonVarValue,
    ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
    ::google::protobuf::internal::WireFormatLite::TYPE_MESSAGE,
    0 > SuperType;
  AutomatonInfo_VarsEntry_DoNotUse();
  AutomatonInfo_VarsEntry_DoNotUse(::google::protobuf::Arena* arena);
  void MergeFrom(const AutomatonInfo_VarsEntry_DoNotUse& other);
  static const AutomatonInfo_VarsEntry_DoNotUse* internal_default_instance() { return reinterpret_cast<const AutomatonInfo_VarsEntry_DoNotUse*>(&_AutomatonInfo_VarsEntry_DoNotUse_default_instance_); }
  void MergeFrom(const ::google::protobuf::Message& other) final;
  ::google::protobuf::Metadata GetMetadata() const;
};

// -------------------------------------------------------------------

class AutomatonInfo final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:ric.logic.v3.AutomatonInfo) */ {
 public:
  AutomatonInfo();
  virtual ~AutomatonInfo();

  AutomatonInfo(const AutomatonInfo& from);

  inline AutomatonInfo& operator=(const AutomatonInfo& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  AutomatonInfo(AutomatonInfo&& from) noexcept
    : AutomatonInfo() {
    *this = ::std::move(from);
  }

  inline AutomatonInfo& operator=(AutomatonInfo&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const AutomatonInfo& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const AutomatonInfo* internal_default_instance() {
    return reinterpret_cast<const AutomatonInfo*>(
               &_AutomatonInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  void Swap(AutomatonInfo* other);
  friend void swap(AutomatonInfo& a, AutomatonInfo& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline AutomatonInfo* New() const final {
    return CreateMaybeMessage<AutomatonInfo>(nullptr);
  }

  AutomatonInfo* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<AutomatonInfo>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const AutomatonInfo& from);
  void MergeFrom(const AutomatonInfo& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(AutomatonInfo* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------


  // accessors -------------------------------------------------------

  // repeated .ric.logic.v3.LogEntry logs = 10;
  int logs_size() const;
  void clear_logs();
  static const int kLogsFieldNumber = 10;
  ::ric::logic::v3::LogEntry* mutable_logs(int index);
  ::google::protobuf::RepeatedPtrField< ::ric::logic::v3::LogEntry >*
      mutable_logs();
  const ::ric::logic::v3::LogEntry& logs(int index) const;
  ::ric::logic::v3::LogEntry* add_logs();
  const ::google::protobuf::RepeatedPtrField< ::ric::logic::v3::LogEntry >&
      logs() const;

  // map<string, .ric.logic.v3.AutomatonVarValue> vars = 11;
  int vars_size() const;
  void clear_vars();
  static const int kVarsFieldNumber = 11;
  const ::google::protobuf::Map< ::std::string, ::ric::logic::v3::AutomatonVarValue >&
      vars() const;
  ::google::protobuf::Map< ::std::string, ::ric::logic::v3::AutomatonVarValue >*
      mutable_vars();

  // string object_id = 1;
  void clear_object_id();
  static const int kObjectIdFieldNumber = 1;
  const ::std::string& object_id() const;
  void set_object_id(const ::std::string& value);
  #if LANG_CXX11
  void set_object_id(::std::string&& value);
  #endif
  void set_object_id(const char* value);
  void set_object_id(const char* value, size_t size);
  ::std::string* mutable_object_id();
  ::std::string* release_object_id();
  void set_allocated_object_id(::std::string* object_id);

  // string automaton_id = 2;
  void clear_automaton_id();
  static const int kAutomatonIdFieldNumber = 2;
  const ::std::string& automaton_id() const;
  void set_automaton_id(const ::std::string& value);
  #if LANG_CXX11
  void set_automaton_id(::std::string&& value);
  #endif
  void set_automaton_id(const char* value);
  void set_automaton_id(const char* value, size_t size);
  ::std::string* mutable_automaton_id();
  ::std::string* release_automaton_id();
  void set_allocated_automaton_id(::std::string* automaton_id);

  // string hash_id = 3;
  void clear_hash_id();
  static const int kHashIdFieldNumber = 3;
  const ::std::string& hash_id() const;
  void set_hash_id(const ::std::string& value);
  #if LANG_CXX11
  void set_hash_id(::std::string&& value);
  #endif
  void set_hash_id(const char* value);
  void set_hash_id(const char* value, size_t size);
  ::std::string* mutable_hash_id();
  ::std::string* release_hash_id();
  void set_allocated_hash_id(::std::string* hash_id);

  // string revision = 4;
  void clear_revision();
  static const int kRevisionFieldNumber = 4;
  const ::std::string& revision() const;
  void set_revision(const ::std::string& value);
  #if LANG_CXX11
  void set_revision(::std::string&& value);
  #endif
  void set_revision(const char* value);
  void set_revision(const char* value, size_t size);
  ::std::string* mutable_revision();
  ::std::string* release_revision();
  void set_allocated_revision(::std::string* revision);

  // string status = 5;
  void clear_status();
  static const int kStatusFieldNumber = 5;
  const ::std::string& status() const;
  void set_status(const ::std::string& value);
  #if LANG_CXX11
  void set_status(::std::string&& value);
  #endif
  void set_status(const char* value);
  void set_status(const char* value, size_t size);
  ::std::string* mutable_status();
  ::std::string* release_status();
  void set_allocated_status(::std::string* status);

  // string state = 6;
  void clear_state();
  static const int kStateFieldNumber = 6;
  const ::std::string& state() const;
  void set_state(const ::std::string& value);
  #if LANG_CXX11
  void set_state(::std::string&& value);
  #endif
  void set_state(const char* value);
  void set_state(const char* value, size_t size);
  ::std::string* mutable_state();
  ::std::string* release_state();
  void set_allocated_state(::std::string* state);

  // string prev_state = 7;
  void clear_prev_state();
  static const int kPrevStateFieldNumber = 7;
  const ::std::string& prev_state() const;
  void set_prev_state(const ::std::string& value);
  #if LANG_CXX11
  void set_prev_state(::std::string&& value);
  #endif
  void set_prev_state(const char* value);
  void set_prev_state(const char* value, size_t size);
  ::std::string* mutable_prev_state();
  ::std::string* release_prev_state();
  void set_allocated_prev_state(::std::string* prev_state);

  // string prev_event = 8;
  void clear_prev_event();
  static const int kPrevEventFieldNumber = 8;
  const ::std::string& prev_event() const;
  void set_prev_event(const ::std::string& value);
  #if LANG_CXX11
  void set_prev_event(::std::string&& value);
  #endif
  void set_prev_event(const char* value);
  void set_prev_event(const char* value, size_t size);
  ::std::string* mutable_prev_event();
  ::std::string* release_prev_event();
  void set_allocated_prev_event(::std::string* prev_event);

  // .ric.logic.v3.AutomatonStats stats = 9;
  bool has_stats() const;
  void clear_stats();
  static const int kStatsFieldNumber = 9;
  const ::ric::logic::v3::AutomatonStats& stats() const;
  ::ric::logic::v3::AutomatonStats* release_stats();
  ::ric::logic::v3::AutomatonStats* mutable_stats();
  void set_allocated_stats(::ric::logic::v3::AutomatonStats* stats);

  // @@protoc_insertion_point(class_scope:ric.logic.v3.AutomatonInfo)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::ric::logic::v3::LogEntry > logs_;
  ::google::protobuf::internal::MapField<
      AutomatonInfo_VarsEntry_DoNotUse,
      ::std::string, ::ric::logic::v3::AutomatonVarValue,
      ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
      ::google::protobuf::internal::WireFormatLite::TYPE_MESSAGE,
      0 > vars_;
  ::google::protobuf::internal::ArenaStringPtr object_id_;
  ::google::protobuf::internal::ArenaStringPtr automaton_id_;
  ::google::protobuf::internal::ArenaStringPtr hash_id_;
  ::google::protobuf::internal::ArenaStringPtr revision_;
  ::google::protobuf::internal::ArenaStringPtr status_;
  ::google::protobuf::internal::ArenaStringPtr state_;
  ::google::protobuf::internal::ArenaStringPtr prev_state_;
  ::google::protobuf::internal::ArenaStringPtr prev_event_;
  ::ric::logic::v3::AutomatonStats* stats_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_ric_2dlogic_2dv3_2friclogicv3_2eproto;
};
// -------------------------------------------------------------------

class AutomatonEvent final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:ric.logic.v3.AutomatonEvent) */ {
 public:
  AutomatonEvent();
  virtual ~AutomatonEvent();

  AutomatonEvent(const AutomatonEvent& from);

  inline AutomatonEvent& operator=(const AutomatonEvent& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  AutomatonEvent(AutomatonEvent&& from) noexcept
    : AutomatonEvent() {
    *this = ::std::move(from);
  }

  inline AutomatonEvent& operator=(AutomatonEvent&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const AutomatonEvent& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const AutomatonEvent* internal_default_instance() {
    return reinterpret_cast<const AutomatonEvent*>(
               &_AutomatonEvent_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  void Swap(AutomatonEvent* other);
  friend void swap(AutomatonEvent& a, AutomatonEvent& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline AutomatonEvent* New() const final {
    return CreateMaybeMessage<AutomatonEvent>(nullptr);
  }

  AutomatonEvent* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<AutomatonEvent>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const AutomatonEvent& from);
  void MergeFrom(const AutomatonEvent& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(AutomatonEvent* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string type = 1;
  void clear_type();
  static const int kTypeFieldNumber = 1;
  const ::std::string& type() const;
  void set_type(const ::std::string& value);
  #if LANG_CXX11
  void set_type(::std::string&& value);
  #endif
  void set_type(const char* value);
  void set_type(const char* value, size_t size);
  ::std::string* mutable_type();
  ::std::string* release_type();
  void set_allocated_type(::std::string* type);

  // string payload = 2;
  void clear_payload();
  static const int kPayloadFieldNumber = 2;
  const ::std::string& payload() const;
  void set_payload(const ::std::string& value);
  #if LANG_CXX11
  void set_payload(::std::string&& value);
  #endif
  void set_payload(const char* value);
  void set_payload(const char* value, size_t size);
  ::std::string* mutable_payload();
  ::std::string* release_payload();
  void set_allocated_payload(::std::string* payload);

  // @@protoc_insertion_point(class_scope:ric.logic.v3.AutomatonEvent)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr type_;
  ::google::protobuf::internal::ArenaStringPtr payload_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_ric_2dlogic_2dv3_2friclogicv3_2eproto;
};
// -------------------------------------------------------------------

class ActionResult final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:ric.logic.v3.ActionResult) */ {
 public:
  ActionResult();
  virtual ~ActionResult();

  ActionResult(const ActionResult& from);

  inline ActionResult& operator=(const ActionResult& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ActionResult(ActionResult&& from) noexcept
    : ActionResult() {
    *this = ::std::move(from);
  }

  inline ActionResult& operator=(ActionResult&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const ActionResult& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ActionResult* internal_default_instance() {
    return reinterpret_cast<const ActionResult*>(
               &_ActionResult_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  void Swap(ActionResult* other);
  friend void swap(ActionResult& a, ActionResult& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ActionResult* New() const final {
    return CreateMaybeMessage<ActionResult>(nullptr);
  }

  ActionResult* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<ActionResult>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const ActionResult& from);
  void MergeFrom(const ActionResult& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ActionResult* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string status = 1;
  void clear_status();
  static const int kStatusFieldNumber = 1;
  const ::std::string& status() const;
  void set_status(const ::std::string& value);
  #if LANG_CXX11
  void set_status(::std::string&& value);
  #endif
  void set_status(const char* value);
  void set_status(const char* value, size_t size);
  ::std::string* mutable_status();
  ::std::string* release_status();
  void set_allocated_status(::std::string* status);

  // string payload = 2;
  void clear_payload();
  static const int kPayloadFieldNumber = 2;
  const ::std::string& payload() const;
  void set_payload(const ::std::string& value);
  #if LANG_CXX11
  void set_payload(::std::string&& value);
  #endif
  void set_payload(const char* value);
  void set_payload(const char* value, size_t size);
  ::std::string* mutable_payload();
  ::std::string* release_payload();
  void set_allocated_payload(::std::string* payload);

  // int32 ms = 3;
  void clear_ms();
  static const int kMsFieldNumber = 3;
  ::google::protobuf::int32 ms() const;
  void set_ms(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:ric.logic.v3.ActionResult)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr status_;
  ::google::protobuf::internal::ArenaStringPtr payload_;
  ::google::protobuf::int32 ms_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_ric_2dlogic_2dv3_2friclogicv3_2eproto;
};
// -------------------------------------------------------------------

class LogEntry final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:ric.logic.v3.LogEntry) */ {
 public:
  LogEntry();
  virtual ~LogEntry();

  LogEntry(const LogEntry& from);

  inline LogEntry& operator=(const LogEntry& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  LogEntry(LogEntry&& from) noexcept
    : LogEntry() {
    *this = ::std::move(from);
  }

  inline LogEntry& operator=(LogEntry&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const LogEntry& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const LogEntry* internal_default_instance() {
    return reinterpret_cast<const LogEntry*>(
               &_LogEntry_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  void Swap(LogEntry* other);
  friend void swap(LogEntry& a, LogEntry& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline LogEntry* New() const final {
    return CreateMaybeMessage<LogEntry>(nullptr);
  }

  LogEntry* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<LogEntry>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const LogEntry& from);
  void MergeFrom(const LogEntry& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(LogEntry* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string id = 1;
  void clear_id();
  static const int kIdFieldNumber = 1;
  const ::std::string& id() const;
  void set_id(const ::std::string& value);
  #if LANG_CXX11
  void set_id(::std::string&& value);
  #endif
  void set_id(const char* value);
  void set_id(const char* value, size_t size);
  ::std::string* mutable_id();
  ::std::string* release_id();
  void set_allocated_id(::std::string* id);

  // string object_id = 3;
  void clear_object_id();
  static const int kObjectIdFieldNumber = 3;
  const ::std::string& object_id() const;
  void set_object_id(const ::std::string& value);
  #if LANG_CXX11
  void set_object_id(::std::string&& value);
  #endif
  void set_object_id(const char* value);
  void set_object_id(const char* value, size_t size);
  ::std::string* mutable_object_id();
  ::std::string* release_object_id();
  void set_allocated_object_id(::std::string* object_id);

  // string automaton_id = 4;
  void clear_automaton_id();
  static const int kAutomatonIdFieldNumber = 4;
  const ::std::string& automaton_id() const;
  void set_automaton_id(const ::std::string& value);
  #if LANG_CXX11
  void set_automaton_id(::std::string&& value);
  #endif
  void set_automaton_id(const char* value);
  void set_automaton_id(const char* value, size_t size);
  ::std::string* mutable_automaton_id();
  ::std::string* release_automaton_id();
  void set_allocated_automaton_id(::std::string* automaton_id);

  // string hash_id = 5;
  void clear_hash_id();
  static const int kHashIdFieldNumber = 5;
  const ::std::string& hash_id() const;
  void set_hash_id(const ::std::string& value);
  #if LANG_CXX11
  void set_hash_id(::std::string&& value);
  #endif
  void set_hash_id(const char* value);
  void set_hash_id(const char* value, size_t size);
  ::std::string* mutable_hash_id();
  ::std::string* release_hash_id();
  void set_allocated_hash_id(::std::string* hash_id);

  // string revision = 6;
  void clear_revision();
  static const int kRevisionFieldNumber = 6;
  const ::std::string& revision() const;
  void set_revision(const ::std::string& value);
  #if LANG_CXX11
  void set_revision(::std::string&& value);
  #endif
  void set_revision(const char* value);
  void set_revision(const char* value, size_t size);
  ::std::string* mutable_revision();
  ::std::string* release_revision();
  void set_allocated_revision(::std::string* revision);

  // string instance = 7;
  void clear_instance();
  static const int kInstanceFieldNumber = 7;
  const ::std::string& instance() const;
  void set_instance(const ::std::string& value);
  #if LANG_CXX11
  void set_instance(::std::string&& value);
  #endif
  void set_instance(const char* value);
  void set_instance(const char* value, size_t size);
  ::std::string* mutable_instance();
  ::std::string* release_instance();
  void set_allocated_instance(::std::string* instance);

  // string category = 8;
  void clear_category();
  static const int kCategoryFieldNumber = 8;
  const ::std::string& category() const;
  void set_category(const ::std::string& value);
  #if LANG_CXX11
  void set_category(::std::string&& value);
  #endif
  void set_category(const char* value);
  void set_category(const char* value, size_t size);
  ::std::string* mutable_category();
  ::std::string* release_category();
  void set_allocated_category(::std::string* category);

  // string message = 9;
  void clear_message();
  static const int kMessageFieldNumber = 9;
  const ::std::string& message() const;
  void set_message(const ::std::string& value);
  #if LANG_CXX11
  void set_message(::std::string&& value);
  #endif
  void set_message(const char* value);
  void set_message(const char* value, size_t size);
  ::std::string* mutable_message();
  ::std::string* release_message();
  void set_allocated_message(::std::string* message);

  // string state = 11;
  void clear_state();
  static const int kStateFieldNumber = 11;
  const ::std::string& state() const;
  void set_state(const ::std::string& value);
  #if LANG_CXX11
  void set_state(::std::string&& value);
  #endif
  void set_state(const char* value);
  void set_state(const char* value, size_t size);
  ::std::string* mutable_state();
  ::std::string* release_state();
  void set_allocated_state(::std::string* state);

  // string prev_state = 12;
  void clear_prev_state();
  static const int kPrevStateFieldNumber = 12;
  const ::std::string& prev_state() const;
  void set_prev_state(const ::std::string& value);
  #if LANG_CXX11
  void set_prev_state(::std::string&& value);
  #endif
  void set_prev_state(const char* value);
  void set_prev_state(const char* value, size_t size);
  ::std::string* mutable_prev_state();
  ::std::string* release_prev_state();
  void set_allocated_prev_state(::std::string* prev_state);

  // .ric.logic.v3.AutomatonEvent event = 10;
  bool has_event() const;
  void clear_event();
  static const int kEventFieldNumber = 10;
  const ::ric::logic::v3::AutomatonEvent& event() const;
  ::ric::logic::v3::AutomatonEvent* release_event();
  ::ric::logic::v3::AutomatonEvent* mutable_event();
  void set_allocated_event(::ric::logic::v3::AutomatonEvent* event);

  // .ric.logic.v3.UserContext ctx = 13;
  bool has_ctx() const;
  void clear_ctx();
  static const int kCtxFieldNumber = 13;
  const ::ric::logic::v3::UserContext& ctx() const;
  ::ric::logic::v3::UserContext* release_ctx();
  ::ric::logic::v3::UserContext* mutable_ctx();
  void set_allocated_ctx(::ric::logic::v3::UserContext* ctx);

  // .ric.logic.v3.ActionResult result = 14;
  bool has_result() const;
  void clear_result();
  static const int kResultFieldNumber = 14;
  const ::ric::logic::v3::ActionResult& result() const;
  ::ric::logic::v3::ActionResult* release_result();
  ::ric::logic::v3::ActionResult* mutable_result();
  void set_allocated_result(::ric::logic::v3::ActionResult* result);

  // int64 ts = 2;
  void clear_ts();
  static const int kTsFieldNumber = 2;
  ::google::protobuf::int64 ts() const;
  void set_ts(::google::protobuf::int64 value);

  // @@protoc_insertion_point(class_scope:ric.logic.v3.LogEntry)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr id_;
  ::google::protobuf::internal::ArenaStringPtr object_id_;
  ::google::protobuf::internal::ArenaStringPtr automaton_id_;
  ::google::protobuf::internal::ArenaStringPtr hash_id_;
  ::google::protobuf::internal::ArenaStringPtr revision_;
  ::google::protobuf::internal::ArenaStringPtr instance_;
  ::google::protobuf::internal::ArenaStringPtr category_;
  ::google::protobuf::internal::ArenaStringPtr message_;
  ::google::protobuf::internal::ArenaStringPtr state_;
  ::google::protobuf::internal::ArenaStringPtr prev_state_;
  ::ric::logic::v3::AutomatonEvent* event_;
  ::ric::logic::v3::UserContext* ctx_;
  ::ric::logic::v3::ActionResult* result_;
  ::google::protobuf::int64 ts_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_ric_2dlogic_2dv3_2friclogicv3_2eproto;
};
// -------------------------------------------------------------------

class WaitCondition final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:ric.logic.v3.WaitCondition) */ {
 public:
  WaitCondition();
  virtual ~WaitCondition();

  WaitCondition(const WaitCondition& from);

  inline WaitCondition& operator=(const WaitCondition& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  WaitCondition(WaitCondition&& from) noexcept
    : WaitCondition() {
    *this = ::std::move(from);
  }

  inline WaitCondition& operator=(WaitCondition&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const WaitCondition& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const WaitCondition* internal_default_instance() {
    return reinterpret_cast<const WaitCondition*>(
               &_WaitCondition_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  void Swap(WaitCondition* other);
  friend void swap(WaitCondition& a, WaitCondition& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline WaitCondition* New() const final {
    return CreateMaybeMessage<WaitCondition>(nullptr);
  }

  WaitCondition* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<WaitCondition>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const WaitCondition& from);
  void MergeFrom(const WaitCondition& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(WaitCondition* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string timeout = 1;
  void clear_timeout();
  static const int kTimeoutFieldNumber = 1;
  const ::std::string& timeout() const;
  void set_timeout(const ::std::string& value);
  #if LANG_CXX11
  void set_timeout(::std::string&& value);
  #endif
  void set_timeout(const char* value);
  void set_timeout(const char* value, size_t size);
  ::std::string* mutable_timeout();
  ::std::string* release_timeout();
  void set_allocated_timeout(::std::string* timeout);

  // string event = 2;
  void clear_event();
  static const int kEventFieldNumber = 2;
  const ::std::string& event() const;
  void set_event(const ::std::string& value);
  #if LANG_CXX11
  void set_event(::std::string&& value);
  #endif
  void set_event(const char* value);
  void set_event(const char* value, size_t size);
  ::std::string* mutable_event();
  ::std::string* release_event();
  void set_allocated_event(::std::string* event);

  // string state = 3;
  void clear_state();
  static const int kStateFieldNumber = 3;
  const ::std::string& state() const;
  void set_state(const ::std::string& value);
  #if LANG_CXX11
  void set_state(::std::string&& value);
  #endif
  void set_state(const char* value);
  void set_state(const char* value, size_t size);
  ::std::string* mutable_state();
  ::std::string* release_state();
  void set_allocated_state(::std::string* state);

  // string status = 4;
  void clear_status();
  static const int kStatusFieldNumber = 4;
  const ::std::string& status() const;
  void set_status(const ::std::string& value);
  #if LANG_CXX11
  void set_status(::std::string&& value);
  #endif
  void set_status(const char* value);
  void set_status(const char* value, size_t size);
  ::std::string* mutable_status();
  ::std::string* release_status();
  void set_allocated_status(::std::string* status);

  // @@protoc_insertion_point(class_scope:ric.logic.v3.WaitCondition)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr timeout_;
  ::google::protobuf::internal::ArenaStringPtr event_;
  ::google::protobuf::internal::ArenaStringPtr state_;
  ::google::protobuf::internal::ArenaStringPtr status_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_ric_2dlogic_2dv3_2friclogicv3_2eproto;
};
// -------------------------------------------------------------------

class GetInstanceInfoRequest final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:ric.logic.v3.GetInstanceInfoRequest) */ {
 public:
  GetInstanceInfoRequest();
  virtual ~GetInstanceInfoRequest();

  GetInstanceInfoRequest(const GetInstanceInfoRequest& from);

  inline GetInstanceInfoRequest& operator=(const GetInstanceInfoRequest& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  GetInstanceInfoRequest(GetInstanceInfoRequest&& from) noexcept
    : GetInstanceInfoRequest() {
    *this = ::std::move(from);
  }

  inline GetInstanceInfoRequest& operator=(GetInstanceInfoRequest&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const GetInstanceInfoRequest& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const GetInstanceInfoRequest* internal_default_instance() {
    return reinterpret_cast<const GetInstanceInfoRequest*>(
               &_GetInstanceInfoRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    10;

  void Swap(GetInstanceInfoRequest* other);
  friend void swap(GetInstanceInfoRequest& a, GetInstanceInfoRequest& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline GetInstanceInfoRequest* New() const final {
    return CreateMaybeMessage<GetInstanceInfoRequest>(nullptr);
  }

  GetInstanceInfoRequest* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<GetInstanceInfoRequest>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const GetInstanceInfoRequest& from);
  void MergeFrom(const GetInstanceInfoRequest& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetInstanceInfoRequest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:ric.logic.v3.GetInstanceInfoRequest)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_ric_2dlogic_2dv3_2friclogicv3_2eproto;
};
// -------------------------------------------------------------------

class GetInstanceInfoResponse final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:ric.logic.v3.GetInstanceInfoResponse) */ {
 public:
  GetInstanceInfoResponse();
  virtual ~GetInstanceInfoResponse();

  GetInstanceInfoResponse(const GetInstanceInfoResponse& from);

  inline GetInstanceInfoResponse& operator=(const GetInstanceInfoResponse& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  GetInstanceInfoResponse(GetInstanceInfoResponse&& from) noexcept
    : GetInstanceInfoResponse() {
    *this = ::std::move(from);
  }

  inline GetInstanceInfoResponse& operator=(GetInstanceInfoResponse&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const GetInstanceInfoResponse& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const GetInstanceInfoResponse* internal_default_instance() {
    return reinterpret_cast<const GetInstanceInfoResponse*>(
               &_GetInstanceInfoResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    11;

  void Swap(GetInstanceInfoResponse* other);
  friend void swap(GetInstanceInfoResponse& a, GetInstanceInfoResponse& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline GetInstanceInfoResponse* New() const final {
    return CreateMaybeMessage<GetInstanceInfoResponse>(nullptr);
  }

  GetInstanceInfoResponse* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<GetInstanceInfoResponse>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const GetInstanceInfoResponse& from);
  void MergeFrom(const GetInstanceInfoResponse& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetInstanceInfoResponse* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated string object_ids = 7;
  int object_ids_size() const;
  void clear_object_ids();
  static const int kObjectIdsFieldNumber = 7;
  const ::std::string& object_ids(int index) const;
  ::std::string* mutable_object_ids(int index);
  void set_object_ids(int index, const ::std::string& value);
  #if LANG_CXX11
  void set_object_ids(int index, ::std::string&& value);
  #endif
  void set_object_ids(int index, const char* value);
  void set_object_ids(int index, const char* value, size_t size);
  ::std::string* add_object_ids();
  void add_object_ids(const ::std::string& value);
  #if LANG_CXX11
  void add_object_ids(::std::string&& value);
  #endif
  void add_object_ids(const char* value);
  void add_object_ids(const char* value, size_t size);
  const ::google::protobuf::RepeatedPtrField<::std::string>& object_ids() const;
  ::google::protobuf::RepeatedPtrField<::std::string>* mutable_object_ids();

  // string hostname = 1;
  void clear_hostname();
  static const int kHostnameFieldNumber = 1;
  const ::std::string& hostname() const;
  void set_hostname(const ::std::string& value);
  #if LANG_CXX11
  void set_hostname(::std::string&& value);
  #endif
  void set_hostname(const char* value);
  void set_hostname(const char* value, size_t size);
  ::std::string* mutable_hostname();
  ::std::string* release_hostname();
  void set_allocated_hostname(::std::string* hostname);

  // string status = 2;
  void clear_status();
  static const int kStatusFieldNumber = 2;
  const ::std::string& status() const;
  void set_status(const ::std::string& value);
  #if LANG_CXX11
  void set_status(::std::string&& value);
  #endif
  void set_status(const char* value);
  void set_status(const char* value, size_t size);
  ::std::string* mutable_status();
  ::std::string* release_status();
  void set_allocated_status(::std::string* status);

  // int64 started_at = 3;
  void clear_started_at();
  static const int kStartedAtFieldNumber = 3;
  ::google::protobuf::int64 started_at() const;
  void set_started_at(::google::protobuf::int64 value);

  // int64 objects_total = 4;
  void clear_objects_total();
  static const int kObjectsTotalFieldNumber = 4;
  ::google::protobuf::int64 objects_total() const;
  void set_objects_total(::google::protobuf::int64 value);

  // int64 containers_total = 5;
  void clear_containers_total();
  static const int kContainersTotalFieldNumber = 5;
  ::google::protobuf::int64 containers_total() const;
  void set_containers_total(::google::protobuf::int64 value);

  // int64 containers_running = 6;
  void clear_containers_running();
  static const int kContainersRunningFieldNumber = 6;
  ::google::protobuf::int64 containers_running() const;
  void set_containers_running(::google::protobuf::int64 value);

  // @@protoc_insertion_point(class_scope:ric.logic.v3.GetInstanceInfoResponse)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField<::std::string> object_ids_;
  ::google::protobuf::internal::ArenaStringPtr hostname_;
  ::google::protobuf::internal::ArenaStringPtr status_;
  ::google::protobuf::int64 started_at_;
  ::google::protobuf::int64 objects_total_;
  ::google::protobuf::int64 containers_total_;
  ::google::protobuf::int64 containers_running_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_ric_2dlogic_2dv3_2friclogicv3_2eproto;
};
// -------------------------------------------------------------------

class StartAutomatonRequest_VarsEntry_DoNotUse : public ::google::protobuf::internal::MapEntry<StartAutomatonRequest_VarsEntry_DoNotUse, 
    ::std::string, ::ric::logic::v3::AutomatonVarValue,
    ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
    ::google::protobuf::internal::WireFormatLite::TYPE_MESSAGE,
    0 > {
public:
#if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
static bool _ParseMap(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
#endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  typedef ::google::protobuf::internal::MapEntry<StartAutomatonRequest_VarsEntry_DoNotUse, 
    ::std::string, ::ric::logic::v3::AutomatonVarValue,
    ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
    ::google::protobuf::internal::WireFormatLite::TYPE_MESSAGE,
    0 > SuperType;
  StartAutomatonRequest_VarsEntry_DoNotUse();
  StartAutomatonRequest_VarsEntry_DoNotUse(::google::protobuf::Arena* arena);
  void MergeFrom(const StartAutomatonRequest_VarsEntry_DoNotUse& other);
  static const StartAutomatonRequest_VarsEntry_DoNotUse* internal_default_instance() { return reinterpret_cast<const StartAutomatonRequest_VarsEntry_DoNotUse*>(&_StartAutomatonRequest_VarsEntry_DoNotUse_default_instance_); }
  void MergeFrom(const ::google::protobuf::Message& other) final;
  ::google::protobuf::Metadata GetMetadata() const;
};

// -------------------------------------------------------------------

class StartAutomatonRequest final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:ric.logic.v3.StartAutomatonRequest) */ {
 public:
  StartAutomatonRequest();
  virtual ~StartAutomatonRequest();

  StartAutomatonRequest(const StartAutomatonRequest& from);

  inline StartAutomatonRequest& operator=(const StartAutomatonRequest& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  StartAutomatonRequest(StartAutomatonRequest&& from) noexcept
    : StartAutomatonRequest() {
    *this = ::std::move(from);
  }

  inline StartAutomatonRequest& operator=(StartAutomatonRequest&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const StartAutomatonRequest& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const StartAutomatonRequest* internal_default_instance() {
    return reinterpret_cast<const StartAutomatonRequest*>(
               &_StartAutomatonRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    13;

  void Swap(StartAutomatonRequest* other);
  friend void swap(StartAutomatonRequest& a, StartAutomatonRequest& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline StartAutomatonRequest* New() const final {
    return CreateMaybeMessage<StartAutomatonRequest>(nullptr);
  }

  StartAutomatonRequest* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<StartAutomatonRequest>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const StartAutomatonRequest& from);
  void MergeFrom(const StartAutomatonRequest& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(StartAutomatonRequest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------


  // accessors -------------------------------------------------------

  // map<string, .ric.logic.v3.AutomatonVarValue> vars = 4;
  int vars_size() const;
  void clear_vars();
  static const int kVarsFieldNumber = 4;
  const ::google::protobuf::Map< ::std::string, ::ric::logic::v3::AutomatonVarValue >&
      vars() const;
  ::google::protobuf::Map< ::std::string, ::ric::logic::v3::AutomatonVarValue >*
      mutable_vars();

  // string object_id = 2;
  void clear_object_id();
  static const int kObjectIdFieldNumber = 2;
  const ::std::string& object_id() const;
  void set_object_id(const ::std::string& value);
  #if LANG_CXX11
  void set_object_id(::std::string&& value);
  #endif
  void set_object_id(const char* value);
  void set_object_id(const char* value, size_t size);
  ::std::string* mutable_object_id();
  ::std::string* release_object_id();
  void set_allocated_object_id(::std::string* object_id);

  // string automaton_id = 3;
  void clear_automaton_id();
  static const int kAutomatonIdFieldNumber = 3;
  const ::std::string& automaton_id() const;
  void set_automaton_id(const ::std::string& value);
  #if LANG_CXX11
  void set_automaton_id(::std::string&& value);
  #endif
  void set_automaton_id(const char* value);
  void set_automaton_id(const char* value, size_t size);
  ::std::string* mutable_automaton_id();
  ::std::string* release_automaton_id();
  void set_allocated_automaton_id(::std::string* automaton_id);

  // .ric.logic.v3.UserContext ctx = 1;
  bool has_ctx() const;
  void clear_ctx();
  static const int kCtxFieldNumber = 1;
  const ::ric::logic::v3::UserContext& ctx() const;
  ::ric::logic::v3::UserContext* release_ctx();
  ::ric::logic::v3::UserContext* mutable_ctx();
  void set_allocated_ctx(::ric::logic::v3::UserContext* ctx);

  // @@protoc_insertion_point(class_scope:ric.logic.v3.StartAutomatonRequest)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::MapField<
      StartAutomatonRequest_VarsEntry_DoNotUse,
      ::std::string, ::ric::logic::v3::AutomatonVarValue,
      ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
      ::google::protobuf::internal::WireFormatLite::TYPE_MESSAGE,
      0 > vars_;
  ::google::protobuf::internal::ArenaStringPtr object_id_;
  ::google::protobuf::internal::ArenaStringPtr automaton_id_;
  ::ric::logic::v3::UserContext* ctx_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_ric_2dlogic_2dv3_2friclogicv3_2eproto;
};
// -------------------------------------------------------------------

class StartAutomatonMultiRequest final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:ric.logic.v3.StartAutomatonMultiRequest) */ {
 public:
  StartAutomatonMultiRequest();
  virtual ~StartAutomatonMultiRequest();

  StartAutomatonMultiRequest(const StartAutomatonMultiRequest& from);

  inline StartAutomatonMultiRequest& operator=(const StartAutomatonMultiRequest& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  StartAutomatonMultiRequest(StartAutomatonMultiRequest&& from) noexcept
    : StartAutomatonMultiRequest() {
    *this = ::std::move(from);
  }

  inline StartAutomatonMultiRequest& operator=(StartAutomatonMultiRequest&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const StartAutomatonMultiRequest& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const StartAutomatonMultiRequest* internal_default_instance() {
    return reinterpret_cast<const StartAutomatonMultiRequest*>(
               &_StartAutomatonMultiRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    14;

  void Swap(StartAutomatonMultiRequest* other);
  friend void swap(StartAutomatonMultiRequest& a, StartAutomatonMultiRequest& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline StartAutomatonMultiRequest* New() const final {
    return CreateMaybeMessage<StartAutomatonMultiRequest>(nullptr);
  }

  StartAutomatonMultiRequest* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<StartAutomatonMultiRequest>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const StartAutomatonMultiRequest& from);
  void MergeFrom(const StartAutomatonMultiRequest& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(StartAutomatonMultiRequest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated string object_ids = 2;
  int object_ids_size() const;
  void clear_object_ids();
  static const int kObjectIdsFieldNumber = 2;
  const ::std::string& object_ids(int index) const;
  ::std::string* mutable_object_ids(int index);
  void set_object_ids(int index, const ::std::string& value);
  #if LANG_CXX11
  void set_object_ids(int index, ::std::string&& value);
  #endif
  void set_object_ids(int index, const char* value);
  void set_object_ids(int index, const char* value, size_t size);
  ::std::string* add_object_ids();
  void add_object_ids(const ::std::string& value);
  #if LANG_CXX11
  void add_object_ids(::std::string&& value);
  #endif
  void add_object_ids(const char* value);
  void add_object_ids(const char* value, size_t size);
  const ::google::protobuf::RepeatedPtrField<::std::string>& object_ids() const;
  ::google::protobuf::RepeatedPtrField<::std::string>* mutable_object_ids();

  // string automaton_id = 3;
  void clear_automaton_id();
  static const int kAutomatonIdFieldNumber = 3;
  const ::std::string& automaton_id() const;
  void set_automaton_id(const ::std::string& value);
  #if LANG_CXX11
  void set_automaton_id(::std::string&& value);
  #endif
  void set_automaton_id(const char* value);
  void set_automaton_id(const char* value, size_t size);
  ::std::string* mutable_automaton_id();
  ::std::string* release_automaton_id();
  void set_allocated_automaton_id(::std::string* automaton_id);

  // .ric.logic.v3.UserContext ctx = 1;
  bool has_ctx() const;
  void clear_ctx();
  static const int kCtxFieldNumber = 1;
  const ::ric::logic::v3::UserContext& ctx() const;
  ::ric::logic::v3::UserContext* release_ctx();
  ::ric::logic::v3::UserContext* mutable_ctx();
  void set_allocated_ctx(::ric::logic::v3::UserContext* ctx);

  // @@protoc_insertion_point(class_scope:ric.logic.v3.StartAutomatonMultiRequest)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField<::std::string> object_ids_;
  ::google::protobuf::internal::ArenaStringPtr automaton_id_;
  ::ric::logic::v3::UserContext* ctx_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_ric_2dlogic_2dv3_2friclogicv3_2eproto;
};
// -------------------------------------------------------------------

class StartAutomatonResponse final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:ric.logic.v3.StartAutomatonResponse) */ {
 public:
  StartAutomatonResponse();
  virtual ~StartAutomatonResponse();

  StartAutomatonResponse(const StartAutomatonResponse& from);

  inline StartAutomatonResponse& operator=(const StartAutomatonResponse& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  StartAutomatonResponse(StartAutomatonResponse&& from) noexcept
    : StartAutomatonResponse() {
    *this = ::std::move(from);
  }

  inline StartAutomatonResponse& operator=(StartAutomatonResponse&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const StartAutomatonResponse& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const StartAutomatonResponse* internal_default_instance() {
    return reinterpret_cast<const StartAutomatonResponse*>(
               &_StartAutomatonResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    15;

  void Swap(StartAutomatonResponse* other);
  friend void swap(StartAutomatonResponse& a, StartAutomatonResponse& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline StartAutomatonResponse* New() const final {
    return CreateMaybeMessage<StartAutomatonResponse>(nullptr);
  }

  StartAutomatonResponse* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<StartAutomatonResponse>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const StartAutomatonResponse& from);
  void MergeFrom(const StartAutomatonResponse& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(StartAutomatonResponse* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .ric.logic.v3.AutomatonInfo automaton = 1;
  bool has_automaton() const;
  void clear_automaton();
  static const int kAutomatonFieldNumber = 1;
  const ::ric::logic::v3::AutomatonInfo& automaton() const;
  ::ric::logic::v3::AutomatonInfo* release_automaton();
  ::ric::logic::v3::AutomatonInfo* mutable_automaton();
  void set_allocated_automaton(::ric::logic::v3::AutomatonInfo* automaton);

  // @@protoc_insertion_point(class_scope:ric.logic.v3.StartAutomatonResponse)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::ric::logic::v3::AutomatonInfo* automaton_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_ric_2dlogic_2dv3_2friclogicv3_2eproto;
};
// -------------------------------------------------------------------

class StopAutomatonRequest final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:ric.logic.v3.StopAutomatonRequest) */ {
 public:
  StopAutomatonRequest();
  virtual ~StopAutomatonRequest();

  StopAutomatonRequest(const StopAutomatonRequest& from);

  inline StopAutomatonRequest& operator=(const StopAutomatonRequest& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  StopAutomatonRequest(StopAutomatonRequest&& from) noexcept
    : StopAutomatonRequest() {
    *this = ::std::move(from);
  }

  inline StopAutomatonRequest& operator=(StopAutomatonRequest&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const StopAutomatonRequest& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const StopAutomatonRequest* internal_default_instance() {
    return reinterpret_cast<const StopAutomatonRequest*>(
               &_StopAutomatonRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    16;

  void Swap(StopAutomatonRequest* other);
  friend void swap(StopAutomatonRequest& a, StopAutomatonRequest& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline StopAutomatonRequest* New() const final {
    return CreateMaybeMessage<StopAutomatonRequest>(nullptr);
  }

  StopAutomatonRequest* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<StopAutomatonRequest>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const StopAutomatonRequest& from);
  void MergeFrom(const StopAutomatonRequest& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(StopAutomatonRequest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string object_id = 2;
  void clear_object_id();
  static const int kObjectIdFieldNumber = 2;
  const ::std::string& object_id() const;
  void set_object_id(const ::std::string& value);
  #if LANG_CXX11
  void set_object_id(::std::string&& value);
  #endif
  void set_object_id(const char* value);
  void set_object_id(const char* value, size_t size);
  ::std::string* mutable_object_id();
  ::std::string* release_object_id();
  void set_allocated_object_id(::std::string* object_id);

  // string automaton_id = 3;
  void clear_automaton_id();
  static const int kAutomatonIdFieldNumber = 3;
  const ::std::string& automaton_id() const;
  void set_automaton_id(const ::std::string& value);
  #if LANG_CXX11
  void set_automaton_id(::std::string&& value);
  #endif
  void set_automaton_id(const char* value);
  void set_automaton_id(const char* value, size_t size);
  ::std::string* mutable_automaton_id();
  ::std::string* release_automaton_id();
  void set_allocated_automaton_id(::std::string* automaton_id);

  // .ric.logic.v3.UserContext ctx = 1;
  bool has_ctx() const;
  void clear_ctx();
  static const int kCtxFieldNumber = 1;
  const ::ric::logic::v3::UserContext& ctx() const;
  ::ric::logic::v3::UserContext* release_ctx();
  ::ric::logic::v3::UserContext* mutable_ctx();
  void set_allocated_ctx(::ric::logic::v3::UserContext* ctx);

  // @@protoc_insertion_point(class_scope:ric.logic.v3.StopAutomatonRequest)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr object_id_;
  ::google::protobuf::internal::ArenaStringPtr automaton_id_;
  ::ric::logic::v3::UserContext* ctx_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_ric_2dlogic_2dv3_2friclogicv3_2eproto;
};
// -------------------------------------------------------------------

class RunAutomatonRequest_VarsEntry_DoNotUse : public ::google::protobuf::internal::MapEntry<RunAutomatonRequest_VarsEntry_DoNotUse, 
    ::std::string, ::ric::logic::v3::AutomatonVarValue,
    ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
    ::google::protobuf::internal::WireFormatLite::TYPE_MESSAGE,
    0 > {
public:
#if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
static bool _ParseMap(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
#endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  typedef ::google::protobuf::internal::MapEntry<RunAutomatonRequest_VarsEntry_DoNotUse, 
    ::std::string, ::ric::logic::v3::AutomatonVarValue,
    ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
    ::google::protobuf::internal::WireFormatLite::TYPE_MESSAGE,
    0 > SuperType;
  RunAutomatonRequest_VarsEntry_DoNotUse();
  RunAutomatonRequest_VarsEntry_DoNotUse(::google::protobuf::Arena* arena);
  void MergeFrom(const RunAutomatonRequest_VarsEntry_DoNotUse& other);
  static const RunAutomatonRequest_VarsEntry_DoNotUse* internal_default_instance() { return reinterpret_cast<const RunAutomatonRequest_VarsEntry_DoNotUse*>(&_RunAutomatonRequest_VarsEntry_DoNotUse_default_instance_); }
  void MergeFrom(const ::google::protobuf::Message& other) final;
  ::google::protobuf::Metadata GetMetadata() const;
};

// -------------------------------------------------------------------

class RunAutomatonRequest final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:ric.logic.v3.RunAutomatonRequest) */ {
 public:
  RunAutomatonRequest();
  virtual ~RunAutomatonRequest();

  RunAutomatonRequest(const RunAutomatonRequest& from);

  inline RunAutomatonRequest& operator=(const RunAutomatonRequest& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  RunAutomatonRequest(RunAutomatonRequest&& from) noexcept
    : RunAutomatonRequest() {
    *this = ::std::move(from);
  }

  inline RunAutomatonRequest& operator=(RunAutomatonRequest&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const RunAutomatonRequest& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const RunAutomatonRequest* internal_default_instance() {
    return reinterpret_cast<const RunAutomatonRequest*>(
               &_RunAutomatonRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    18;

  void Swap(RunAutomatonRequest* other);
  friend void swap(RunAutomatonRequest& a, RunAutomatonRequest& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline RunAutomatonRequest* New() const final {
    return CreateMaybeMessage<RunAutomatonRequest>(nullptr);
  }

  RunAutomatonRequest* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<RunAutomatonRequest>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const RunAutomatonRequest& from);
  void MergeFrom(const RunAutomatonRequest& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RunAutomatonRequest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------


  // accessors -------------------------------------------------------

  // map<string, .ric.logic.v3.AutomatonVarValue> vars = 7;
  int vars_size() const;
  void clear_vars();
  static const int kVarsFieldNumber = 7;
  const ::google::protobuf::Map< ::std::string, ::ric::logic::v3::AutomatonVarValue >&
      vars() const;
  ::google::protobuf::Map< ::std::string, ::ric::logic::v3::AutomatonVarValue >*
      mutable_vars();

  // string object_id = 2;
  void clear_object_id();
  static const int kObjectIdFieldNumber = 2;
  const ::std::string& object_id() const;
  void set_object_id(const ::std::string& value);
  #if LANG_CXX11
  void set_object_id(::std::string&& value);
  #endif
  void set_object_id(const char* value);
  void set_object_id(const char* value, size_t size);
  ::std::string* mutable_object_id();
  ::std::string* release_object_id();
  void set_allocated_object_id(::std::string* object_id);

  // string automaton_id = 3;
  void clear_automaton_id();
  static const int kAutomatonIdFieldNumber = 3;
  const ::std::string& automaton_id() const;
  void set_automaton_id(const ::std::string& value);
  #if LANG_CXX11
  void set_automaton_id(::std::string&& value);
  #endif
  void set_automaton_id(const char* value);
  void set_automaton_id(const char* value, size_t size);
  ::std::string* mutable_automaton_id();
  ::std::string* release_automaton_id();
  void set_allocated_automaton_id(::std::string* automaton_id);

  // string on_running = 6;
  void clear_on_running();
  static const int kOnRunningFieldNumber = 6;
  const ::std::string& on_running() const;
  void set_on_running(const ::std::string& value);
  #if LANG_CXX11
  void set_on_running(::std::string&& value);
  #endif
  void set_on_running(const char* value);
  void set_on_running(const char* value, size_t size);
  ::std::string* mutable_on_running();
  ::std::string* release_on_running();
  void set_allocated_on_running(::std::string* on_running);

  // .ric.logic.v3.UserContext ctx = 1;
  bool has_ctx() const;
  void clear_ctx();
  static const int kCtxFieldNumber = 1;
  const ::ric::logic::v3::UserContext& ctx() const;
  ::ric::logic::v3::UserContext* release_ctx();
  ::ric::logic::v3::UserContext* mutable_ctx();
  void set_allocated_ctx(::ric::logic::v3::UserContext* ctx);

  // .ric.logic.v3.WaitCondition wait = 4;
  bool has_wait() const;
  void clear_wait();
  static const int kWaitFieldNumber = 4;
  const ::ric::logic::v3::WaitCondition& wait() const;
  ::ric::logic::v3::WaitCondition* release_wait();
  ::ric::logic::v3::WaitCondition* mutable_wait();
  void set_allocated_wait(::ric::logic::v3::WaitCondition* wait);

  // @@protoc_insertion_point(class_scope:ric.logic.v3.RunAutomatonRequest)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::MapField<
      RunAutomatonRequest_VarsEntry_DoNotUse,
      ::std::string, ::ric::logic::v3::AutomatonVarValue,
      ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
      ::google::protobuf::internal::WireFormatLite::TYPE_MESSAGE,
      0 > vars_;
  ::google::protobuf::internal::ArenaStringPtr object_id_;
  ::google::protobuf::internal::ArenaStringPtr automaton_id_;
  ::google::protobuf::internal::ArenaStringPtr on_running_;
  ::ric::logic::v3::UserContext* ctx_;
  ::ric::logic::v3::WaitCondition* wait_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_ric_2dlogic_2dv3_2friclogicv3_2eproto;
};
// -------------------------------------------------------------------

class StopAutomatonResponse final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:ric.logic.v3.StopAutomatonResponse) */ {
 public:
  StopAutomatonResponse();
  virtual ~StopAutomatonResponse();

  StopAutomatonResponse(const StopAutomatonResponse& from);

  inline StopAutomatonResponse& operator=(const StopAutomatonResponse& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  StopAutomatonResponse(StopAutomatonResponse&& from) noexcept
    : StopAutomatonResponse() {
    *this = ::std::move(from);
  }

  inline StopAutomatonResponse& operator=(StopAutomatonResponse&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const StopAutomatonResponse& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const StopAutomatonResponse* internal_default_instance() {
    return reinterpret_cast<const StopAutomatonResponse*>(
               &_StopAutomatonResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    19;

  void Swap(StopAutomatonResponse* other);
  friend void swap(StopAutomatonResponse& a, StopAutomatonResponse& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline StopAutomatonResponse* New() const final {
    return CreateMaybeMessage<StopAutomatonResponse>(nullptr);
  }

  StopAutomatonResponse* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<StopAutomatonResponse>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const StopAutomatonResponse& from);
  void MergeFrom(const StopAutomatonResponse& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(StopAutomatonResponse* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .ric.logic.v3.AutomatonInfo automaton = 1;
  bool has_automaton() const;
  void clear_automaton();
  static const int kAutomatonFieldNumber = 1;
  const ::ric::logic::v3::AutomatonInfo& automaton() const;
  ::ric::logic::v3::AutomatonInfo* release_automaton();
  ::ric::logic::v3::AutomatonInfo* mutable_automaton();
  void set_allocated_automaton(::ric::logic::v3::AutomatonInfo* automaton);

  // @@protoc_insertion_point(class_scope:ric.logic.v3.StopAutomatonResponse)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::ric::logic::v3::AutomatonInfo* automaton_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_ric_2dlogic_2dv3_2friclogicv3_2eproto;
};
// -------------------------------------------------------------------

class GetAutomatonsRequest final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:ric.logic.v3.GetAutomatonsRequest) */ {
 public:
  GetAutomatonsRequest();
  virtual ~GetAutomatonsRequest();

  GetAutomatonsRequest(const GetAutomatonsRequest& from);

  inline GetAutomatonsRequest& operator=(const GetAutomatonsRequest& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  GetAutomatonsRequest(GetAutomatonsRequest&& from) noexcept
    : GetAutomatonsRequest() {
    *this = ::std::move(from);
  }

  inline GetAutomatonsRequest& operator=(GetAutomatonsRequest&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const GetAutomatonsRequest& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const GetAutomatonsRequest* internal_default_instance() {
    return reinterpret_cast<const GetAutomatonsRequest*>(
               &_GetAutomatonsRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    20;

  void Swap(GetAutomatonsRequest* other);
  friend void swap(GetAutomatonsRequest& a, GetAutomatonsRequest& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline GetAutomatonsRequest* New() const final {
    return CreateMaybeMessage<GetAutomatonsRequest>(nullptr);
  }

  GetAutomatonsRequest* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<GetAutomatonsRequest>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const GetAutomatonsRequest& from);
  void MergeFrom(const GetAutomatonsRequest& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetAutomatonsRequest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated string object_ids = 1;
  int object_ids_size() const;
  void clear_object_ids();
  static const int kObjectIdsFieldNumber = 1;
  const ::std::string& object_ids(int index) const;
  ::std::string* mutable_object_ids(int index);
  void set_object_ids(int index, const ::std::string& value);
  #if LANG_CXX11
  void set_object_ids(int index, ::std::string&& value);
  #endif
  void set_object_ids(int index, const char* value);
  void set_object_ids(int index, const char* value, size_t size);
  ::std::string* add_object_ids();
  void add_object_ids(const ::std::string& value);
  #if LANG_CXX11
  void add_object_ids(::std::string&& value);
  #endif
  void add_object_ids(const char* value);
  void add_object_ids(const char* value, size_t size);
  const ::google::protobuf::RepeatedPtrField<::std::string>& object_ids() const;
  ::google::protobuf::RepeatedPtrField<::std::string>* mutable_object_ids();

  // repeated string automaton_ids = 2;
  int automaton_ids_size() const;
  void clear_automaton_ids();
  static const int kAutomatonIdsFieldNumber = 2;
  const ::std::string& automaton_ids(int index) const;
  ::std::string* mutable_automaton_ids(int index);
  void set_automaton_ids(int index, const ::std::string& value);
  #if LANG_CXX11
  void set_automaton_ids(int index, ::std::string&& value);
  #endif
  void set_automaton_ids(int index, const char* value);
  void set_automaton_ids(int index, const char* value, size_t size);
  ::std::string* add_automaton_ids();
  void add_automaton_ids(const ::std::string& value);
  #if LANG_CXX11
  void add_automaton_ids(::std::string&& value);
  #endif
  void add_automaton_ids(const char* value);
  void add_automaton_ids(const char* value, size_t size);
  const ::google::protobuf::RepeatedPtrField<::std::string>& automaton_ids() const;
  ::google::protobuf::RepeatedPtrField<::std::string>* mutable_automaton_ids();

  // bool with_logs = 3;
  void clear_with_logs();
  static const int kWithLogsFieldNumber = 3;
  bool with_logs() const;
  void set_with_logs(bool value);

  // bool watch = 4;
  void clear_watch();
  static const int kWatchFieldNumber = 4;
  bool watch() const;
  void set_watch(bool value);

  // @@protoc_insertion_point(class_scope:ric.logic.v3.GetAutomatonsRequest)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField<::std::string> object_ids_;
  ::google::protobuf::RepeatedPtrField<::std::string> automaton_ids_;
  bool with_logs_;
  bool watch_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_ric_2dlogic_2dv3_2friclogicv3_2eproto;
};
// -------------------------------------------------------------------

class GetAutomatonsResponse final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:ric.logic.v3.GetAutomatonsResponse) */ {
 public:
  GetAutomatonsResponse();
  virtual ~GetAutomatonsResponse();

  GetAutomatonsResponse(const GetAutomatonsResponse& from);

  inline GetAutomatonsResponse& operator=(const GetAutomatonsResponse& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  GetAutomatonsResponse(GetAutomatonsResponse&& from) noexcept
    : GetAutomatonsResponse() {
    *this = ::std::move(from);
  }

  inline GetAutomatonsResponse& operator=(GetAutomatonsResponse&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const GetAutomatonsResponse& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const GetAutomatonsResponse* internal_default_instance() {
    return reinterpret_cast<const GetAutomatonsResponse*>(
               &_GetAutomatonsResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    21;

  void Swap(GetAutomatonsResponse* other);
  friend void swap(GetAutomatonsResponse& a, GetAutomatonsResponse& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline GetAutomatonsResponse* New() const final {
    return CreateMaybeMessage<GetAutomatonsResponse>(nullptr);
  }

  GetAutomatonsResponse* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<GetAutomatonsResponse>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const GetAutomatonsResponse& from);
  void MergeFrom(const GetAutomatonsResponse& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetAutomatonsResponse* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .ric.logic.v3.AutomatonInfo automatons = 1;
  int automatons_size() const;
  void clear_automatons();
  static const int kAutomatonsFieldNumber = 1;
  ::ric::logic::v3::AutomatonInfo* mutable_automatons(int index);
  ::google::protobuf::RepeatedPtrField< ::ric::logic::v3::AutomatonInfo >*
      mutable_automatons();
  const ::ric::logic::v3::AutomatonInfo& automatons(int index) const;
  ::ric::logic::v3::AutomatonInfo* add_automatons();
  const ::google::protobuf::RepeatedPtrField< ::ric::logic::v3::AutomatonInfo >&
      automatons() const;

  // @@protoc_insertion_point(class_scope:ric.logic.v3.GetAutomatonsResponse)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::ric::logic::v3::AutomatonInfo > automatons_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_ric_2dlogic_2dv3_2friclogicv3_2eproto;
};
// -------------------------------------------------------------------

class EmitEventRequest final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:ric.logic.v3.EmitEventRequest) */ {
 public:
  EmitEventRequest();
  virtual ~EmitEventRequest();

  EmitEventRequest(const EmitEventRequest& from);

  inline EmitEventRequest& operator=(const EmitEventRequest& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  EmitEventRequest(EmitEventRequest&& from) noexcept
    : EmitEventRequest() {
    *this = ::std::move(from);
  }

  inline EmitEventRequest& operator=(EmitEventRequest&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const EmitEventRequest& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const EmitEventRequest* internal_default_instance() {
    return reinterpret_cast<const EmitEventRequest*>(
               &_EmitEventRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    22;

  void Swap(EmitEventRequest* other);
  friend void swap(EmitEventRequest& a, EmitEventRequest& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline EmitEventRequest* New() const final {
    return CreateMaybeMessage<EmitEventRequest>(nullptr);
  }

  EmitEventRequest* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<EmitEventRequest>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const EmitEventRequest& from);
  void MergeFrom(const EmitEventRequest& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(EmitEventRequest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string object_id = 2;
  void clear_object_id();
  static const int kObjectIdFieldNumber = 2;
  const ::std::string& object_id() const;
  void set_object_id(const ::std::string& value);
  #if LANG_CXX11
  void set_object_id(::std::string&& value);
  #endif
  void set_object_id(const char* value);
  void set_object_id(const char* value, size_t size);
  ::std::string* mutable_object_id();
  ::std::string* release_object_id();
  void set_allocated_object_id(::std::string* object_id);

  // string automaton_id = 3;
  void clear_automaton_id();
  static const int kAutomatonIdFieldNumber = 3;
  const ::std::string& automaton_id() const;
  void set_automaton_id(const ::std::string& value);
  #if LANG_CXX11
  void set_automaton_id(::std::string&& value);
  #endif
  void set_automaton_id(const char* value);
  void set_automaton_id(const char* value, size_t size);
  ::std::string* mutable_automaton_id();
  ::std::string* release_automaton_id();
  void set_allocated_automaton_id(::std::string* automaton_id);

  // string event = 4;
  void clear_event();
  static const int kEventFieldNumber = 4;
  const ::std::string& event() const;
  void set_event(const ::std::string& value);
  #if LANG_CXX11
  void set_event(::std::string&& value);
  #endif
  void set_event(const char* value);
  void set_event(const char* value, size_t size);
  ::std::string* mutable_event();
  ::std::string* release_event();
  void set_allocated_event(::std::string* event);

  // string payload = 5;
  void clear_payload();
  static const int kPayloadFieldNumber = 5;
  const ::std::string& payload() const;
  void set_payload(const ::std::string& value);
  #if LANG_CXX11
  void set_payload(::std::string&& value);
  #endif
  void set_payload(const char* value);
  void set_payload(const char* value, size_t size);
  ::std::string* mutable_payload();
  ::std::string* release_payload();
  void set_allocated_payload(::std::string* payload);

  // .ric.logic.v3.UserContext ctx = 1;
  bool has_ctx() const;
  void clear_ctx();
  static const int kCtxFieldNumber = 1;
  const ::ric::logic::v3::UserContext& ctx() const;
  ::ric::logic::v3::UserContext* release_ctx();
  ::ric::logic::v3::UserContext* mutable_ctx();
  void set_allocated_ctx(::ric::logic::v3::UserContext* ctx);

  // @@protoc_insertion_point(class_scope:ric.logic.v3.EmitEventRequest)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr object_id_;
  ::google::protobuf::internal::ArenaStringPtr automaton_id_;
  ::google::protobuf::internal::ArenaStringPtr event_;
  ::google::protobuf::internal::ArenaStringPtr payload_;
  ::ric::logic::v3::UserContext* ctx_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_ric_2dlogic_2dv3_2friclogicv3_2eproto;
};
// -------------------------------------------------------------------

class EmitEventResponse final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:ric.logic.v3.EmitEventResponse) */ {
 public:
  EmitEventResponse();
  virtual ~EmitEventResponse();

  EmitEventResponse(const EmitEventResponse& from);

  inline EmitEventResponse& operator=(const EmitEventResponse& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  EmitEventResponse(EmitEventResponse&& from) noexcept
    : EmitEventResponse() {
    *this = ::std::move(from);
  }

  inline EmitEventResponse& operator=(EmitEventResponse&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const EmitEventResponse& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const EmitEventResponse* internal_default_instance() {
    return reinterpret_cast<const EmitEventResponse*>(
               &_EmitEventResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    23;

  void Swap(EmitEventResponse* other);
  friend void swap(EmitEventResponse& a, EmitEventResponse& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline EmitEventResponse* New() const final {
    return CreateMaybeMessage<EmitEventResponse>(nullptr);
  }

  EmitEventResponse* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<EmitEventResponse>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const EmitEventResponse& from);
  void MergeFrom(const EmitEventResponse& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(EmitEventResponse* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:ric.logic.v3.EmitEventResponse)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_ric_2dlogic_2dv3_2friclogicv3_2eproto;
};
// -------------------------------------------------------------------

class WaitEventRequest final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:ric.logic.v3.WaitEventRequest) */ {
 public:
  WaitEventRequest();
  virtual ~WaitEventRequest();

  WaitEventRequest(const WaitEventRequest& from);

  inline WaitEventRequest& operator=(const WaitEventRequest& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  WaitEventRequest(WaitEventRequest&& from) noexcept
    : WaitEventRequest() {
    *this = ::std::move(from);
  }

  inline WaitEventRequest& operator=(WaitEventRequest&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const WaitEventRequest& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const WaitEventRequest* internal_default_instance() {
    return reinterpret_cast<const WaitEventRequest*>(
               &_WaitEventRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    24;

  void Swap(WaitEventRequest* other);
  friend void swap(WaitEventRequest& a, WaitEventRequest& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline WaitEventRequest* New() const final {
    return CreateMaybeMessage<WaitEventRequest>(nullptr);
  }

  WaitEventRequest* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<WaitEventRequest>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const WaitEventRequest& from);
  void MergeFrom(const WaitEventRequest& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(WaitEventRequest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string object_id = 2;
  void clear_object_id();
  static const int kObjectIdFieldNumber = 2;
  const ::std::string& object_id() const;
  void set_object_id(const ::std::string& value);
  #if LANG_CXX11
  void set_object_id(::std::string&& value);
  #endif
  void set_object_id(const char* value);
  void set_object_id(const char* value, size_t size);
  ::std::string* mutable_object_id();
  ::std::string* release_object_id();
  void set_allocated_object_id(::std::string* object_id);

  // string automaton_id = 3;
  void clear_automaton_id();
  static const int kAutomatonIdFieldNumber = 3;
  const ::std::string& automaton_id() const;
  void set_automaton_id(const ::std::string& value);
  #if LANG_CXX11
  void set_automaton_id(::std::string&& value);
  #endif
  void set_automaton_id(const char* value);
  void set_automaton_id(const char* value, size_t size);
  ::std::string* mutable_automaton_id();
  ::std::string* release_automaton_id();
  void set_allocated_automaton_id(::std::string* automaton_id);

  // .ric.logic.v3.UserContext ctx = 1;
  bool has_ctx() const;
  void clear_ctx();
  static const int kCtxFieldNumber = 1;
  const ::ric::logic::v3::UserContext& ctx() const;
  ::ric::logic::v3::UserContext* release_ctx();
  ::ric::logic::v3::UserContext* mutable_ctx();
  void set_allocated_ctx(::ric::logic::v3::UserContext* ctx);

  // .ric.logic.v3.WaitCondition wait = 4;
  bool has_wait() const;
  void clear_wait();
  static const int kWaitFieldNumber = 4;
  const ::ric::logic::v3::WaitCondition& wait() const;
  ::ric::logic::v3::WaitCondition* release_wait();
  ::ric::logic::v3::WaitCondition* mutable_wait();
  void set_allocated_wait(::ric::logic::v3::WaitCondition* wait);

  // @@protoc_insertion_point(class_scope:ric.logic.v3.WaitEventRequest)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr object_id_;
  ::google::protobuf::internal::ArenaStringPtr automaton_id_;
  ::ric::logic::v3::UserContext* ctx_;
  ::ric::logic::v3::WaitCondition* wait_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_ric_2dlogic_2dv3_2friclogicv3_2eproto;
};
// -------------------------------------------------------------------

class WaitEventResponse final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:ric.logic.v3.WaitEventResponse) */ {
 public:
  WaitEventResponse();
  virtual ~WaitEventResponse();

  WaitEventResponse(const WaitEventResponse& from);

  inline WaitEventResponse& operator=(const WaitEventResponse& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  WaitEventResponse(WaitEventResponse&& from) noexcept
    : WaitEventResponse() {
    *this = ::std::move(from);
  }

  inline WaitEventResponse& operator=(WaitEventResponse&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const WaitEventResponse& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const WaitEventResponse* internal_default_instance() {
    return reinterpret_cast<const WaitEventResponse*>(
               &_WaitEventResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    25;

  void Swap(WaitEventResponse* other);
  friend void swap(WaitEventResponse& a, WaitEventResponse& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline WaitEventResponse* New() const final {
    return CreateMaybeMessage<WaitEventResponse>(nullptr);
  }

  WaitEventResponse* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<WaitEventResponse>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const WaitEventResponse& from);
  void MergeFrom(const WaitEventResponse& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(WaitEventResponse* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:ric.logic.v3.WaitEventResponse)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_ric_2dlogic_2dv3_2friclogicv3_2eproto;
};
// -------------------------------------------------------------------

class GetRuntimeInfoRequest final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:ric.logic.v3.GetRuntimeInfoRequest) */ {
 public:
  GetRuntimeInfoRequest();
  virtual ~GetRuntimeInfoRequest();

  GetRuntimeInfoRequest(const GetRuntimeInfoRequest& from);

  inline GetRuntimeInfoRequest& operator=(const GetRuntimeInfoRequest& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  GetRuntimeInfoRequest(GetRuntimeInfoRequest&& from) noexcept
    : GetRuntimeInfoRequest() {
    *this = ::std::move(from);
  }

  inline GetRuntimeInfoRequest& operator=(GetRuntimeInfoRequest&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const GetRuntimeInfoRequest& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const GetRuntimeInfoRequest* internal_default_instance() {
    return reinterpret_cast<const GetRuntimeInfoRequest*>(
               &_GetRuntimeInfoRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    26;

  void Swap(GetRuntimeInfoRequest* other);
  friend void swap(GetRuntimeInfoRequest& a, GetRuntimeInfoRequest& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline GetRuntimeInfoRequest* New() const final {
    return CreateMaybeMessage<GetRuntimeInfoRequest>(nullptr);
  }

  GetRuntimeInfoRequest* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<GetRuntimeInfoRequest>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const GetRuntimeInfoRequest& from);
  void MergeFrom(const GetRuntimeInfoRequest& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetRuntimeInfoRequest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string object_id = 1;
  void clear_object_id();
  static const int kObjectIdFieldNumber = 1;
  const ::std::string& object_id() const;
  void set_object_id(const ::std::string& value);
  #if LANG_CXX11
  void set_object_id(::std::string&& value);
  #endif
  void set_object_id(const char* value);
  void set_object_id(const char* value, size_t size);
  ::std::string* mutable_object_id();
  ::std::string* release_object_id();
  void set_allocated_object_id(::std::string* object_id);

  // string automaton_id = 2;
  void clear_automaton_id();
  static const int kAutomatonIdFieldNumber = 2;
  const ::std::string& automaton_id() const;
  void set_automaton_id(const ::std::string& value);
  #if LANG_CXX11
  void set_automaton_id(::std::string&& value);
  #endif
  void set_automaton_id(const char* value);
  void set_automaton_id(const char* value, size_t size);
  ::std::string* mutable_automaton_id();
  ::std::string* release_automaton_id();
  void set_allocated_automaton_id(::std::string* automaton_id);

  // @@protoc_insertion_point(class_scope:ric.logic.v3.GetRuntimeInfoRequest)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr object_id_;
  ::google::protobuf::internal::ArenaStringPtr automaton_id_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_ric_2dlogic_2dv3_2friclogicv3_2eproto;
};
// -------------------------------------------------------------------

class UpdateAutomatonVarsRequest_VarsEntry_DoNotUse : public ::google::protobuf::internal::MapEntry<UpdateAutomatonVarsRequest_VarsEntry_DoNotUse, 
    ::std::string, ::ric::logic::v3::AutomatonVarValue,
    ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
    ::google::protobuf::internal::WireFormatLite::TYPE_MESSAGE,
    0 > {
public:
#if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
static bool _ParseMap(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
#endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  typedef ::google::protobuf::internal::MapEntry<UpdateAutomatonVarsRequest_VarsEntry_DoNotUse, 
    ::std::string, ::ric::logic::v3::AutomatonVarValue,
    ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
    ::google::protobuf::internal::WireFormatLite::TYPE_MESSAGE,
    0 > SuperType;
  UpdateAutomatonVarsRequest_VarsEntry_DoNotUse();
  UpdateAutomatonVarsRequest_VarsEntry_DoNotUse(::google::protobuf::Arena* arena);
  void MergeFrom(const UpdateAutomatonVarsRequest_VarsEntry_DoNotUse& other);
  static const UpdateAutomatonVarsRequest_VarsEntry_DoNotUse* internal_default_instance() { return reinterpret_cast<const UpdateAutomatonVarsRequest_VarsEntry_DoNotUse*>(&_UpdateAutomatonVarsRequest_VarsEntry_DoNotUse_default_instance_); }
  void MergeFrom(const ::google::protobuf::Message& other) final;
  ::google::protobuf::Metadata GetMetadata() const;
};

// -------------------------------------------------------------------

class UpdateAutomatonVarsRequest final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:ric.logic.v3.UpdateAutomatonVarsRequest) */ {
 public:
  UpdateAutomatonVarsRequest();
  virtual ~UpdateAutomatonVarsRequest();

  UpdateAutomatonVarsRequest(const UpdateAutomatonVarsRequest& from);

  inline UpdateAutomatonVarsRequest& operator=(const UpdateAutomatonVarsRequest& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  UpdateAutomatonVarsRequest(UpdateAutomatonVarsRequest&& from) noexcept
    : UpdateAutomatonVarsRequest() {
    *this = ::std::move(from);
  }

  inline UpdateAutomatonVarsRequest& operator=(UpdateAutomatonVarsRequest&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const UpdateAutomatonVarsRequest& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const UpdateAutomatonVarsRequest* internal_default_instance() {
    return reinterpret_cast<const UpdateAutomatonVarsRequest*>(
               &_UpdateAutomatonVarsRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    28;

  void Swap(UpdateAutomatonVarsRequest* other);
  friend void swap(UpdateAutomatonVarsRequest& a, UpdateAutomatonVarsRequest& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline UpdateAutomatonVarsRequest* New() const final {
    return CreateMaybeMessage<UpdateAutomatonVarsRequest>(nullptr);
  }

  UpdateAutomatonVarsRequest* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<UpdateAutomatonVarsRequest>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const UpdateAutomatonVarsRequest& from);
  void MergeFrom(const UpdateAutomatonVarsRequest& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(UpdateAutomatonVarsRequest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------


  // accessors -------------------------------------------------------

  // map<string, .ric.logic.v3.AutomatonVarValue> vars = 4;
  int vars_size() const;
  void clear_vars();
  static const int kVarsFieldNumber = 4;
  const ::google::protobuf::Map< ::std::string, ::ric::logic::v3::AutomatonVarValue >&
      vars() const;
  ::google::protobuf::Map< ::std::string, ::ric::logic::v3::AutomatonVarValue >*
      mutable_vars();

  // string object_id = 2;
  void clear_object_id();
  static const int kObjectIdFieldNumber = 2;
  const ::std::string& object_id() const;
  void set_object_id(const ::std::string& value);
  #if LANG_CXX11
  void set_object_id(::std::string&& value);
  #endif
  void set_object_id(const char* value);
  void set_object_id(const char* value, size_t size);
  ::std::string* mutable_object_id();
  ::std::string* release_object_id();
  void set_allocated_object_id(::std::string* object_id);

  // string automaton_id = 3;
  void clear_automaton_id();
  static const int kAutomatonIdFieldNumber = 3;
  const ::std::string& automaton_id() const;
  void set_automaton_id(const ::std::string& value);
  #if LANG_CXX11
  void set_automaton_id(::std::string&& value);
  #endif
  void set_automaton_id(const char* value);
  void set_automaton_id(const char* value, size_t size);
  ::std::string* mutable_automaton_id();
  ::std::string* release_automaton_id();
  void set_allocated_automaton_id(::std::string* automaton_id);

  // .ric.logic.v3.UserContext ctx = 1;
  bool has_ctx() const;
  void clear_ctx();
  static const int kCtxFieldNumber = 1;
  const ::ric::logic::v3::UserContext& ctx() const;
  ::ric::logic::v3::UserContext* release_ctx();
  ::ric::logic::v3::UserContext* mutable_ctx();
  void set_allocated_ctx(::ric::logic::v3::UserContext* ctx);

  // @@protoc_insertion_point(class_scope:ric.logic.v3.UpdateAutomatonVarsRequest)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::MapField<
      UpdateAutomatonVarsRequest_VarsEntry_DoNotUse,
      ::std::string, ::ric::logic::v3::AutomatonVarValue,
      ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
      ::google::protobuf::internal::WireFormatLite::TYPE_MESSAGE,
      0 > vars_;
  ::google::protobuf::internal::ArenaStringPtr object_id_;
  ::google::protobuf::internal::ArenaStringPtr automaton_id_;
  ::ric::logic::v3::UserContext* ctx_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_ric_2dlogic_2dv3_2friclogicv3_2eproto;
};
// -------------------------------------------------------------------

class UpdateAutomatonVarsResponse_VarsEntry_DoNotUse : public ::google::protobuf::internal::MapEntry<UpdateAutomatonVarsResponse_VarsEntry_DoNotUse, 
    ::std::string, ::ric::logic::v3::AutomatonVarValue,
    ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
    ::google::protobuf::internal::WireFormatLite::TYPE_MESSAGE,
    0 > {
public:
#if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
static bool _ParseMap(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
#endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  typedef ::google::protobuf::internal::MapEntry<UpdateAutomatonVarsResponse_VarsEntry_DoNotUse, 
    ::std::string, ::ric::logic::v3::AutomatonVarValue,
    ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
    ::google::protobuf::internal::WireFormatLite::TYPE_MESSAGE,
    0 > SuperType;
  UpdateAutomatonVarsResponse_VarsEntry_DoNotUse();
  UpdateAutomatonVarsResponse_VarsEntry_DoNotUse(::google::protobuf::Arena* arena);
  void MergeFrom(const UpdateAutomatonVarsResponse_VarsEntry_DoNotUse& other);
  static const UpdateAutomatonVarsResponse_VarsEntry_DoNotUse* internal_default_instance() { return reinterpret_cast<const UpdateAutomatonVarsResponse_VarsEntry_DoNotUse*>(&_UpdateAutomatonVarsResponse_VarsEntry_DoNotUse_default_instance_); }
  void MergeFrom(const ::google::protobuf::Message& other) final;
  ::google::protobuf::Metadata GetMetadata() const;
};

// -------------------------------------------------------------------

class UpdateAutomatonVarsResponse final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:ric.logic.v3.UpdateAutomatonVarsResponse) */ {
 public:
  UpdateAutomatonVarsResponse();
  virtual ~UpdateAutomatonVarsResponse();

  UpdateAutomatonVarsResponse(const UpdateAutomatonVarsResponse& from);

  inline UpdateAutomatonVarsResponse& operator=(const UpdateAutomatonVarsResponse& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  UpdateAutomatonVarsResponse(UpdateAutomatonVarsResponse&& from) noexcept
    : UpdateAutomatonVarsResponse() {
    *this = ::std::move(from);
  }

  inline UpdateAutomatonVarsResponse& operator=(UpdateAutomatonVarsResponse&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const UpdateAutomatonVarsResponse& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const UpdateAutomatonVarsResponse* internal_default_instance() {
    return reinterpret_cast<const UpdateAutomatonVarsResponse*>(
               &_UpdateAutomatonVarsResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    30;

  void Swap(UpdateAutomatonVarsResponse* other);
  friend void swap(UpdateAutomatonVarsResponse& a, UpdateAutomatonVarsResponse& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline UpdateAutomatonVarsResponse* New() const final {
    return CreateMaybeMessage<UpdateAutomatonVarsResponse>(nullptr);
  }

  UpdateAutomatonVarsResponse* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<UpdateAutomatonVarsResponse>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const UpdateAutomatonVarsResponse& from);
  void MergeFrom(const UpdateAutomatonVarsResponse& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(UpdateAutomatonVarsResponse* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------


  // accessors -------------------------------------------------------

  // map<string, .ric.logic.v3.AutomatonVarValue> vars = 1;
  int vars_size() const;
  void clear_vars();
  static const int kVarsFieldNumber = 1;
  const ::google::protobuf::Map< ::std::string, ::ric::logic::v3::AutomatonVarValue >&
      vars() const;
  ::google::protobuf::Map< ::std::string, ::ric::logic::v3::AutomatonVarValue >*
      mutable_vars();

  // @@protoc_insertion_point(class_scope:ric.logic.v3.UpdateAutomatonVarsResponse)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::MapField<
      UpdateAutomatonVarsResponse_VarsEntry_DoNotUse,
      ::std::string, ::ric::logic::v3::AutomatonVarValue,
      ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
      ::google::protobuf::internal::WireFormatLite::TYPE_MESSAGE,
      0 > vars_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_ric_2dlogic_2dv3_2friclogicv3_2eproto;
};
// -------------------------------------------------------------------

class TouchEventSubscriptionRequest final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:ric.logic.v3.TouchEventSubscriptionRequest) */ {
 public:
  TouchEventSubscriptionRequest();
  virtual ~TouchEventSubscriptionRequest();

  TouchEventSubscriptionRequest(const TouchEventSubscriptionRequest& from);

  inline TouchEventSubscriptionRequest& operator=(const TouchEventSubscriptionRequest& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  TouchEventSubscriptionRequest(TouchEventSubscriptionRequest&& from) noexcept
    : TouchEventSubscriptionRequest() {
    *this = ::std::move(from);
  }

  inline TouchEventSubscriptionRequest& operator=(TouchEventSubscriptionRequest&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const TouchEventSubscriptionRequest& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const TouchEventSubscriptionRequest* internal_default_instance() {
    return reinterpret_cast<const TouchEventSubscriptionRequest*>(
               &_TouchEventSubscriptionRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    31;

  void Swap(TouchEventSubscriptionRequest* other);
  friend void swap(TouchEventSubscriptionRequest& a, TouchEventSubscriptionRequest& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline TouchEventSubscriptionRequest* New() const final {
    return CreateMaybeMessage<TouchEventSubscriptionRequest>(nullptr);
  }

  TouchEventSubscriptionRequest* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<TouchEventSubscriptionRequest>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const TouchEventSubscriptionRequest& from);
  void MergeFrom(const TouchEventSubscriptionRequest& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TouchEventSubscriptionRequest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string object_id = 2;
  void clear_object_id();
  static const int kObjectIdFieldNumber = 2;
  const ::std::string& object_id() const;
  void set_object_id(const ::std::string& value);
  #if LANG_CXX11
  void set_object_id(::std::string&& value);
  #endif
  void set_object_id(const char* value);
  void set_object_id(const char* value, size_t size);
  ::std::string* mutable_object_id();
  ::std::string* release_object_id();
  void set_allocated_object_id(::std::string* object_id);

  // string automaton_id = 3;
  void clear_automaton_id();
  static const int kAutomatonIdFieldNumber = 3;
  const ::std::string& automaton_id() const;
  void set_automaton_id(const ::std::string& value);
  #if LANG_CXX11
  void set_automaton_id(::std::string&& value);
  #endif
  void set_automaton_id(const char* value);
  void set_automaton_id(const char* value, size_t size);
  ::std::string* mutable_automaton_id();
  ::std::string* release_automaton_id();
  void set_allocated_automaton_id(::std::string* automaton_id);

  // .ric.logic.v3.UserContext ctx = 1;
  bool has_ctx() const;
  void clear_ctx();
  static const int kCtxFieldNumber = 1;
  const ::ric::logic::v3::UserContext& ctx() const;
  ::ric::logic::v3::UserContext* release_ctx();
  ::ric::logic::v3::UserContext* mutable_ctx();
  void set_allocated_ctx(::ric::logic::v3::UserContext* ctx);

  // int32 ttl = 4;
  void clear_ttl();
  static const int kTtlFieldNumber = 4;
  ::google::protobuf::int32 ttl() const;
  void set_ttl(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:ric.logic.v3.TouchEventSubscriptionRequest)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr object_id_;
  ::google::protobuf::internal::ArenaStringPtr automaton_id_;
  ::ric::logic::v3::UserContext* ctx_;
  ::google::protobuf::int32 ttl_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_ric_2dlogic_2dv3_2friclogicv3_2eproto;
};
// -------------------------------------------------------------------

class TouchEventSubscriptionResponse final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:ric.logic.v3.TouchEventSubscriptionResponse) */ {
 public:
  TouchEventSubscriptionResponse();
  virtual ~TouchEventSubscriptionResponse();

  TouchEventSubscriptionResponse(const TouchEventSubscriptionResponse& from);

  inline TouchEventSubscriptionResponse& operator=(const TouchEventSubscriptionResponse& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  TouchEventSubscriptionResponse(TouchEventSubscriptionResponse&& from) noexcept
    : TouchEventSubscriptionResponse() {
    *this = ::std::move(from);
  }

  inline TouchEventSubscriptionResponse& operator=(TouchEventSubscriptionResponse&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const TouchEventSubscriptionResponse& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const TouchEventSubscriptionResponse* internal_default_instance() {
    return reinterpret_cast<const TouchEventSubscriptionResponse*>(
               &_TouchEventSubscriptionResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    32;

  void Swap(TouchEventSubscriptionResponse* other);
  friend void swap(TouchEventSubscriptionResponse& a, TouchEventSubscriptionResponse& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline TouchEventSubscriptionResponse* New() const final {
    return CreateMaybeMessage<TouchEventSubscriptionResponse>(nullptr);
  }

  TouchEventSubscriptionResponse* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<TouchEventSubscriptionResponse>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const TouchEventSubscriptionResponse& from);
  void MergeFrom(const TouchEventSubscriptionResponse& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TouchEventSubscriptionResponse* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:ric.logic.v3.TouchEventSubscriptionResponse)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_ric_2dlogic_2dv3_2friclogicv3_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// UserContext

// string group_id = 1;
inline void UserContext::clear_group_id() {
  group_id_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& UserContext::group_id() const {
  // @@protoc_insertion_point(field_get:ric.logic.v3.UserContext.group_id)
  return group_id_.GetNoArena();
}
inline void UserContext::set_group_id(const ::std::string& value) {
  
  group_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:ric.logic.v3.UserContext.group_id)
}
#if LANG_CXX11
inline void UserContext::set_group_id(::std::string&& value) {
  
  group_id_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:ric.logic.v3.UserContext.group_id)
}
#endif
inline void UserContext::set_group_id(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  group_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:ric.logic.v3.UserContext.group_id)
}
inline void UserContext::set_group_id(const char* value, size_t size) {
  
  group_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:ric.logic.v3.UserContext.group_id)
}
inline ::std::string* UserContext::mutable_group_id() {
  
  // @@protoc_insertion_point(field_mutable:ric.logic.v3.UserContext.group_id)
  return group_id_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* UserContext::release_group_id() {
  // @@protoc_insertion_point(field_release:ric.logic.v3.UserContext.group_id)
  
  return group_id_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void UserContext::set_allocated_group_id(::std::string* group_id) {
  if (group_id != nullptr) {
    
  } else {
    
  }
  group_id_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), group_id);
  // @@protoc_insertion_point(field_set_allocated:ric.logic.v3.UserContext.group_id)
}

// string user_id = 2;
inline void UserContext::clear_user_id() {
  user_id_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& UserContext::user_id() const {
  // @@protoc_insertion_point(field_get:ric.logic.v3.UserContext.user_id)
  return user_id_.GetNoArena();
}
inline void UserContext::set_user_id(const ::std::string& value) {
  
  user_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:ric.logic.v3.UserContext.user_id)
}
#if LANG_CXX11
inline void UserContext::set_user_id(::std::string&& value) {
  
  user_id_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:ric.logic.v3.UserContext.user_id)
}
#endif
inline void UserContext::set_user_id(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  user_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:ric.logic.v3.UserContext.user_id)
}
inline void UserContext::set_user_id(const char* value, size_t size) {
  
  user_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:ric.logic.v3.UserContext.user_id)
}
inline ::std::string* UserContext::mutable_user_id() {
  
  // @@protoc_insertion_point(field_mutable:ric.logic.v3.UserContext.user_id)
  return user_id_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* UserContext::release_user_id() {
  // @@protoc_insertion_point(field_release:ric.logic.v3.UserContext.user_id)
  
  return user_id_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void UserContext::set_allocated_user_id(::std::string* user_id) {
  if (user_id != nullptr) {
    
  } else {
    
  }
  user_id_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), user_id);
  // @@protoc_insertion_point(field_set_allocated:ric.logic.v3.UserContext.user_id)
}

// string span_id = 3;
inline void UserContext::clear_span_id() {
  span_id_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& UserContext::span_id() const {
  // @@protoc_insertion_point(field_get:ric.logic.v3.UserContext.span_id)
  return span_id_.GetNoArena();
}
inline void UserContext::set_span_id(const ::std::string& value) {
  
  span_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:ric.logic.v3.UserContext.span_id)
}
#if LANG_CXX11
inline void UserContext::set_span_id(::std::string&& value) {
  
  span_id_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:ric.logic.v3.UserContext.span_id)
}
#endif
inline void UserContext::set_span_id(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  span_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:ric.logic.v3.UserContext.span_id)
}
inline void UserContext::set_span_id(const char* value, size_t size) {
  
  span_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:ric.logic.v3.UserContext.span_id)
}
inline ::std::string* UserContext::mutable_span_id() {
  
  // @@protoc_insertion_point(field_mutable:ric.logic.v3.UserContext.span_id)
  return span_id_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* UserContext::release_span_id() {
  // @@protoc_insertion_point(field_release:ric.logic.v3.UserContext.span_id)
  
  return span_id_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void UserContext::set_allocated_span_id(::std::string* span_id) {
  if (span_id != nullptr) {
    
  } else {
    
  }
  span_id_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), span_id);
  // @@protoc_insertion_point(field_set_allocated:ric.logic.v3.UserContext.span_id)
}

// -------------------------------------------------------------------

// StatsCounter

// int64 count = 1;
inline void StatsCounter::clear_count() {
  count_ = PROTOBUF_LONGLONG(0);
}
inline ::google::protobuf::int64 StatsCounter::count() const {
  // @@protoc_insertion_point(field_get:ric.logic.v3.StatsCounter.count)
  return count_;
}
inline void StatsCounter::set_count(::google::protobuf::int64 value) {
  
  count_ = value;
  // @@protoc_insertion_point(field_set:ric.logic.v3.StatsCounter.count)
}

// float mean = 2;
inline void StatsCounter::clear_mean() {
  mean_ = 0;
}
inline float StatsCounter::mean() const {
  // @@protoc_insertion_point(field_get:ric.logic.v3.StatsCounter.mean)
  return mean_;
}
inline void StatsCounter::set_mean(float value) {
  
  mean_ = value;
  // @@protoc_insertion_point(field_set:ric.logic.v3.StatsCounter.mean)
}

// -------------------------------------------------------------------

// AutomatonStats

// int64 started_at = 1;
inline void AutomatonStats::clear_started_at() {
  started_at_ = PROTOBUF_LONGLONG(0);
}
inline ::google::protobuf::int64 AutomatonStats::started_at() const {
  // @@protoc_insertion_point(field_get:ric.logic.v3.AutomatonStats.started_at)
  return started_at_;
}
inline void AutomatonStats::set_started_at(::google::protobuf::int64 value) {
  
  started_at_ = value;
  // @@protoc_insertion_point(field_set:ric.logic.v3.AutomatonStats.started_at)
}

// int64 stopped_at = 2;
inline void AutomatonStats::clear_stopped_at() {
  stopped_at_ = PROTOBUF_LONGLONG(0);
}
inline ::google::protobuf::int64 AutomatonStats::stopped_at() const {
  // @@protoc_insertion_point(field_get:ric.logic.v3.AutomatonStats.stopped_at)
  return stopped_at_;
}
inline void AutomatonStats::set_stopped_at(::google::protobuf::int64 value) {
  
  stopped_at_ = value;
  // @@protoc_insertion_point(field_set:ric.logic.v3.AutomatonStats.stopped_at)
}

// int64 transitioned_at = 3;
inline void AutomatonStats::clear_transitioned_at() {
  transitioned_at_ = PROTOBUF_LONGLONG(0);
}
inline ::google::protobuf::int64 AutomatonStats::transitioned_at() const {
  // @@protoc_insertion_point(field_get:ric.logic.v3.AutomatonStats.transitioned_at)
  return transitioned_at_;
}
inline void AutomatonStats::set_transitioned_at(::google::protobuf::int64 value) {
  
  transitioned_at_ = value;
  // @@protoc_insertion_point(field_set:ric.logic.v3.AutomatonStats.transitioned_at)
}

// .ric.logic.v3.StatsCounter transitions = 4;
inline bool AutomatonStats::has_transitions() const {
  return this != internal_default_instance() && transitions_ != nullptr;
}
inline void AutomatonStats::clear_transitions() {
  if (GetArenaNoVirtual() == nullptr && transitions_ != nullptr) {
    delete transitions_;
  }
  transitions_ = nullptr;
}
inline const ::ric::logic::v3::StatsCounter& AutomatonStats::transitions() const {
  const ::ric::logic::v3::StatsCounter* p = transitions_;
  // @@protoc_insertion_point(field_get:ric.logic.v3.AutomatonStats.transitions)
  return p != nullptr ? *p : *reinterpret_cast<const ::ric::logic::v3::StatsCounter*>(
      &::ric::logic::v3::_StatsCounter_default_instance_);
}
inline ::ric::logic::v3::StatsCounter* AutomatonStats::release_transitions() {
  // @@protoc_insertion_point(field_release:ric.logic.v3.AutomatonStats.transitions)
  
  ::ric::logic::v3::StatsCounter* temp = transitions_;
  transitions_ = nullptr;
  return temp;
}
inline ::ric::logic::v3::StatsCounter* AutomatonStats::mutable_transitions() {
  
  if (transitions_ == nullptr) {
    auto* p = CreateMaybeMessage<::ric::logic::v3::StatsCounter>(GetArenaNoVirtual());
    transitions_ = p;
  }
  // @@protoc_insertion_point(field_mutable:ric.logic.v3.AutomatonStats.transitions)
  return transitions_;
}
inline void AutomatonStats::set_allocated_transitions(::ric::logic::v3::StatsCounter* transitions) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete transitions_;
  }
  if (transitions) {
    ::google::protobuf::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      transitions = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, transitions, submessage_arena);
    }
    
  } else {
    
  }
  transitions_ = transitions;
  // @@protoc_insertion_point(field_set_allocated:ric.logic.v3.AutomatonStats.transitions)
}

// .ric.logic.v3.StatsCounter actions = 5;
inline bool AutomatonStats::has_actions() const {
  return this != internal_default_instance() && actions_ != nullptr;
}
inline void AutomatonStats::clear_actions() {
  if (GetArenaNoVirtual() == nullptr && actions_ != nullptr) {
    delete actions_;
  }
  actions_ = nullptr;
}
inline const ::ric::logic::v3::StatsCounter& AutomatonStats::actions() const {
  const ::ric::logic::v3::StatsCounter* p = actions_;
  // @@protoc_insertion_point(field_get:ric.logic.v3.AutomatonStats.actions)
  return p != nullptr ? *p : *reinterpret_cast<const ::ric::logic::v3::StatsCounter*>(
      &::ric::logic::v3::_StatsCounter_default_instance_);
}
inline ::ric::logic::v3::StatsCounter* AutomatonStats::release_actions() {
  // @@protoc_insertion_point(field_release:ric.logic.v3.AutomatonStats.actions)
  
  ::ric::logic::v3::StatsCounter* temp = actions_;
  actions_ = nullptr;
  return temp;
}
inline ::ric::logic::v3::StatsCounter* AutomatonStats::mutable_actions() {
  
  if (actions_ == nullptr) {
    auto* p = CreateMaybeMessage<::ric::logic::v3::StatsCounter>(GetArenaNoVirtual());
    actions_ = p;
  }
  // @@protoc_insertion_point(field_mutable:ric.logic.v3.AutomatonStats.actions)
  return actions_;
}
inline void AutomatonStats::set_allocated_actions(::ric::logic::v3::StatsCounter* actions) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete actions_;
  }
  if (actions) {
    ::google::protobuf::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      actions = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, actions, submessage_arena);
    }
    
  } else {
    
  }
  actions_ = actions;
  // @@protoc_insertion_point(field_set_allocated:ric.logic.v3.AutomatonStats.actions)
}

// .ric.logic.v3.StatsCounter packets = 6;
inline bool AutomatonStats::has_packets() const {
  return this != internal_default_instance() && packets_ != nullptr;
}
inline void AutomatonStats::clear_packets() {
  if (GetArenaNoVirtual() == nullptr && packets_ != nullptr) {
    delete packets_;
  }
  packets_ = nullptr;
}
inline const ::ric::logic::v3::StatsCounter& AutomatonStats::packets() const {
  const ::ric::logic::v3::StatsCounter* p = packets_;
  // @@protoc_insertion_point(field_get:ric.logic.v3.AutomatonStats.packets)
  return p != nullptr ? *p : *reinterpret_cast<const ::ric::logic::v3::StatsCounter*>(
      &::ric::logic::v3::_StatsCounter_default_instance_);
}
inline ::ric::logic::v3::StatsCounter* AutomatonStats::release_packets() {
  // @@protoc_insertion_point(field_release:ric.logic.v3.AutomatonStats.packets)
  
  ::ric::logic::v3::StatsCounter* temp = packets_;
  packets_ = nullptr;
  return temp;
}
inline ::ric::logic::v3::StatsCounter* AutomatonStats::mutable_packets() {
  
  if (packets_ == nullptr) {
    auto* p = CreateMaybeMessage<::ric::logic::v3::StatsCounter>(GetArenaNoVirtual());
    packets_ = p;
  }
  // @@protoc_insertion_point(field_mutable:ric.logic.v3.AutomatonStats.packets)
  return packets_;
}
inline void AutomatonStats::set_allocated_packets(::ric::logic::v3::StatsCounter* packets) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete packets_;
  }
  if (packets) {
    ::google::protobuf::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      packets = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, packets, submessage_arena);
    }
    
  } else {
    
  }
  packets_ = packets;
  // @@protoc_insertion_point(field_set_allocated:ric.logic.v3.AutomatonStats.packets)
}

// .ric.logic.v3.StatsCounter events = 7;
inline bool AutomatonStats::has_events() const {
  return this != internal_default_instance() && events_ != nullptr;
}
inline void AutomatonStats::clear_events() {
  if (GetArenaNoVirtual() == nullptr && events_ != nullptr) {
    delete events_;
  }
  events_ = nullptr;
}
inline const ::ric::logic::v3::StatsCounter& AutomatonStats::events() const {
  const ::ric::logic::v3::StatsCounter* p = events_;
  // @@protoc_insertion_point(field_get:ric.logic.v3.AutomatonStats.events)
  return p != nullptr ? *p : *reinterpret_cast<const ::ric::logic::v3::StatsCounter*>(
      &::ric::logic::v3::_StatsCounter_default_instance_);
}
inline ::ric::logic::v3::StatsCounter* AutomatonStats::release_events() {
  // @@protoc_insertion_point(field_release:ric.logic.v3.AutomatonStats.events)
  
  ::ric::logic::v3::StatsCounter* temp = events_;
  events_ = nullptr;
  return temp;
}
inline ::ric::logic::v3::StatsCounter* AutomatonStats::mutable_events() {
  
  if (events_ == nullptr) {
    auto* p = CreateMaybeMessage<::ric::logic::v3::StatsCounter>(GetArenaNoVirtual());
    events_ = p;
  }
  // @@protoc_insertion_point(field_mutable:ric.logic.v3.AutomatonStats.events)
  return events_;
}
inline void AutomatonStats::set_allocated_events(::ric::logic::v3::StatsCounter* events) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete events_;
  }
  if (events) {
    ::google::protobuf::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      events = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, events, submessage_arena);
    }
    
  } else {
    
  }
  events_ = events;
  // @@protoc_insertion_point(field_set_allocated:ric.logic.v3.AutomatonStats.events)
}

// string halted = 8;
inline void AutomatonStats::clear_halted() {
  halted_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& AutomatonStats::halted() const {
  // @@protoc_insertion_point(field_get:ric.logic.v3.AutomatonStats.halted)
  return halted_.GetNoArena();
}
inline void AutomatonStats::set_halted(const ::std::string& value) {
  
  halted_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:ric.logic.v3.AutomatonStats.halted)
}
#if LANG_CXX11
inline void AutomatonStats::set_halted(::std::string&& value) {
  
  halted_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:ric.logic.v3.AutomatonStats.halted)
}
#endif
inline void AutomatonStats::set_halted(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  halted_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:ric.logic.v3.AutomatonStats.halted)
}
inline void AutomatonStats::set_halted(const char* value, size_t size) {
  
  halted_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:ric.logic.v3.AutomatonStats.halted)
}
inline ::std::string* AutomatonStats::mutable_halted() {
  
  // @@protoc_insertion_point(field_mutable:ric.logic.v3.AutomatonStats.halted)
  return halted_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* AutomatonStats::release_halted() {
  // @@protoc_insertion_point(field_release:ric.logic.v3.AutomatonStats.halted)
  
  return halted_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void AutomatonStats::set_allocated_halted(::std::string* halted) {
  if (halted != nullptr) {
    
  } else {
    
  }
  halted_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), halted);
  // @@protoc_insertion_point(field_set_allocated:ric.logic.v3.AutomatonStats.halted)
}

// -------------------------------------------------------------------

// AutomatonVarValue

// string string_val = 1;
inline bool AutomatonVarValue::has_string_val() const {
  return type_case() == kStringVal;
}
inline void AutomatonVarValue::set_has_string_val() {
  _oneof_case_[0] = kStringVal;
}
inline void AutomatonVarValue::clear_string_val() {
  if (has_string_val()) {
    type_.string_val_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    clear_has_type();
  }
}
inline const ::std::string& AutomatonVarValue::string_val() const {
  // @@protoc_insertion_point(field_get:ric.logic.v3.AutomatonVarValue.string_val)
  if (has_string_val()) {
    return type_.string_val_.GetNoArena();
  }
  return *&::google::protobuf::internal::GetEmptyStringAlreadyInited();
}
inline void AutomatonVarValue::set_string_val(const ::std::string& value) {
  // @@protoc_insertion_point(field_set:ric.logic.v3.AutomatonVarValue.string_val)
  if (!has_string_val()) {
    clear_type();
    set_has_string_val();
    type_.string_val_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  type_.string_val_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:ric.logic.v3.AutomatonVarValue.string_val)
}
#if LANG_CXX11
inline void AutomatonVarValue::set_string_val(::std::string&& value) {
  // @@protoc_insertion_point(field_set:ric.logic.v3.AutomatonVarValue.string_val)
  if (!has_string_val()) {
    clear_type();
    set_has_string_val();
    type_.string_val_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  type_.string_val_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:ric.logic.v3.AutomatonVarValue.string_val)
}
#endif
inline void AutomatonVarValue::set_string_val(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  if (!has_string_val()) {
    clear_type();
    set_has_string_val();
    type_.string_val_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  type_.string_val_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(value));
  // @@protoc_insertion_point(field_set_char:ric.logic.v3.AutomatonVarValue.string_val)
}
inline void AutomatonVarValue::set_string_val(const char* value, size_t size) {
  if (!has_string_val()) {
    clear_type();
    set_has_string_val();
    type_.string_val_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  type_.string_val_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:ric.logic.v3.AutomatonVarValue.string_val)
}
inline ::std::string* AutomatonVarValue::mutable_string_val() {
  if (!has_string_val()) {
    clear_type();
    set_has_string_val();
    type_.string_val_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_mutable:ric.logic.v3.AutomatonVarValue.string_val)
  return type_.string_val_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* AutomatonVarValue::release_string_val() {
  // @@protoc_insertion_point(field_release:ric.logic.v3.AutomatonVarValue.string_val)
  if (has_string_val()) {
    clear_has_type();
    return type_.string_val_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  } else {
    return nullptr;
  }
}
inline void AutomatonVarValue::set_allocated_string_val(::std::string* string_val) {
  if (has_type()) {
    clear_type();
  }
  if (string_val != nullptr) {
    set_has_string_val();
    type_.string_val_.UnsafeSetDefault(string_val);
  }
  // @@protoc_insertion_point(field_set_allocated:ric.logic.v3.AutomatonVarValue.string_val)
}

// double double_val = 2;
inline bool AutomatonVarValue::has_double_val() const {
  return type_case() == kDoubleVal;
}
inline void AutomatonVarValue::set_has_double_val() {
  _oneof_case_[0] = kDoubleVal;
}
inline void AutomatonVarValue::clear_double_val() {
  if (has_double_val()) {
    type_.double_val_ = 0;
    clear_has_type();
  }
}
inline double AutomatonVarValue::double_val() const {
  // @@protoc_insertion_point(field_get:ric.logic.v3.AutomatonVarValue.double_val)
  if (has_double_val()) {
    return type_.double_val_;
  }
  return 0;
}
inline void AutomatonVarValue::set_double_val(double value) {
  if (!has_double_val()) {
    clear_type();
    set_has_double_val();
  }
  type_.double_val_ = value;
  // @@protoc_insertion_point(field_set:ric.logic.v3.AutomatonVarValue.double_val)
}

// bool bool_val = 3;
inline bool AutomatonVarValue::has_bool_val() const {
  return type_case() == kBoolVal;
}
inline void AutomatonVarValue::set_has_bool_val() {
  _oneof_case_[0] = kBoolVal;
}
inline void AutomatonVarValue::clear_bool_val() {
  if (has_bool_val()) {
    type_.bool_val_ = false;
    clear_has_type();
  }
}
inline bool AutomatonVarValue::bool_val() const {
  // @@protoc_insertion_point(field_get:ric.logic.v3.AutomatonVarValue.bool_val)
  if (has_bool_val()) {
    return type_.bool_val_;
  }
  return false;
}
inline void AutomatonVarValue::set_bool_val(bool value) {
  if (!has_bool_val()) {
    clear_type();
    set_has_bool_val();
  }
  type_.bool_val_ = value;
  // @@protoc_insertion_point(field_set:ric.logic.v3.AutomatonVarValue.bool_val)
}

inline bool AutomatonVarValue::has_type() const {
  return type_case() != TYPE_NOT_SET;
}
inline void AutomatonVarValue::clear_has_type() {
  _oneof_case_[0] = TYPE_NOT_SET;
}
inline AutomatonVarValue::TypeCase AutomatonVarValue::type_case() const {
  return AutomatonVarValue::TypeCase(_oneof_case_[0]);
}
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// AutomatonInfo

// string object_id = 1;
inline void AutomatonInfo::clear_object_id() {
  object_id_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& AutomatonInfo::object_id() const {
  // @@protoc_insertion_point(field_get:ric.logic.v3.AutomatonInfo.object_id)
  return object_id_.GetNoArena();
}
inline void AutomatonInfo::set_object_id(const ::std::string& value) {
  
  object_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:ric.logic.v3.AutomatonInfo.object_id)
}
#if LANG_CXX11
inline void AutomatonInfo::set_object_id(::std::string&& value) {
  
  object_id_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:ric.logic.v3.AutomatonInfo.object_id)
}
#endif
inline void AutomatonInfo::set_object_id(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  object_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:ric.logic.v3.AutomatonInfo.object_id)
}
inline void AutomatonInfo::set_object_id(const char* value, size_t size) {
  
  object_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:ric.logic.v3.AutomatonInfo.object_id)
}
inline ::std::string* AutomatonInfo::mutable_object_id() {
  
  // @@protoc_insertion_point(field_mutable:ric.logic.v3.AutomatonInfo.object_id)
  return object_id_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* AutomatonInfo::release_object_id() {
  // @@protoc_insertion_point(field_release:ric.logic.v3.AutomatonInfo.object_id)
  
  return object_id_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void AutomatonInfo::set_allocated_object_id(::std::string* object_id) {
  if (object_id != nullptr) {
    
  } else {
    
  }
  object_id_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), object_id);
  // @@protoc_insertion_point(field_set_allocated:ric.logic.v3.AutomatonInfo.object_id)
}

// string automaton_id = 2;
inline void AutomatonInfo::clear_automaton_id() {
  automaton_id_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& AutomatonInfo::automaton_id() const {
  // @@protoc_insertion_point(field_get:ric.logic.v3.AutomatonInfo.automaton_id)
  return automaton_id_.GetNoArena();
}
inline void AutomatonInfo::set_automaton_id(const ::std::string& value) {
  
  automaton_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:ric.logic.v3.AutomatonInfo.automaton_id)
}
#if LANG_CXX11
inline void AutomatonInfo::set_automaton_id(::std::string&& value) {
  
  automaton_id_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:ric.logic.v3.AutomatonInfo.automaton_id)
}
#endif
inline void AutomatonInfo::set_automaton_id(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  automaton_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:ric.logic.v3.AutomatonInfo.automaton_id)
}
inline void AutomatonInfo::set_automaton_id(const char* value, size_t size) {
  
  automaton_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:ric.logic.v3.AutomatonInfo.automaton_id)
}
inline ::std::string* AutomatonInfo::mutable_automaton_id() {
  
  // @@protoc_insertion_point(field_mutable:ric.logic.v3.AutomatonInfo.automaton_id)
  return automaton_id_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* AutomatonInfo::release_automaton_id() {
  // @@protoc_insertion_point(field_release:ric.logic.v3.AutomatonInfo.automaton_id)
  
  return automaton_id_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void AutomatonInfo::set_allocated_automaton_id(::std::string* automaton_id) {
  if (automaton_id != nullptr) {
    
  } else {
    
  }
  automaton_id_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), automaton_id);
  // @@protoc_insertion_point(field_set_allocated:ric.logic.v3.AutomatonInfo.automaton_id)
}

// string hash_id = 3;
inline void AutomatonInfo::clear_hash_id() {
  hash_id_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& AutomatonInfo::hash_id() const {
  // @@protoc_insertion_point(field_get:ric.logic.v3.AutomatonInfo.hash_id)
  return hash_id_.GetNoArena();
}
inline void AutomatonInfo::set_hash_id(const ::std::string& value) {
  
  hash_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:ric.logic.v3.AutomatonInfo.hash_id)
}
#if LANG_CXX11
inline void AutomatonInfo::set_hash_id(::std::string&& value) {
  
  hash_id_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:ric.logic.v3.AutomatonInfo.hash_id)
}
#endif
inline void AutomatonInfo::set_hash_id(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  hash_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:ric.logic.v3.AutomatonInfo.hash_id)
}
inline void AutomatonInfo::set_hash_id(const char* value, size_t size) {
  
  hash_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:ric.logic.v3.AutomatonInfo.hash_id)
}
inline ::std::string* AutomatonInfo::mutable_hash_id() {
  
  // @@protoc_insertion_point(field_mutable:ric.logic.v3.AutomatonInfo.hash_id)
  return hash_id_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* AutomatonInfo::release_hash_id() {
  // @@protoc_insertion_point(field_release:ric.logic.v3.AutomatonInfo.hash_id)
  
  return hash_id_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void AutomatonInfo::set_allocated_hash_id(::std::string* hash_id) {
  if (hash_id != nullptr) {
    
  } else {
    
  }
  hash_id_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), hash_id);
  // @@protoc_insertion_point(field_set_allocated:ric.logic.v3.AutomatonInfo.hash_id)
}

// string revision = 4;
inline void AutomatonInfo::clear_revision() {
  revision_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& AutomatonInfo::revision() const {
  // @@protoc_insertion_point(field_get:ric.logic.v3.AutomatonInfo.revision)
  return revision_.GetNoArena();
}
inline void AutomatonInfo::set_revision(const ::std::string& value) {
  
  revision_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:ric.logic.v3.AutomatonInfo.revision)
}
#if LANG_CXX11
inline void AutomatonInfo::set_revision(::std::string&& value) {
  
  revision_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:ric.logic.v3.AutomatonInfo.revision)
}
#endif
inline void AutomatonInfo::set_revision(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  revision_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:ric.logic.v3.AutomatonInfo.revision)
}
inline void AutomatonInfo::set_revision(const char* value, size_t size) {
  
  revision_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:ric.logic.v3.AutomatonInfo.revision)
}
inline ::std::string* AutomatonInfo::mutable_revision() {
  
  // @@protoc_insertion_point(field_mutable:ric.logic.v3.AutomatonInfo.revision)
  return revision_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* AutomatonInfo::release_revision() {
  // @@protoc_insertion_point(field_release:ric.logic.v3.AutomatonInfo.revision)
  
  return revision_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void AutomatonInfo::set_allocated_revision(::std::string* revision) {
  if (revision != nullptr) {
    
  } else {
    
  }
  revision_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), revision);
  // @@protoc_insertion_point(field_set_allocated:ric.logic.v3.AutomatonInfo.revision)
}

// string status = 5;
inline void AutomatonInfo::clear_status() {
  status_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& AutomatonInfo::status() const {
  // @@protoc_insertion_point(field_get:ric.logic.v3.AutomatonInfo.status)
  return status_.GetNoArena();
}
inline void AutomatonInfo::set_status(const ::std::string& value) {
  
  status_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:ric.logic.v3.AutomatonInfo.status)
}
#if LANG_CXX11
inline void AutomatonInfo::set_status(::std::string&& value) {
  
  status_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:ric.logic.v3.AutomatonInfo.status)
}
#endif
inline void AutomatonInfo::set_status(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  status_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:ric.logic.v3.AutomatonInfo.status)
}
inline void AutomatonInfo::set_status(const char* value, size_t size) {
  
  status_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:ric.logic.v3.AutomatonInfo.status)
}
inline ::std::string* AutomatonInfo::mutable_status() {
  
  // @@protoc_insertion_point(field_mutable:ric.logic.v3.AutomatonInfo.status)
  return status_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* AutomatonInfo::release_status() {
  // @@protoc_insertion_point(field_release:ric.logic.v3.AutomatonInfo.status)
  
  return status_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void AutomatonInfo::set_allocated_status(::std::string* status) {
  if (status != nullptr) {
    
  } else {
    
  }
  status_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), status);
  // @@protoc_insertion_point(field_set_allocated:ric.logic.v3.AutomatonInfo.status)
}

// string state = 6;
inline void AutomatonInfo::clear_state() {
  state_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& AutomatonInfo::state() const {
  // @@protoc_insertion_point(field_get:ric.logic.v3.AutomatonInfo.state)
  return state_.GetNoArena();
}
inline void AutomatonInfo::set_state(const ::std::string& value) {
  
  state_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:ric.logic.v3.AutomatonInfo.state)
}
#if LANG_CXX11
inline void AutomatonInfo::set_state(::std::string&& value) {
  
  state_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:ric.logic.v3.AutomatonInfo.state)
}
#endif
inline void AutomatonInfo::set_state(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  state_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:ric.logic.v3.AutomatonInfo.state)
}
inline void AutomatonInfo::set_state(const char* value, size_t size) {
  
  state_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:ric.logic.v3.AutomatonInfo.state)
}
inline ::std::string* AutomatonInfo::mutable_state() {
  
  // @@protoc_insertion_point(field_mutable:ric.logic.v3.AutomatonInfo.state)
  return state_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* AutomatonInfo::release_state() {
  // @@protoc_insertion_point(field_release:ric.logic.v3.AutomatonInfo.state)
  
  return state_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void AutomatonInfo::set_allocated_state(::std::string* state) {
  if (state != nullptr) {
    
  } else {
    
  }
  state_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), state);
  // @@protoc_insertion_point(field_set_allocated:ric.logic.v3.AutomatonInfo.state)
}

// string prev_state = 7;
inline void AutomatonInfo::clear_prev_state() {
  prev_state_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& AutomatonInfo::prev_state() const {
  // @@protoc_insertion_point(field_get:ric.logic.v3.AutomatonInfo.prev_state)
  return prev_state_.GetNoArena();
}
inline void AutomatonInfo::set_prev_state(const ::std::string& value) {
  
  prev_state_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:ric.logic.v3.AutomatonInfo.prev_state)
}
#if LANG_CXX11
inline void AutomatonInfo::set_prev_state(::std::string&& value) {
  
  prev_state_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:ric.logic.v3.AutomatonInfo.prev_state)
}
#endif
inline void AutomatonInfo::set_prev_state(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  prev_state_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:ric.logic.v3.AutomatonInfo.prev_state)
}
inline void AutomatonInfo::set_prev_state(const char* value, size_t size) {
  
  prev_state_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:ric.logic.v3.AutomatonInfo.prev_state)
}
inline ::std::string* AutomatonInfo::mutable_prev_state() {
  
  // @@protoc_insertion_point(field_mutable:ric.logic.v3.AutomatonInfo.prev_state)
  return prev_state_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* AutomatonInfo::release_prev_state() {
  // @@protoc_insertion_point(field_release:ric.logic.v3.AutomatonInfo.prev_state)
  
  return prev_state_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void AutomatonInfo::set_allocated_prev_state(::std::string* prev_state) {
  if (prev_state != nullptr) {
    
  } else {
    
  }
  prev_state_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), prev_state);
  // @@protoc_insertion_point(field_set_allocated:ric.logic.v3.AutomatonInfo.prev_state)
}

// string prev_event = 8;
inline void AutomatonInfo::clear_prev_event() {
  prev_event_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& AutomatonInfo::prev_event() const {
  // @@protoc_insertion_point(field_get:ric.logic.v3.AutomatonInfo.prev_event)
  return prev_event_.GetNoArena();
}
inline void AutomatonInfo::set_prev_event(const ::std::string& value) {
  
  prev_event_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:ric.logic.v3.AutomatonInfo.prev_event)
}
#if LANG_CXX11
inline void AutomatonInfo::set_prev_event(::std::string&& value) {
  
  prev_event_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:ric.logic.v3.AutomatonInfo.prev_event)
}
#endif
inline void AutomatonInfo::set_prev_event(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  prev_event_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:ric.logic.v3.AutomatonInfo.prev_event)
}
inline void AutomatonInfo::set_prev_event(const char* value, size_t size) {
  
  prev_event_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:ric.logic.v3.AutomatonInfo.prev_event)
}
inline ::std::string* AutomatonInfo::mutable_prev_event() {
  
  // @@protoc_insertion_point(field_mutable:ric.logic.v3.AutomatonInfo.prev_event)
  return prev_event_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* AutomatonInfo::release_prev_event() {
  // @@protoc_insertion_point(field_release:ric.logic.v3.AutomatonInfo.prev_event)
  
  return prev_event_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void AutomatonInfo::set_allocated_prev_event(::std::string* prev_event) {
  if (prev_event != nullptr) {
    
  } else {
    
  }
  prev_event_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), prev_event);
  // @@protoc_insertion_point(field_set_allocated:ric.logic.v3.AutomatonInfo.prev_event)
}

// .ric.logic.v3.AutomatonStats stats = 9;
inline bool AutomatonInfo::has_stats() const {
  return this != internal_default_instance() && stats_ != nullptr;
}
inline void AutomatonInfo::clear_stats() {
  if (GetArenaNoVirtual() == nullptr && stats_ != nullptr) {
    delete stats_;
  }
  stats_ = nullptr;
}
inline const ::ric::logic::v3::AutomatonStats& AutomatonInfo::stats() const {
  const ::ric::logic::v3::AutomatonStats* p = stats_;
  // @@protoc_insertion_point(field_get:ric.logic.v3.AutomatonInfo.stats)
  return p != nullptr ? *p : *reinterpret_cast<const ::ric::logic::v3::AutomatonStats*>(
      &::ric::logic::v3::_AutomatonStats_default_instance_);
}
inline ::ric::logic::v3::AutomatonStats* AutomatonInfo::release_stats() {
  // @@protoc_insertion_point(field_release:ric.logic.v3.AutomatonInfo.stats)
  
  ::ric::logic::v3::AutomatonStats* temp = stats_;
  stats_ = nullptr;
  return temp;
}
inline ::ric::logic::v3::AutomatonStats* AutomatonInfo::mutable_stats() {
  
  if (stats_ == nullptr) {
    auto* p = CreateMaybeMessage<::ric::logic::v3::AutomatonStats>(GetArenaNoVirtual());
    stats_ = p;
  }
  // @@protoc_insertion_point(field_mutable:ric.logic.v3.AutomatonInfo.stats)
  return stats_;
}
inline void AutomatonInfo::set_allocated_stats(::ric::logic::v3::AutomatonStats* stats) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete stats_;
  }
  if (stats) {
    ::google::protobuf::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      stats = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, stats, submessage_arena);
    }
    
  } else {
    
  }
  stats_ = stats;
  // @@protoc_insertion_point(field_set_allocated:ric.logic.v3.AutomatonInfo.stats)
}

// repeated .ric.logic.v3.LogEntry logs = 10;
inline int AutomatonInfo::logs_size() const {
  return logs_.size();
}
inline void AutomatonInfo::clear_logs() {
  logs_.Clear();
}
inline ::ric::logic::v3::LogEntry* AutomatonInfo::mutable_logs(int index) {
  // @@protoc_insertion_point(field_mutable:ric.logic.v3.AutomatonInfo.logs)
  return logs_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::ric::logic::v3::LogEntry >*
AutomatonInfo::mutable_logs() {
  // @@protoc_insertion_point(field_mutable_list:ric.logic.v3.AutomatonInfo.logs)
  return &logs_;
}
inline const ::ric::logic::v3::LogEntry& AutomatonInfo::logs(int index) const {
  // @@protoc_insertion_point(field_get:ric.logic.v3.AutomatonInfo.logs)
  return logs_.Get(index);
}
inline ::ric::logic::v3::LogEntry* AutomatonInfo::add_logs() {
  // @@protoc_insertion_point(field_add:ric.logic.v3.AutomatonInfo.logs)
  return logs_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::ric::logic::v3::LogEntry >&
AutomatonInfo::logs() const {
  // @@protoc_insertion_point(field_list:ric.logic.v3.AutomatonInfo.logs)
  return logs_;
}

// map<string, .ric.logic.v3.AutomatonVarValue> vars = 11;
inline int AutomatonInfo::vars_size() const {
  return vars_.size();
}
inline void AutomatonInfo::clear_vars() {
  vars_.Clear();
}
inline const ::google::protobuf::Map< ::std::string, ::ric::logic::v3::AutomatonVarValue >&
AutomatonInfo::vars() const {
  // @@protoc_insertion_point(field_map:ric.logic.v3.AutomatonInfo.vars)
  return vars_.GetMap();
}
inline ::google::protobuf::Map< ::std::string, ::ric::logic::v3::AutomatonVarValue >*
AutomatonInfo::mutable_vars() {
  // @@protoc_insertion_point(field_mutable_map:ric.logic.v3.AutomatonInfo.vars)
  return vars_.MutableMap();
}

// -------------------------------------------------------------------

// AutomatonEvent

// string type = 1;
inline void AutomatonEvent::clear_type() {
  type_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& AutomatonEvent::type() const {
  // @@protoc_insertion_point(field_get:ric.logic.v3.AutomatonEvent.type)
  return type_.GetNoArena();
}
inline void AutomatonEvent::set_type(const ::std::string& value) {
  
  type_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:ric.logic.v3.AutomatonEvent.type)
}
#if LANG_CXX11
inline void AutomatonEvent::set_type(::std::string&& value) {
  
  type_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:ric.logic.v3.AutomatonEvent.type)
}
#endif
inline void AutomatonEvent::set_type(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  type_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:ric.logic.v3.AutomatonEvent.type)
}
inline void AutomatonEvent::set_type(const char* value, size_t size) {
  
  type_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:ric.logic.v3.AutomatonEvent.type)
}
inline ::std::string* AutomatonEvent::mutable_type() {
  
  // @@protoc_insertion_point(field_mutable:ric.logic.v3.AutomatonEvent.type)
  return type_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* AutomatonEvent::release_type() {
  // @@protoc_insertion_point(field_release:ric.logic.v3.AutomatonEvent.type)
  
  return type_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void AutomatonEvent::set_allocated_type(::std::string* type) {
  if (type != nullptr) {
    
  } else {
    
  }
  type_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), type);
  // @@protoc_insertion_point(field_set_allocated:ric.logic.v3.AutomatonEvent.type)
}

// string payload = 2;
inline void AutomatonEvent::clear_payload() {
  payload_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& AutomatonEvent::payload() const {
  // @@protoc_insertion_point(field_get:ric.logic.v3.AutomatonEvent.payload)
  return payload_.GetNoArena();
}
inline void AutomatonEvent::set_payload(const ::std::string& value) {
  
  payload_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:ric.logic.v3.AutomatonEvent.payload)
}
#if LANG_CXX11
inline void AutomatonEvent::set_payload(::std::string&& value) {
  
  payload_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:ric.logic.v3.AutomatonEvent.payload)
}
#endif
inline void AutomatonEvent::set_payload(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  payload_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:ric.logic.v3.AutomatonEvent.payload)
}
inline void AutomatonEvent::set_payload(const char* value, size_t size) {
  
  payload_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:ric.logic.v3.AutomatonEvent.payload)
}
inline ::std::string* AutomatonEvent::mutable_payload() {
  
  // @@protoc_insertion_point(field_mutable:ric.logic.v3.AutomatonEvent.payload)
  return payload_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* AutomatonEvent::release_payload() {
  // @@protoc_insertion_point(field_release:ric.logic.v3.AutomatonEvent.payload)
  
  return payload_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void AutomatonEvent::set_allocated_payload(::std::string* payload) {
  if (payload != nullptr) {
    
  } else {
    
  }
  payload_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), payload);
  // @@protoc_insertion_point(field_set_allocated:ric.logic.v3.AutomatonEvent.payload)
}

// -------------------------------------------------------------------

// ActionResult

// string status = 1;
inline void ActionResult::clear_status() {
  status_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& ActionResult::status() const {
  // @@protoc_insertion_point(field_get:ric.logic.v3.ActionResult.status)
  return status_.GetNoArena();
}
inline void ActionResult::set_status(const ::std::string& value) {
  
  status_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:ric.logic.v3.ActionResult.status)
}
#if LANG_CXX11
inline void ActionResult::set_status(::std::string&& value) {
  
  status_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:ric.logic.v3.ActionResult.status)
}
#endif
inline void ActionResult::set_status(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  status_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:ric.logic.v3.ActionResult.status)
}
inline void ActionResult::set_status(const char* value, size_t size) {
  
  status_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:ric.logic.v3.ActionResult.status)
}
inline ::std::string* ActionResult::mutable_status() {
  
  // @@protoc_insertion_point(field_mutable:ric.logic.v3.ActionResult.status)
  return status_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* ActionResult::release_status() {
  // @@protoc_insertion_point(field_release:ric.logic.v3.ActionResult.status)
  
  return status_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ActionResult::set_allocated_status(::std::string* status) {
  if (status != nullptr) {
    
  } else {
    
  }
  status_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), status);
  // @@protoc_insertion_point(field_set_allocated:ric.logic.v3.ActionResult.status)
}

// string payload = 2;
inline void ActionResult::clear_payload() {
  payload_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& ActionResult::payload() const {
  // @@protoc_insertion_point(field_get:ric.logic.v3.ActionResult.payload)
  return payload_.GetNoArena();
}
inline void ActionResult::set_payload(const ::std::string& value) {
  
  payload_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:ric.logic.v3.ActionResult.payload)
}
#if LANG_CXX11
inline void ActionResult::set_payload(::std::string&& value) {
  
  payload_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:ric.logic.v3.ActionResult.payload)
}
#endif
inline void ActionResult::set_payload(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  payload_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:ric.logic.v3.ActionResult.payload)
}
inline void ActionResult::set_payload(const char* value, size_t size) {
  
  payload_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:ric.logic.v3.ActionResult.payload)
}
inline ::std::string* ActionResult::mutable_payload() {
  
  // @@protoc_insertion_point(field_mutable:ric.logic.v3.ActionResult.payload)
  return payload_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* ActionResult::release_payload() {
  // @@protoc_insertion_point(field_release:ric.logic.v3.ActionResult.payload)
  
  return payload_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ActionResult::set_allocated_payload(::std::string* payload) {
  if (payload != nullptr) {
    
  } else {
    
  }
  payload_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), payload);
  // @@protoc_insertion_point(field_set_allocated:ric.logic.v3.ActionResult.payload)
}

// int32 ms = 3;
inline void ActionResult::clear_ms() {
  ms_ = 0;
}
inline ::google::protobuf::int32 ActionResult::ms() const {
  // @@protoc_insertion_point(field_get:ric.logic.v3.ActionResult.ms)
  return ms_;
}
inline void ActionResult::set_ms(::google::protobuf::int32 value) {
  
  ms_ = value;
  // @@protoc_insertion_point(field_set:ric.logic.v3.ActionResult.ms)
}

// -------------------------------------------------------------------

// LogEntry

// string id = 1;
inline void LogEntry::clear_id() {
  id_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& LogEntry::id() const {
  // @@protoc_insertion_point(field_get:ric.logic.v3.LogEntry.id)
  return id_.GetNoArena();
}
inline void LogEntry::set_id(const ::std::string& value) {
  
  id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:ric.logic.v3.LogEntry.id)
}
#if LANG_CXX11
inline void LogEntry::set_id(::std::string&& value) {
  
  id_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:ric.logic.v3.LogEntry.id)
}
#endif
inline void LogEntry::set_id(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:ric.logic.v3.LogEntry.id)
}
inline void LogEntry::set_id(const char* value, size_t size) {
  
  id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:ric.logic.v3.LogEntry.id)
}
inline ::std::string* LogEntry::mutable_id() {
  
  // @@protoc_insertion_point(field_mutable:ric.logic.v3.LogEntry.id)
  return id_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* LogEntry::release_id() {
  // @@protoc_insertion_point(field_release:ric.logic.v3.LogEntry.id)
  
  return id_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void LogEntry::set_allocated_id(::std::string* id) {
  if (id != nullptr) {
    
  } else {
    
  }
  id_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), id);
  // @@protoc_insertion_point(field_set_allocated:ric.logic.v3.LogEntry.id)
}

// int64 ts = 2;
inline void LogEntry::clear_ts() {
  ts_ = PROTOBUF_LONGLONG(0);
}
inline ::google::protobuf::int64 LogEntry::ts() const {
  // @@protoc_insertion_point(field_get:ric.logic.v3.LogEntry.ts)
  return ts_;
}
inline void LogEntry::set_ts(::google::protobuf::int64 value) {
  
  ts_ = value;
  // @@protoc_insertion_point(field_set:ric.logic.v3.LogEntry.ts)
}

// string object_id = 3;
inline void LogEntry::clear_object_id() {
  object_id_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& LogEntry::object_id() const {
  // @@protoc_insertion_point(field_get:ric.logic.v3.LogEntry.object_id)
  return object_id_.GetNoArena();
}
inline void LogEntry::set_object_id(const ::std::string& value) {
  
  object_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:ric.logic.v3.LogEntry.object_id)
}
#if LANG_CXX11
inline void LogEntry::set_object_id(::std::string&& value) {
  
  object_id_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:ric.logic.v3.LogEntry.object_id)
}
#endif
inline void LogEntry::set_object_id(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  object_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:ric.logic.v3.LogEntry.object_id)
}
inline void LogEntry::set_object_id(const char* value, size_t size) {
  
  object_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:ric.logic.v3.LogEntry.object_id)
}
inline ::std::string* LogEntry::mutable_object_id() {
  
  // @@protoc_insertion_point(field_mutable:ric.logic.v3.LogEntry.object_id)
  return object_id_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* LogEntry::release_object_id() {
  // @@protoc_insertion_point(field_release:ric.logic.v3.LogEntry.object_id)
  
  return object_id_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void LogEntry::set_allocated_object_id(::std::string* object_id) {
  if (object_id != nullptr) {
    
  } else {
    
  }
  object_id_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), object_id);
  // @@protoc_insertion_point(field_set_allocated:ric.logic.v3.LogEntry.object_id)
}

// string automaton_id = 4;
inline void LogEntry::clear_automaton_id() {
  automaton_id_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& LogEntry::automaton_id() const {
  // @@protoc_insertion_point(field_get:ric.logic.v3.LogEntry.automaton_id)
  return automaton_id_.GetNoArena();
}
inline void LogEntry::set_automaton_id(const ::std::string& value) {
  
  automaton_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:ric.logic.v3.LogEntry.automaton_id)
}
#if LANG_CXX11
inline void LogEntry::set_automaton_id(::std::string&& value) {
  
  automaton_id_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:ric.logic.v3.LogEntry.automaton_id)
}
#endif
inline void LogEntry::set_automaton_id(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  automaton_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:ric.logic.v3.LogEntry.automaton_id)
}
inline void LogEntry::set_automaton_id(const char* value, size_t size) {
  
  automaton_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:ric.logic.v3.LogEntry.automaton_id)
}
inline ::std::string* LogEntry::mutable_automaton_id() {
  
  // @@protoc_insertion_point(field_mutable:ric.logic.v3.LogEntry.automaton_id)
  return automaton_id_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* LogEntry::release_automaton_id() {
  // @@protoc_insertion_point(field_release:ric.logic.v3.LogEntry.automaton_id)
  
  return automaton_id_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void LogEntry::set_allocated_automaton_id(::std::string* automaton_id) {
  if (automaton_id != nullptr) {
    
  } else {
    
  }
  automaton_id_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), automaton_id);
  // @@protoc_insertion_point(field_set_allocated:ric.logic.v3.LogEntry.automaton_id)
}

// string hash_id = 5;
inline void LogEntry::clear_hash_id() {
  hash_id_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& LogEntry::hash_id() const {
  // @@protoc_insertion_point(field_get:ric.logic.v3.LogEntry.hash_id)
  return hash_id_.GetNoArena();
}
inline void LogEntry::set_hash_id(const ::std::string& value) {
  
  hash_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:ric.logic.v3.LogEntry.hash_id)
}
#if LANG_CXX11
inline void LogEntry::set_hash_id(::std::string&& value) {
  
  hash_id_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:ric.logic.v3.LogEntry.hash_id)
}
#endif
inline void LogEntry::set_hash_id(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  hash_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:ric.logic.v3.LogEntry.hash_id)
}
inline void LogEntry::set_hash_id(const char* value, size_t size) {
  
  hash_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:ric.logic.v3.LogEntry.hash_id)
}
inline ::std::string* LogEntry::mutable_hash_id() {
  
  // @@protoc_insertion_point(field_mutable:ric.logic.v3.LogEntry.hash_id)
  return hash_id_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* LogEntry::release_hash_id() {
  // @@protoc_insertion_point(field_release:ric.logic.v3.LogEntry.hash_id)
  
  return hash_id_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void LogEntry::set_allocated_hash_id(::std::string* hash_id) {
  if (hash_id != nullptr) {
    
  } else {
    
  }
  hash_id_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), hash_id);
  // @@protoc_insertion_point(field_set_allocated:ric.logic.v3.LogEntry.hash_id)
}

// string revision = 6;
inline void LogEntry::clear_revision() {
  revision_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& LogEntry::revision() const {
  // @@protoc_insertion_point(field_get:ric.logic.v3.LogEntry.revision)
  return revision_.GetNoArena();
}
inline void LogEntry::set_revision(const ::std::string& value) {
  
  revision_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:ric.logic.v3.LogEntry.revision)
}
#if LANG_CXX11
inline void LogEntry::set_revision(::std::string&& value) {
  
  revision_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:ric.logic.v3.LogEntry.revision)
}
#endif
inline void LogEntry::set_revision(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  revision_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:ric.logic.v3.LogEntry.revision)
}
inline void LogEntry::set_revision(const char* value, size_t size) {
  
  revision_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:ric.logic.v3.LogEntry.revision)
}
inline ::std::string* LogEntry::mutable_revision() {
  
  // @@protoc_insertion_point(field_mutable:ric.logic.v3.LogEntry.revision)
  return revision_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* LogEntry::release_revision() {
  // @@protoc_insertion_point(field_release:ric.logic.v3.LogEntry.revision)
  
  return revision_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void LogEntry::set_allocated_revision(::std::string* revision) {
  if (revision != nullptr) {
    
  } else {
    
  }
  revision_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), revision);
  // @@protoc_insertion_point(field_set_allocated:ric.logic.v3.LogEntry.revision)
}

// string instance = 7;
inline void LogEntry::clear_instance() {
  instance_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& LogEntry::instance() const {
  // @@protoc_insertion_point(field_get:ric.logic.v3.LogEntry.instance)
  return instance_.GetNoArena();
}
inline void LogEntry::set_instance(const ::std::string& value) {
  
  instance_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:ric.logic.v3.LogEntry.instance)
}
#if LANG_CXX11
inline void LogEntry::set_instance(::std::string&& value) {
  
  instance_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:ric.logic.v3.LogEntry.instance)
}
#endif
inline void LogEntry::set_instance(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  instance_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:ric.logic.v3.LogEntry.instance)
}
inline void LogEntry::set_instance(const char* value, size_t size) {
  
  instance_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:ric.logic.v3.LogEntry.instance)
}
inline ::std::string* LogEntry::mutable_instance() {
  
  // @@protoc_insertion_point(field_mutable:ric.logic.v3.LogEntry.instance)
  return instance_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* LogEntry::release_instance() {
  // @@protoc_insertion_point(field_release:ric.logic.v3.LogEntry.instance)
  
  return instance_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void LogEntry::set_allocated_instance(::std::string* instance) {
  if (instance != nullptr) {
    
  } else {
    
  }
  instance_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), instance);
  // @@protoc_insertion_point(field_set_allocated:ric.logic.v3.LogEntry.instance)
}

// string category = 8;
inline void LogEntry::clear_category() {
  category_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& LogEntry::category() const {
  // @@protoc_insertion_point(field_get:ric.logic.v3.LogEntry.category)
  return category_.GetNoArena();
}
inline void LogEntry::set_category(const ::std::string& value) {
  
  category_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:ric.logic.v3.LogEntry.category)
}
#if LANG_CXX11
inline void LogEntry::set_category(::std::string&& value) {
  
  category_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:ric.logic.v3.LogEntry.category)
}
#endif
inline void LogEntry::set_category(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  category_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:ric.logic.v3.LogEntry.category)
}
inline void LogEntry::set_category(const char* value, size_t size) {
  
  category_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:ric.logic.v3.LogEntry.category)
}
inline ::std::string* LogEntry::mutable_category() {
  
  // @@protoc_insertion_point(field_mutable:ric.logic.v3.LogEntry.category)
  return category_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* LogEntry::release_category() {
  // @@protoc_insertion_point(field_release:ric.logic.v3.LogEntry.category)
  
  return category_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void LogEntry::set_allocated_category(::std::string* category) {
  if (category != nullptr) {
    
  } else {
    
  }
  category_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), category);
  // @@protoc_insertion_point(field_set_allocated:ric.logic.v3.LogEntry.category)
}

// string message = 9;
inline void LogEntry::clear_message() {
  message_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& LogEntry::message() const {
  // @@protoc_insertion_point(field_get:ric.logic.v3.LogEntry.message)
  return message_.GetNoArena();
}
inline void LogEntry::set_message(const ::std::string& value) {
  
  message_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:ric.logic.v3.LogEntry.message)
}
#if LANG_CXX11
inline void LogEntry::set_message(::std::string&& value) {
  
  message_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:ric.logic.v3.LogEntry.message)
}
#endif
inline void LogEntry::set_message(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  message_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:ric.logic.v3.LogEntry.message)
}
inline void LogEntry::set_message(const char* value, size_t size) {
  
  message_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:ric.logic.v3.LogEntry.message)
}
inline ::std::string* LogEntry::mutable_message() {
  
  // @@protoc_insertion_point(field_mutable:ric.logic.v3.LogEntry.message)
  return message_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* LogEntry::release_message() {
  // @@protoc_insertion_point(field_release:ric.logic.v3.LogEntry.message)
  
  return message_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void LogEntry::set_allocated_message(::std::string* message) {
  if (message != nullptr) {
    
  } else {
    
  }
  message_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), message);
  // @@protoc_insertion_point(field_set_allocated:ric.logic.v3.LogEntry.message)
}

// .ric.logic.v3.AutomatonEvent event = 10;
inline bool LogEntry::has_event() const {
  return this != internal_default_instance() && event_ != nullptr;
}
inline void LogEntry::clear_event() {
  if (GetArenaNoVirtual() == nullptr && event_ != nullptr) {
    delete event_;
  }
  event_ = nullptr;
}
inline const ::ric::logic::v3::AutomatonEvent& LogEntry::event() const {
  const ::ric::logic::v3::AutomatonEvent* p = event_;
  // @@protoc_insertion_point(field_get:ric.logic.v3.LogEntry.event)
  return p != nullptr ? *p : *reinterpret_cast<const ::ric::logic::v3::AutomatonEvent*>(
      &::ric::logic::v3::_AutomatonEvent_default_instance_);
}
inline ::ric::logic::v3::AutomatonEvent* LogEntry::release_event() {
  // @@protoc_insertion_point(field_release:ric.logic.v3.LogEntry.event)
  
  ::ric::logic::v3::AutomatonEvent* temp = event_;
  event_ = nullptr;
  return temp;
}
inline ::ric::logic::v3::AutomatonEvent* LogEntry::mutable_event() {
  
  if (event_ == nullptr) {
    auto* p = CreateMaybeMessage<::ric::logic::v3::AutomatonEvent>(GetArenaNoVirtual());
    event_ = p;
  }
  // @@protoc_insertion_point(field_mutable:ric.logic.v3.LogEntry.event)
  return event_;
}
inline void LogEntry::set_allocated_event(::ric::logic::v3::AutomatonEvent* event) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete event_;
  }
  if (event) {
    ::google::protobuf::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      event = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, event, submessage_arena);
    }
    
  } else {
    
  }
  event_ = event;
  // @@protoc_insertion_point(field_set_allocated:ric.logic.v3.LogEntry.event)
}

// string state = 11;
inline void LogEntry::clear_state() {
  state_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& LogEntry::state() const {
  // @@protoc_insertion_point(field_get:ric.logic.v3.LogEntry.state)
  return state_.GetNoArena();
}
inline void LogEntry::set_state(const ::std::string& value) {
  
  state_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:ric.logic.v3.LogEntry.state)
}
#if LANG_CXX11
inline void LogEntry::set_state(::std::string&& value) {
  
  state_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:ric.logic.v3.LogEntry.state)
}
#endif
inline void LogEntry::set_state(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  state_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:ric.logic.v3.LogEntry.state)
}
inline void LogEntry::set_state(const char* value, size_t size) {
  
  state_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:ric.logic.v3.LogEntry.state)
}
inline ::std::string* LogEntry::mutable_state() {
  
  // @@protoc_insertion_point(field_mutable:ric.logic.v3.LogEntry.state)
  return state_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* LogEntry::release_state() {
  // @@protoc_insertion_point(field_release:ric.logic.v3.LogEntry.state)
  
  return state_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void LogEntry::set_allocated_state(::std::string* state) {
  if (state != nullptr) {
    
  } else {
    
  }
  state_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), state);
  // @@protoc_insertion_point(field_set_allocated:ric.logic.v3.LogEntry.state)
}

// string prev_state = 12;
inline void LogEntry::clear_prev_state() {
  prev_state_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& LogEntry::prev_state() const {
  // @@protoc_insertion_point(field_get:ric.logic.v3.LogEntry.prev_state)
  return prev_state_.GetNoArena();
}
inline void LogEntry::set_prev_state(const ::std::string& value) {
  
  prev_state_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:ric.logic.v3.LogEntry.prev_state)
}
#if LANG_CXX11
inline void LogEntry::set_prev_state(::std::string&& value) {
  
  prev_state_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:ric.logic.v3.LogEntry.prev_state)
}
#endif
inline void LogEntry::set_prev_state(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  prev_state_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:ric.logic.v3.LogEntry.prev_state)
}
inline void LogEntry::set_prev_state(const char* value, size_t size) {
  
  prev_state_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:ric.logic.v3.LogEntry.prev_state)
}
inline ::std::string* LogEntry::mutable_prev_state() {
  
  // @@protoc_insertion_point(field_mutable:ric.logic.v3.LogEntry.prev_state)
  return prev_state_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* LogEntry::release_prev_state() {
  // @@protoc_insertion_point(field_release:ric.logic.v3.LogEntry.prev_state)
  
  return prev_state_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void LogEntry::set_allocated_prev_state(::std::string* prev_state) {
  if (prev_state != nullptr) {
    
  } else {
    
  }
  prev_state_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), prev_state);
  // @@protoc_insertion_point(field_set_allocated:ric.logic.v3.LogEntry.prev_state)
}

// .ric.logic.v3.UserContext ctx = 13;
inline bool LogEntry::has_ctx() const {
  return this != internal_default_instance() && ctx_ != nullptr;
}
inline void LogEntry::clear_ctx() {
  if (GetArenaNoVirtual() == nullptr && ctx_ != nullptr) {
    delete ctx_;
  }
  ctx_ = nullptr;
}
inline const ::ric::logic::v3::UserContext& LogEntry::ctx() const {
  const ::ric::logic::v3::UserContext* p = ctx_;
  // @@protoc_insertion_point(field_get:ric.logic.v3.LogEntry.ctx)
  return p != nullptr ? *p : *reinterpret_cast<const ::ric::logic::v3::UserContext*>(
      &::ric::logic::v3::_UserContext_default_instance_);
}
inline ::ric::logic::v3::UserContext* LogEntry::release_ctx() {
  // @@protoc_insertion_point(field_release:ric.logic.v3.LogEntry.ctx)
  
  ::ric::logic::v3::UserContext* temp = ctx_;
  ctx_ = nullptr;
  return temp;
}
inline ::ric::logic::v3::UserContext* LogEntry::mutable_ctx() {
  
  if (ctx_ == nullptr) {
    auto* p = CreateMaybeMessage<::ric::logic::v3::UserContext>(GetArenaNoVirtual());
    ctx_ = p;
  }
  // @@protoc_insertion_point(field_mutable:ric.logic.v3.LogEntry.ctx)
  return ctx_;
}
inline void LogEntry::set_allocated_ctx(::ric::logic::v3::UserContext* ctx) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete ctx_;
  }
  if (ctx) {
    ::google::protobuf::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      ctx = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, ctx, submessage_arena);
    }
    
  } else {
    
  }
  ctx_ = ctx;
  // @@protoc_insertion_point(field_set_allocated:ric.logic.v3.LogEntry.ctx)
}

// .ric.logic.v3.ActionResult result = 14;
inline bool LogEntry::has_result() const {
  return this != internal_default_instance() && result_ != nullptr;
}
inline void LogEntry::clear_result() {
  if (GetArenaNoVirtual() == nullptr && result_ != nullptr) {
    delete result_;
  }
  result_ = nullptr;
}
inline const ::ric::logic::v3::ActionResult& LogEntry::result() const {
  const ::ric::logic::v3::ActionResult* p = result_;
  // @@protoc_insertion_point(field_get:ric.logic.v3.LogEntry.result)
  return p != nullptr ? *p : *reinterpret_cast<const ::ric::logic::v3::ActionResult*>(
      &::ric::logic::v3::_ActionResult_default_instance_);
}
inline ::ric::logic::v3::ActionResult* LogEntry::release_result() {
  // @@protoc_insertion_point(field_release:ric.logic.v3.LogEntry.result)
  
  ::ric::logic::v3::ActionResult* temp = result_;
  result_ = nullptr;
  return temp;
}
inline ::ric::logic::v3::ActionResult* LogEntry::mutable_result() {
  
  if (result_ == nullptr) {
    auto* p = CreateMaybeMessage<::ric::logic::v3::ActionResult>(GetArenaNoVirtual());
    result_ = p;
  }
  // @@protoc_insertion_point(field_mutable:ric.logic.v3.LogEntry.result)
  return result_;
}
inline void LogEntry::set_allocated_result(::ric::logic::v3::ActionResult* result) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete result_;
  }
  if (result) {
    ::google::protobuf::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      result = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, result, submessage_arena);
    }
    
  } else {
    
  }
  result_ = result;
  // @@protoc_insertion_point(field_set_allocated:ric.logic.v3.LogEntry.result)
}

// -------------------------------------------------------------------

// WaitCondition

// string timeout = 1;
inline void WaitCondition::clear_timeout() {
  timeout_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& WaitCondition::timeout() const {
  // @@protoc_insertion_point(field_get:ric.logic.v3.WaitCondition.timeout)
  return timeout_.GetNoArena();
}
inline void WaitCondition::set_timeout(const ::std::string& value) {
  
  timeout_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:ric.logic.v3.WaitCondition.timeout)
}
#if LANG_CXX11
inline void WaitCondition::set_timeout(::std::string&& value) {
  
  timeout_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:ric.logic.v3.WaitCondition.timeout)
}
#endif
inline void WaitCondition::set_timeout(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  timeout_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:ric.logic.v3.WaitCondition.timeout)
}
inline void WaitCondition::set_timeout(const char* value, size_t size) {
  
  timeout_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:ric.logic.v3.WaitCondition.timeout)
}
inline ::std::string* WaitCondition::mutable_timeout() {
  
  // @@protoc_insertion_point(field_mutable:ric.logic.v3.WaitCondition.timeout)
  return timeout_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* WaitCondition::release_timeout() {
  // @@protoc_insertion_point(field_release:ric.logic.v3.WaitCondition.timeout)
  
  return timeout_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void WaitCondition::set_allocated_timeout(::std::string* timeout) {
  if (timeout != nullptr) {
    
  } else {
    
  }
  timeout_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), timeout);
  // @@protoc_insertion_point(field_set_allocated:ric.logic.v3.WaitCondition.timeout)
}

// string event = 2;
inline void WaitCondition::clear_event() {
  event_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& WaitCondition::event() const {
  // @@protoc_insertion_point(field_get:ric.logic.v3.WaitCondition.event)
  return event_.GetNoArena();
}
inline void WaitCondition::set_event(const ::std::string& value) {
  
  event_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:ric.logic.v3.WaitCondition.event)
}
#if LANG_CXX11
inline void WaitCondition::set_event(::std::string&& value) {
  
  event_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:ric.logic.v3.WaitCondition.event)
}
#endif
inline void WaitCondition::set_event(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  event_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:ric.logic.v3.WaitCondition.event)
}
inline void WaitCondition::set_event(const char* value, size_t size) {
  
  event_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:ric.logic.v3.WaitCondition.event)
}
inline ::std::string* WaitCondition::mutable_event() {
  
  // @@protoc_insertion_point(field_mutable:ric.logic.v3.WaitCondition.event)
  return event_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* WaitCondition::release_event() {
  // @@protoc_insertion_point(field_release:ric.logic.v3.WaitCondition.event)
  
  return event_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void WaitCondition::set_allocated_event(::std::string* event) {
  if (event != nullptr) {
    
  } else {
    
  }
  event_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), event);
  // @@protoc_insertion_point(field_set_allocated:ric.logic.v3.WaitCondition.event)
}

// string state = 3;
inline void WaitCondition::clear_state() {
  state_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& WaitCondition::state() const {
  // @@protoc_insertion_point(field_get:ric.logic.v3.WaitCondition.state)
  return state_.GetNoArena();
}
inline void WaitCondition::set_state(const ::std::string& value) {
  
  state_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:ric.logic.v3.WaitCondition.state)
}
#if LANG_CXX11
inline void WaitCondition::set_state(::std::string&& value) {
  
  state_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:ric.logic.v3.WaitCondition.state)
}
#endif
inline void WaitCondition::set_state(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  state_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:ric.logic.v3.WaitCondition.state)
}
inline void WaitCondition::set_state(const char* value, size_t size) {
  
  state_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:ric.logic.v3.WaitCondition.state)
}
inline ::std::string* WaitCondition::mutable_state() {
  
  // @@protoc_insertion_point(field_mutable:ric.logic.v3.WaitCondition.state)
  return state_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* WaitCondition::release_state() {
  // @@protoc_insertion_point(field_release:ric.logic.v3.WaitCondition.state)
  
  return state_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void WaitCondition::set_allocated_state(::std::string* state) {
  if (state != nullptr) {
    
  } else {
    
  }
  state_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), state);
  // @@protoc_insertion_point(field_set_allocated:ric.logic.v3.WaitCondition.state)
}

// string status = 4;
inline void WaitCondition::clear_status() {
  status_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& WaitCondition::status() const {
  // @@protoc_insertion_point(field_get:ric.logic.v3.WaitCondition.status)
  return status_.GetNoArena();
}
inline void WaitCondition::set_status(const ::std::string& value) {
  
  status_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:ric.logic.v3.WaitCondition.status)
}
#if LANG_CXX11
inline void WaitCondition::set_status(::std::string&& value) {
  
  status_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:ric.logic.v3.WaitCondition.status)
}
#endif
inline void WaitCondition::set_status(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  status_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:ric.logic.v3.WaitCondition.status)
}
inline void WaitCondition::set_status(const char* value, size_t size) {
  
  status_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:ric.logic.v3.WaitCondition.status)
}
inline ::std::string* WaitCondition::mutable_status() {
  
  // @@protoc_insertion_point(field_mutable:ric.logic.v3.WaitCondition.status)
  return status_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* WaitCondition::release_status() {
  // @@protoc_insertion_point(field_release:ric.logic.v3.WaitCondition.status)
  
  return status_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void WaitCondition::set_allocated_status(::std::string* status) {
  if (status != nullptr) {
    
  } else {
    
  }
  status_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), status);
  // @@protoc_insertion_point(field_set_allocated:ric.logic.v3.WaitCondition.status)
}

// -------------------------------------------------------------------

// GetInstanceInfoRequest

// -------------------------------------------------------------------

// GetInstanceInfoResponse

// string hostname = 1;
inline void GetInstanceInfoResponse::clear_hostname() {
  hostname_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& GetInstanceInfoResponse::hostname() const {
  // @@protoc_insertion_point(field_get:ric.logic.v3.GetInstanceInfoResponse.hostname)
  return hostname_.GetNoArena();
}
inline void GetInstanceInfoResponse::set_hostname(const ::std::string& value) {
  
  hostname_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:ric.logic.v3.GetInstanceInfoResponse.hostname)
}
#if LANG_CXX11
inline void GetInstanceInfoResponse::set_hostname(::std::string&& value) {
  
  hostname_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:ric.logic.v3.GetInstanceInfoResponse.hostname)
}
#endif
inline void GetInstanceInfoResponse::set_hostname(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  hostname_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:ric.logic.v3.GetInstanceInfoResponse.hostname)
}
inline void GetInstanceInfoResponse::set_hostname(const char* value, size_t size) {
  
  hostname_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:ric.logic.v3.GetInstanceInfoResponse.hostname)
}
inline ::std::string* GetInstanceInfoResponse::mutable_hostname() {
  
  // @@protoc_insertion_point(field_mutable:ric.logic.v3.GetInstanceInfoResponse.hostname)
  return hostname_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* GetInstanceInfoResponse::release_hostname() {
  // @@protoc_insertion_point(field_release:ric.logic.v3.GetInstanceInfoResponse.hostname)
  
  return hostname_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void GetInstanceInfoResponse::set_allocated_hostname(::std::string* hostname) {
  if (hostname != nullptr) {
    
  } else {
    
  }
  hostname_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), hostname);
  // @@protoc_insertion_point(field_set_allocated:ric.logic.v3.GetInstanceInfoResponse.hostname)
}

// string status = 2;
inline void GetInstanceInfoResponse::clear_status() {
  status_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& GetInstanceInfoResponse::status() const {
  // @@protoc_insertion_point(field_get:ric.logic.v3.GetInstanceInfoResponse.status)
  return status_.GetNoArena();
}
inline void GetInstanceInfoResponse::set_status(const ::std::string& value) {
  
  status_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:ric.logic.v3.GetInstanceInfoResponse.status)
}
#if LANG_CXX11
inline void GetInstanceInfoResponse::set_status(::std::string&& value) {
  
  status_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:ric.logic.v3.GetInstanceInfoResponse.status)
}
#endif
inline void GetInstanceInfoResponse::set_status(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  status_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:ric.logic.v3.GetInstanceInfoResponse.status)
}
inline void GetInstanceInfoResponse::set_status(const char* value, size_t size) {
  
  status_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:ric.logic.v3.GetInstanceInfoResponse.status)
}
inline ::std::string* GetInstanceInfoResponse::mutable_status() {
  
  // @@protoc_insertion_point(field_mutable:ric.logic.v3.GetInstanceInfoResponse.status)
  return status_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* GetInstanceInfoResponse::release_status() {
  // @@protoc_insertion_point(field_release:ric.logic.v3.GetInstanceInfoResponse.status)
  
  return status_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void GetInstanceInfoResponse::set_allocated_status(::std::string* status) {
  if (status != nullptr) {
    
  } else {
    
  }
  status_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), status);
  // @@protoc_insertion_point(field_set_allocated:ric.logic.v3.GetInstanceInfoResponse.status)
}

// int64 started_at = 3;
inline void GetInstanceInfoResponse::clear_started_at() {
  started_at_ = PROTOBUF_LONGLONG(0);
}
inline ::google::protobuf::int64 GetInstanceInfoResponse::started_at() const {
  // @@protoc_insertion_point(field_get:ric.logic.v3.GetInstanceInfoResponse.started_at)
  return started_at_;
}
inline void GetInstanceInfoResponse::set_started_at(::google::protobuf::int64 value) {
  
  started_at_ = value;
  // @@protoc_insertion_point(field_set:ric.logic.v3.GetInstanceInfoResponse.started_at)
}

// int64 objects_total = 4;
inline void GetInstanceInfoResponse::clear_objects_total() {
  objects_total_ = PROTOBUF_LONGLONG(0);
}
inline ::google::protobuf::int64 GetInstanceInfoResponse::objects_total() const {
  // @@protoc_insertion_point(field_get:ric.logic.v3.GetInstanceInfoResponse.objects_total)
  return objects_total_;
}
inline void GetInstanceInfoResponse::set_objects_total(::google::protobuf::int64 value) {
  
  objects_total_ = value;
  // @@protoc_insertion_point(field_set:ric.logic.v3.GetInstanceInfoResponse.objects_total)
}

// int64 containers_total = 5;
inline void GetInstanceInfoResponse::clear_containers_total() {
  containers_total_ = PROTOBUF_LONGLONG(0);
}
inline ::google::protobuf::int64 GetInstanceInfoResponse::containers_total() const {
  // @@protoc_insertion_point(field_get:ric.logic.v3.GetInstanceInfoResponse.containers_total)
  return containers_total_;
}
inline void GetInstanceInfoResponse::set_containers_total(::google::protobuf::int64 value) {
  
  containers_total_ = value;
  // @@protoc_insertion_point(field_set:ric.logic.v3.GetInstanceInfoResponse.containers_total)
}

// int64 containers_running = 6;
inline void GetInstanceInfoResponse::clear_containers_running() {
  containers_running_ = PROTOBUF_LONGLONG(0);
}
inline ::google::protobuf::int64 GetInstanceInfoResponse::containers_running() const {
  // @@protoc_insertion_point(field_get:ric.logic.v3.GetInstanceInfoResponse.containers_running)
  return containers_running_;
}
inline void GetInstanceInfoResponse::set_containers_running(::google::protobuf::int64 value) {
  
  containers_running_ = value;
  // @@protoc_insertion_point(field_set:ric.logic.v3.GetInstanceInfoResponse.containers_running)
}

// repeated string object_ids = 7;
inline int GetInstanceInfoResponse::object_ids_size() const {
  return object_ids_.size();
}
inline void GetInstanceInfoResponse::clear_object_ids() {
  object_ids_.Clear();
}
inline const ::std::string& GetInstanceInfoResponse::object_ids(int index) const {
  // @@protoc_insertion_point(field_get:ric.logic.v3.GetInstanceInfoResponse.object_ids)
  return object_ids_.Get(index);
}
inline ::std::string* GetInstanceInfoResponse::mutable_object_ids(int index) {
  // @@protoc_insertion_point(field_mutable:ric.logic.v3.GetInstanceInfoResponse.object_ids)
  return object_ids_.Mutable(index);
}
inline void GetInstanceInfoResponse::set_object_ids(int index, const ::std::string& value) {
  // @@protoc_insertion_point(field_set:ric.logic.v3.GetInstanceInfoResponse.object_ids)
  object_ids_.Mutable(index)->assign(value);
}
#if LANG_CXX11
inline void GetInstanceInfoResponse::set_object_ids(int index, ::std::string&& value) {
  // @@protoc_insertion_point(field_set:ric.logic.v3.GetInstanceInfoResponse.object_ids)
  object_ids_.Mutable(index)->assign(std::move(value));
}
#endif
inline void GetInstanceInfoResponse::set_object_ids(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  object_ids_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:ric.logic.v3.GetInstanceInfoResponse.object_ids)
}
inline void GetInstanceInfoResponse::set_object_ids(int index, const char* value, size_t size) {
  object_ids_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:ric.logic.v3.GetInstanceInfoResponse.object_ids)
}
inline ::std::string* GetInstanceInfoResponse::add_object_ids() {
  // @@protoc_insertion_point(field_add_mutable:ric.logic.v3.GetInstanceInfoResponse.object_ids)
  return object_ids_.Add();
}
inline void GetInstanceInfoResponse::add_object_ids(const ::std::string& value) {
  object_ids_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:ric.logic.v3.GetInstanceInfoResponse.object_ids)
}
#if LANG_CXX11
inline void GetInstanceInfoResponse::add_object_ids(::std::string&& value) {
  object_ids_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:ric.logic.v3.GetInstanceInfoResponse.object_ids)
}
#endif
inline void GetInstanceInfoResponse::add_object_ids(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  object_ids_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:ric.logic.v3.GetInstanceInfoResponse.object_ids)
}
inline void GetInstanceInfoResponse::add_object_ids(const char* value, size_t size) {
  object_ids_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:ric.logic.v3.GetInstanceInfoResponse.object_ids)
}
inline const ::google::protobuf::RepeatedPtrField<::std::string>&
GetInstanceInfoResponse::object_ids() const {
  // @@protoc_insertion_point(field_list:ric.logic.v3.GetInstanceInfoResponse.object_ids)
  return object_ids_;
}
inline ::google::protobuf::RepeatedPtrField<::std::string>*
GetInstanceInfoResponse::mutable_object_ids() {
  // @@protoc_insertion_point(field_mutable_list:ric.logic.v3.GetInstanceInfoResponse.object_ids)
  return &object_ids_;
}

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// StartAutomatonRequest

// .ric.logic.v3.UserContext ctx = 1;
inline bool StartAutomatonRequest::has_ctx() const {
  return this != internal_default_instance() && ctx_ != nullptr;
}
inline void StartAutomatonRequest::clear_ctx() {
  if (GetArenaNoVirtual() == nullptr && ctx_ != nullptr) {
    delete ctx_;
  }
  ctx_ = nullptr;
}
inline const ::ric::logic::v3::UserContext& StartAutomatonRequest::ctx() const {
  const ::ric::logic::v3::UserContext* p = ctx_;
  // @@protoc_insertion_point(field_get:ric.logic.v3.StartAutomatonRequest.ctx)
  return p != nullptr ? *p : *reinterpret_cast<const ::ric::logic::v3::UserContext*>(
      &::ric::logic::v3::_UserContext_default_instance_);
}
inline ::ric::logic::v3::UserContext* StartAutomatonRequest::release_ctx() {
  // @@protoc_insertion_point(field_release:ric.logic.v3.StartAutomatonRequest.ctx)
  
  ::ric::logic::v3::UserContext* temp = ctx_;
  ctx_ = nullptr;
  return temp;
}
inline ::ric::logic::v3::UserContext* StartAutomatonRequest::mutable_ctx() {
  
  if (ctx_ == nullptr) {
    auto* p = CreateMaybeMessage<::ric::logic::v3::UserContext>(GetArenaNoVirtual());
    ctx_ = p;
  }
  // @@protoc_insertion_point(field_mutable:ric.logic.v3.StartAutomatonRequest.ctx)
  return ctx_;
}
inline void StartAutomatonRequest::set_allocated_ctx(::ric::logic::v3::UserContext* ctx) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete ctx_;
  }
  if (ctx) {
    ::google::protobuf::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      ctx = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, ctx, submessage_arena);
    }
    
  } else {
    
  }
  ctx_ = ctx;
  // @@protoc_insertion_point(field_set_allocated:ric.logic.v3.StartAutomatonRequest.ctx)
}

// string object_id = 2;
inline void StartAutomatonRequest::clear_object_id() {
  object_id_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& StartAutomatonRequest::object_id() const {
  // @@protoc_insertion_point(field_get:ric.logic.v3.StartAutomatonRequest.object_id)
  return object_id_.GetNoArena();
}
inline void StartAutomatonRequest::set_object_id(const ::std::string& value) {
  
  object_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:ric.logic.v3.StartAutomatonRequest.object_id)
}
#if LANG_CXX11
inline void StartAutomatonRequest::set_object_id(::std::string&& value) {
  
  object_id_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:ric.logic.v3.StartAutomatonRequest.object_id)
}
#endif
inline void StartAutomatonRequest::set_object_id(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  object_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:ric.logic.v3.StartAutomatonRequest.object_id)
}
inline void StartAutomatonRequest::set_object_id(const char* value, size_t size) {
  
  object_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:ric.logic.v3.StartAutomatonRequest.object_id)
}
inline ::std::string* StartAutomatonRequest::mutable_object_id() {
  
  // @@protoc_insertion_point(field_mutable:ric.logic.v3.StartAutomatonRequest.object_id)
  return object_id_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* StartAutomatonRequest::release_object_id() {
  // @@protoc_insertion_point(field_release:ric.logic.v3.StartAutomatonRequest.object_id)
  
  return object_id_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void StartAutomatonRequest::set_allocated_object_id(::std::string* object_id) {
  if (object_id != nullptr) {
    
  } else {
    
  }
  object_id_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), object_id);
  // @@protoc_insertion_point(field_set_allocated:ric.logic.v3.StartAutomatonRequest.object_id)
}

// string automaton_id = 3;
inline void StartAutomatonRequest::clear_automaton_id() {
  automaton_id_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& StartAutomatonRequest::automaton_id() const {
  // @@protoc_insertion_point(field_get:ric.logic.v3.StartAutomatonRequest.automaton_id)
  return automaton_id_.GetNoArena();
}
inline void StartAutomatonRequest::set_automaton_id(const ::std::string& value) {
  
  automaton_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:ric.logic.v3.StartAutomatonRequest.automaton_id)
}
#if LANG_CXX11
inline void StartAutomatonRequest::set_automaton_id(::std::string&& value) {
  
  automaton_id_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:ric.logic.v3.StartAutomatonRequest.automaton_id)
}
#endif
inline void StartAutomatonRequest::set_automaton_id(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  automaton_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:ric.logic.v3.StartAutomatonRequest.automaton_id)
}
inline void StartAutomatonRequest::set_automaton_id(const char* value, size_t size) {
  
  automaton_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:ric.logic.v3.StartAutomatonRequest.automaton_id)
}
inline ::std::string* StartAutomatonRequest::mutable_automaton_id() {
  
  // @@protoc_insertion_point(field_mutable:ric.logic.v3.StartAutomatonRequest.automaton_id)
  return automaton_id_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* StartAutomatonRequest::release_automaton_id() {
  // @@protoc_insertion_point(field_release:ric.logic.v3.StartAutomatonRequest.automaton_id)
  
  return automaton_id_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void StartAutomatonRequest::set_allocated_automaton_id(::std::string* automaton_id) {
  if (automaton_id != nullptr) {
    
  } else {
    
  }
  automaton_id_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), automaton_id);
  // @@protoc_insertion_point(field_set_allocated:ric.logic.v3.StartAutomatonRequest.automaton_id)
}

// map<string, .ric.logic.v3.AutomatonVarValue> vars = 4;
inline int StartAutomatonRequest::vars_size() const {
  return vars_.size();
}
inline void StartAutomatonRequest::clear_vars() {
  vars_.Clear();
}
inline const ::google::protobuf::Map< ::std::string, ::ric::logic::v3::AutomatonVarValue >&
StartAutomatonRequest::vars() const {
  // @@protoc_insertion_point(field_map:ric.logic.v3.StartAutomatonRequest.vars)
  return vars_.GetMap();
}
inline ::google::protobuf::Map< ::std::string, ::ric::logic::v3::AutomatonVarValue >*
StartAutomatonRequest::mutable_vars() {
  // @@protoc_insertion_point(field_mutable_map:ric.logic.v3.StartAutomatonRequest.vars)
  return vars_.MutableMap();
}

// -------------------------------------------------------------------

// StartAutomatonMultiRequest

// .ric.logic.v3.UserContext ctx = 1;
inline bool StartAutomatonMultiRequest::has_ctx() const {
  return this != internal_default_instance() && ctx_ != nullptr;
}
inline void StartAutomatonMultiRequest::clear_ctx() {
  if (GetArenaNoVirtual() == nullptr && ctx_ != nullptr) {
    delete ctx_;
  }
  ctx_ = nullptr;
}
inline const ::ric::logic::v3::UserContext& StartAutomatonMultiRequest::ctx() const {
  const ::ric::logic::v3::UserContext* p = ctx_;
  // @@protoc_insertion_point(field_get:ric.logic.v3.StartAutomatonMultiRequest.ctx)
  return p != nullptr ? *p : *reinterpret_cast<const ::ric::logic::v3::UserContext*>(
      &::ric::logic::v3::_UserContext_default_instance_);
}
inline ::ric::logic::v3::UserContext* StartAutomatonMultiRequest::release_ctx() {
  // @@protoc_insertion_point(field_release:ric.logic.v3.StartAutomatonMultiRequest.ctx)
  
  ::ric::logic::v3::UserContext* temp = ctx_;
  ctx_ = nullptr;
  return temp;
}
inline ::ric::logic::v3::UserContext* StartAutomatonMultiRequest::mutable_ctx() {
  
  if (ctx_ == nullptr) {
    auto* p = CreateMaybeMessage<::ric::logic::v3::UserContext>(GetArenaNoVirtual());
    ctx_ = p;
  }
  // @@protoc_insertion_point(field_mutable:ric.logic.v3.StartAutomatonMultiRequest.ctx)
  return ctx_;
}
inline void StartAutomatonMultiRequest::set_allocated_ctx(::ric::logic::v3::UserContext* ctx) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete ctx_;
  }
  if (ctx) {
    ::google::protobuf::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      ctx = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, ctx, submessage_arena);
    }
    
  } else {
    
  }
  ctx_ = ctx;
  // @@protoc_insertion_point(field_set_allocated:ric.logic.v3.StartAutomatonMultiRequest.ctx)
}

// repeated string object_ids = 2;
inline int StartAutomatonMultiRequest::object_ids_size() const {
  return object_ids_.size();
}
inline void StartAutomatonMultiRequest::clear_object_ids() {
  object_ids_.Clear();
}
inline const ::std::string& StartAutomatonMultiRequest::object_ids(int index) const {
  // @@protoc_insertion_point(field_get:ric.logic.v3.StartAutomatonMultiRequest.object_ids)
  return object_ids_.Get(index);
}
inline ::std::string* StartAutomatonMultiRequest::mutable_object_ids(int index) {
  // @@protoc_insertion_point(field_mutable:ric.logic.v3.StartAutomatonMultiRequest.object_ids)
  return object_ids_.Mutable(index);
}
inline void StartAutomatonMultiRequest::set_object_ids(int index, const ::std::string& value) {
  // @@protoc_insertion_point(field_set:ric.logic.v3.StartAutomatonMultiRequest.object_ids)
  object_ids_.Mutable(index)->assign(value);
}
#if LANG_CXX11
inline void StartAutomatonMultiRequest::set_object_ids(int index, ::std::string&& value) {
  // @@protoc_insertion_point(field_set:ric.logic.v3.StartAutomatonMultiRequest.object_ids)
  object_ids_.Mutable(index)->assign(std::move(value));
}
#endif
inline void StartAutomatonMultiRequest::set_object_ids(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  object_ids_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:ric.logic.v3.StartAutomatonMultiRequest.object_ids)
}
inline void StartAutomatonMultiRequest::set_object_ids(int index, const char* value, size_t size) {
  object_ids_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:ric.logic.v3.StartAutomatonMultiRequest.object_ids)
}
inline ::std::string* StartAutomatonMultiRequest::add_object_ids() {
  // @@protoc_insertion_point(field_add_mutable:ric.logic.v3.StartAutomatonMultiRequest.object_ids)
  return object_ids_.Add();
}
inline void StartAutomatonMultiRequest::add_object_ids(const ::std::string& value) {
  object_ids_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:ric.logic.v3.StartAutomatonMultiRequest.object_ids)
}
#if LANG_CXX11
inline void StartAutomatonMultiRequest::add_object_ids(::std::string&& value) {
  object_ids_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:ric.logic.v3.StartAutomatonMultiRequest.object_ids)
}
#endif
inline void StartAutomatonMultiRequest::add_object_ids(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  object_ids_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:ric.logic.v3.StartAutomatonMultiRequest.object_ids)
}
inline void StartAutomatonMultiRequest::add_object_ids(const char* value, size_t size) {
  object_ids_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:ric.logic.v3.StartAutomatonMultiRequest.object_ids)
}
inline const ::google::protobuf::RepeatedPtrField<::std::string>&
StartAutomatonMultiRequest::object_ids() const {
  // @@protoc_insertion_point(field_list:ric.logic.v3.StartAutomatonMultiRequest.object_ids)
  return object_ids_;
}
inline ::google::protobuf::RepeatedPtrField<::std::string>*
StartAutomatonMultiRequest::mutable_object_ids() {
  // @@protoc_insertion_point(field_mutable_list:ric.logic.v3.StartAutomatonMultiRequest.object_ids)
  return &object_ids_;
}

// string automaton_id = 3;
inline void StartAutomatonMultiRequest::clear_automaton_id() {
  automaton_id_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& StartAutomatonMultiRequest::automaton_id() const {
  // @@protoc_insertion_point(field_get:ric.logic.v3.StartAutomatonMultiRequest.automaton_id)
  return automaton_id_.GetNoArena();
}
inline void StartAutomatonMultiRequest::set_automaton_id(const ::std::string& value) {
  
  automaton_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:ric.logic.v3.StartAutomatonMultiRequest.automaton_id)
}
#if LANG_CXX11
inline void StartAutomatonMultiRequest::set_automaton_id(::std::string&& value) {
  
  automaton_id_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:ric.logic.v3.StartAutomatonMultiRequest.automaton_id)
}
#endif
inline void StartAutomatonMultiRequest::set_automaton_id(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  automaton_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:ric.logic.v3.StartAutomatonMultiRequest.automaton_id)
}
inline void StartAutomatonMultiRequest::set_automaton_id(const char* value, size_t size) {
  
  automaton_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:ric.logic.v3.StartAutomatonMultiRequest.automaton_id)
}
inline ::std::string* StartAutomatonMultiRequest::mutable_automaton_id() {
  
  // @@protoc_insertion_point(field_mutable:ric.logic.v3.StartAutomatonMultiRequest.automaton_id)
  return automaton_id_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* StartAutomatonMultiRequest::release_automaton_id() {
  // @@protoc_insertion_point(field_release:ric.logic.v3.StartAutomatonMultiRequest.automaton_id)
  
  return automaton_id_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void StartAutomatonMultiRequest::set_allocated_automaton_id(::std::string* automaton_id) {
  if (automaton_id != nullptr) {
    
  } else {
    
  }
  automaton_id_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), automaton_id);
  // @@protoc_insertion_point(field_set_allocated:ric.logic.v3.StartAutomatonMultiRequest.automaton_id)
}

// -------------------------------------------------------------------

// StartAutomatonResponse

// .ric.logic.v3.AutomatonInfo automaton = 1;
inline bool StartAutomatonResponse::has_automaton() const {
  return this != internal_default_instance() && automaton_ != nullptr;
}
inline void StartAutomatonResponse::clear_automaton() {
  if (GetArenaNoVirtual() == nullptr && automaton_ != nullptr) {
    delete automaton_;
  }
  automaton_ = nullptr;
}
inline const ::ric::logic::v3::AutomatonInfo& StartAutomatonResponse::automaton() const {
  const ::ric::logic::v3::AutomatonInfo* p = automaton_;
  // @@protoc_insertion_point(field_get:ric.logic.v3.StartAutomatonResponse.automaton)
  return p != nullptr ? *p : *reinterpret_cast<const ::ric::logic::v3::AutomatonInfo*>(
      &::ric::logic::v3::_AutomatonInfo_default_instance_);
}
inline ::ric::logic::v3::AutomatonInfo* StartAutomatonResponse::release_automaton() {
  // @@protoc_insertion_point(field_release:ric.logic.v3.StartAutomatonResponse.automaton)
  
  ::ric::logic::v3::AutomatonInfo* temp = automaton_;
  automaton_ = nullptr;
  return temp;
}
inline ::ric::logic::v3::AutomatonInfo* StartAutomatonResponse::mutable_automaton() {
  
  if (automaton_ == nullptr) {
    auto* p = CreateMaybeMessage<::ric::logic::v3::AutomatonInfo>(GetArenaNoVirtual());
    automaton_ = p;
  }
  // @@protoc_insertion_point(field_mutable:ric.logic.v3.StartAutomatonResponse.automaton)
  return automaton_;
}
inline void StartAutomatonResponse::set_allocated_automaton(::ric::logic::v3::AutomatonInfo* automaton) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete automaton_;
  }
  if (automaton) {
    ::google::protobuf::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      automaton = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, automaton, submessage_arena);
    }
    
  } else {
    
  }
  automaton_ = automaton;
  // @@protoc_insertion_point(field_set_allocated:ric.logic.v3.StartAutomatonResponse.automaton)
}

// -------------------------------------------------------------------

// StopAutomatonRequest

// .ric.logic.v3.UserContext ctx = 1;
inline bool StopAutomatonRequest::has_ctx() const {
  return this != internal_default_instance() && ctx_ != nullptr;
}
inline void StopAutomatonRequest::clear_ctx() {
  if (GetArenaNoVirtual() == nullptr && ctx_ != nullptr) {
    delete ctx_;
  }
  ctx_ = nullptr;
}
inline const ::ric::logic::v3::UserContext& StopAutomatonRequest::ctx() const {
  const ::ric::logic::v3::UserContext* p = ctx_;
  // @@protoc_insertion_point(field_get:ric.logic.v3.StopAutomatonRequest.ctx)
  return p != nullptr ? *p : *reinterpret_cast<const ::ric::logic::v3::UserContext*>(
      &::ric::logic::v3::_UserContext_default_instance_);
}
inline ::ric::logic::v3::UserContext* StopAutomatonRequest::release_ctx() {
  // @@protoc_insertion_point(field_release:ric.logic.v3.StopAutomatonRequest.ctx)
  
  ::ric::logic::v3::UserContext* temp = ctx_;
  ctx_ = nullptr;
  return temp;
}
inline ::ric::logic::v3::UserContext* StopAutomatonRequest::mutable_ctx() {
  
  if (ctx_ == nullptr) {
    auto* p = CreateMaybeMessage<::ric::logic::v3::UserContext>(GetArenaNoVirtual());
    ctx_ = p;
  }
  // @@protoc_insertion_point(field_mutable:ric.logic.v3.StopAutomatonRequest.ctx)
  return ctx_;
}
inline void StopAutomatonRequest::set_allocated_ctx(::ric::logic::v3::UserContext* ctx) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete ctx_;
  }
  if (ctx) {
    ::google::protobuf::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      ctx = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, ctx, submessage_arena);
    }
    
  } else {
    
  }
  ctx_ = ctx;
  // @@protoc_insertion_point(field_set_allocated:ric.logic.v3.StopAutomatonRequest.ctx)
}

// string object_id = 2;
inline void StopAutomatonRequest::clear_object_id() {
  object_id_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& StopAutomatonRequest::object_id() const {
  // @@protoc_insertion_point(field_get:ric.logic.v3.StopAutomatonRequest.object_id)
  return object_id_.GetNoArena();
}
inline void StopAutomatonRequest::set_object_id(const ::std::string& value) {
  
  object_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:ric.logic.v3.StopAutomatonRequest.object_id)
}
#if LANG_CXX11
inline void StopAutomatonRequest::set_object_id(::std::string&& value) {
  
  object_id_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:ric.logic.v3.StopAutomatonRequest.object_id)
}
#endif
inline void StopAutomatonRequest::set_object_id(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  object_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:ric.logic.v3.StopAutomatonRequest.object_id)
}
inline void StopAutomatonRequest::set_object_id(const char* value, size_t size) {
  
  object_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:ric.logic.v3.StopAutomatonRequest.object_id)
}
inline ::std::string* StopAutomatonRequest::mutable_object_id() {
  
  // @@protoc_insertion_point(field_mutable:ric.logic.v3.StopAutomatonRequest.object_id)
  return object_id_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* StopAutomatonRequest::release_object_id() {
  // @@protoc_insertion_point(field_release:ric.logic.v3.StopAutomatonRequest.object_id)
  
  return object_id_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void StopAutomatonRequest::set_allocated_object_id(::std::string* object_id) {
  if (object_id != nullptr) {
    
  } else {
    
  }
  object_id_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), object_id);
  // @@protoc_insertion_point(field_set_allocated:ric.logic.v3.StopAutomatonRequest.object_id)
}

// string automaton_id = 3;
inline void StopAutomatonRequest::clear_automaton_id() {
  automaton_id_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& StopAutomatonRequest::automaton_id() const {
  // @@protoc_insertion_point(field_get:ric.logic.v3.StopAutomatonRequest.automaton_id)
  return automaton_id_.GetNoArena();
}
inline void StopAutomatonRequest::set_automaton_id(const ::std::string& value) {
  
  automaton_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:ric.logic.v3.StopAutomatonRequest.automaton_id)
}
#if LANG_CXX11
inline void StopAutomatonRequest::set_automaton_id(::std::string&& value) {
  
  automaton_id_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:ric.logic.v3.StopAutomatonRequest.automaton_id)
}
#endif
inline void StopAutomatonRequest::set_automaton_id(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  automaton_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:ric.logic.v3.StopAutomatonRequest.automaton_id)
}
inline void StopAutomatonRequest::set_automaton_id(const char* value, size_t size) {
  
  automaton_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:ric.logic.v3.StopAutomatonRequest.automaton_id)
}
inline ::std::string* StopAutomatonRequest::mutable_automaton_id() {
  
  // @@protoc_insertion_point(field_mutable:ric.logic.v3.StopAutomatonRequest.automaton_id)
  return automaton_id_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* StopAutomatonRequest::release_automaton_id() {
  // @@protoc_insertion_point(field_release:ric.logic.v3.StopAutomatonRequest.automaton_id)
  
  return automaton_id_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void StopAutomatonRequest::set_allocated_automaton_id(::std::string* automaton_id) {
  if (automaton_id != nullptr) {
    
  } else {
    
  }
  automaton_id_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), automaton_id);
  // @@protoc_insertion_point(field_set_allocated:ric.logic.v3.StopAutomatonRequest.automaton_id)
}

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// RunAutomatonRequest

// .ric.logic.v3.UserContext ctx = 1;
inline bool RunAutomatonRequest::has_ctx() const {
  return this != internal_default_instance() && ctx_ != nullptr;
}
inline void RunAutomatonRequest::clear_ctx() {
  if (GetArenaNoVirtual() == nullptr && ctx_ != nullptr) {
    delete ctx_;
  }
  ctx_ = nullptr;
}
inline const ::ric::logic::v3::UserContext& RunAutomatonRequest::ctx() const {
  const ::ric::logic::v3::UserContext* p = ctx_;
  // @@protoc_insertion_point(field_get:ric.logic.v3.RunAutomatonRequest.ctx)
  return p != nullptr ? *p : *reinterpret_cast<const ::ric::logic::v3::UserContext*>(
      &::ric::logic::v3::_UserContext_default_instance_);
}
inline ::ric::logic::v3::UserContext* RunAutomatonRequest::release_ctx() {
  // @@protoc_insertion_point(field_release:ric.logic.v3.RunAutomatonRequest.ctx)
  
  ::ric::logic::v3::UserContext* temp = ctx_;
  ctx_ = nullptr;
  return temp;
}
inline ::ric::logic::v3::UserContext* RunAutomatonRequest::mutable_ctx() {
  
  if (ctx_ == nullptr) {
    auto* p = CreateMaybeMessage<::ric::logic::v3::UserContext>(GetArenaNoVirtual());
    ctx_ = p;
  }
  // @@protoc_insertion_point(field_mutable:ric.logic.v3.RunAutomatonRequest.ctx)
  return ctx_;
}
inline void RunAutomatonRequest::set_allocated_ctx(::ric::logic::v3::UserContext* ctx) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete ctx_;
  }
  if (ctx) {
    ::google::protobuf::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      ctx = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, ctx, submessage_arena);
    }
    
  } else {
    
  }
  ctx_ = ctx;
  // @@protoc_insertion_point(field_set_allocated:ric.logic.v3.RunAutomatonRequest.ctx)
}

// string object_id = 2;
inline void RunAutomatonRequest::clear_object_id() {
  object_id_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& RunAutomatonRequest::object_id() const {
  // @@protoc_insertion_point(field_get:ric.logic.v3.RunAutomatonRequest.object_id)
  return object_id_.GetNoArena();
}
inline void RunAutomatonRequest::set_object_id(const ::std::string& value) {
  
  object_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:ric.logic.v3.RunAutomatonRequest.object_id)
}
#if LANG_CXX11
inline void RunAutomatonRequest::set_object_id(::std::string&& value) {
  
  object_id_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:ric.logic.v3.RunAutomatonRequest.object_id)
}
#endif
inline void RunAutomatonRequest::set_object_id(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  object_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:ric.logic.v3.RunAutomatonRequest.object_id)
}
inline void RunAutomatonRequest::set_object_id(const char* value, size_t size) {
  
  object_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:ric.logic.v3.RunAutomatonRequest.object_id)
}
inline ::std::string* RunAutomatonRequest::mutable_object_id() {
  
  // @@protoc_insertion_point(field_mutable:ric.logic.v3.RunAutomatonRequest.object_id)
  return object_id_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* RunAutomatonRequest::release_object_id() {
  // @@protoc_insertion_point(field_release:ric.logic.v3.RunAutomatonRequest.object_id)
  
  return object_id_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void RunAutomatonRequest::set_allocated_object_id(::std::string* object_id) {
  if (object_id != nullptr) {
    
  } else {
    
  }
  object_id_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), object_id);
  // @@protoc_insertion_point(field_set_allocated:ric.logic.v3.RunAutomatonRequest.object_id)
}

// string automaton_id = 3;
inline void RunAutomatonRequest::clear_automaton_id() {
  automaton_id_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& RunAutomatonRequest::automaton_id() const {
  // @@protoc_insertion_point(field_get:ric.logic.v3.RunAutomatonRequest.automaton_id)
  return automaton_id_.GetNoArena();
}
inline void RunAutomatonRequest::set_automaton_id(const ::std::string& value) {
  
  automaton_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:ric.logic.v3.RunAutomatonRequest.automaton_id)
}
#if LANG_CXX11
inline void RunAutomatonRequest::set_automaton_id(::std::string&& value) {
  
  automaton_id_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:ric.logic.v3.RunAutomatonRequest.automaton_id)
}
#endif
inline void RunAutomatonRequest::set_automaton_id(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  automaton_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:ric.logic.v3.RunAutomatonRequest.automaton_id)
}
inline void RunAutomatonRequest::set_automaton_id(const char* value, size_t size) {
  
  automaton_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:ric.logic.v3.RunAutomatonRequest.automaton_id)
}
inline ::std::string* RunAutomatonRequest::mutable_automaton_id() {
  
  // @@protoc_insertion_point(field_mutable:ric.logic.v3.RunAutomatonRequest.automaton_id)
  return automaton_id_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* RunAutomatonRequest::release_automaton_id() {
  // @@protoc_insertion_point(field_release:ric.logic.v3.RunAutomatonRequest.automaton_id)
  
  return automaton_id_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void RunAutomatonRequest::set_allocated_automaton_id(::std::string* automaton_id) {
  if (automaton_id != nullptr) {
    
  } else {
    
  }
  automaton_id_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), automaton_id);
  // @@protoc_insertion_point(field_set_allocated:ric.logic.v3.RunAutomatonRequest.automaton_id)
}

// .ric.logic.v3.WaitCondition wait = 4;
inline bool RunAutomatonRequest::has_wait() const {
  return this != internal_default_instance() && wait_ != nullptr;
}
inline void RunAutomatonRequest::clear_wait() {
  if (GetArenaNoVirtual() == nullptr && wait_ != nullptr) {
    delete wait_;
  }
  wait_ = nullptr;
}
inline const ::ric::logic::v3::WaitCondition& RunAutomatonRequest::wait() const {
  const ::ric::logic::v3::WaitCondition* p = wait_;
  // @@protoc_insertion_point(field_get:ric.logic.v3.RunAutomatonRequest.wait)
  return p != nullptr ? *p : *reinterpret_cast<const ::ric::logic::v3::WaitCondition*>(
      &::ric::logic::v3::_WaitCondition_default_instance_);
}
inline ::ric::logic::v3::WaitCondition* RunAutomatonRequest::release_wait() {
  // @@protoc_insertion_point(field_release:ric.logic.v3.RunAutomatonRequest.wait)
  
  ::ric::logic::v3::WaitCondition* temp = wait_;
  wait_ = nullptr;
  return temp;
}
inline ::ric::logic::v3::WaitCondition* RunAutomatonRequest::mutable_wait() {
  
  if (wait_ == nullptr) {
    auto* p = CreateMaybeMessage<::ric::logic::v3::WaitCondition>(GetArenaNoVirtual());
    wait_ = p;
  }
  // @@protoc_insertion_point(field_mutable:ric.logic.v3.RunAutomatonRequest.wait)
  return wait_;
}
inline void RunAutomatonRequest::set_allocated_wait(::ric::logic::v3::WaitCondition* wait) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete wait_;
  }
  if (wait) {
    ::google::protobuf::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      wait = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, wait, submessage_arena);
    }
    
  } else {
    
  }
  wait_ = wait;
  // @@protoc_insertion_point(field_set_allocated:ric.logic.v3.RunAutomatonRequest.wait)
}

// string on_running = 6;
inline void RunAutomatonRequest::clear_on_running() {
  on_running_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& RunAutomatonRequest::on_running() const {
  // @@protoc_insertion_point(field_get:ric.logic.v3.RunAutomatonRequest.on_running)
  return on_running_.GetNoArena();
}
inline void RunAutomatonRequest::set_on_running(const ::std::string& value) {
  
  on_running_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:ric.logic.v3.RunAutomatonRequest.on_running)
}
#if LANG_CXX11
inline void RunAutomatonRequest::set_on_running(::std::string&& value) {
  
  on_running_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:ric.logic.v3.RunAutomatonRequest.on_running)
}
#endif
inline void RunAutomatonRequest::set_on_running(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  on_running_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:ric.logic.v3.RunAutomatonRequest.on_running)
}
inline void RunAutomatonRequest::set_on_running(const char* value, size_t size) {
  
  on_running_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:ric.logic.v3.RunAutomatonRequest.on_running)
}
inline ::std::string* RunAutomatonRequest::mutable_on_running() {
  
  // @@protoc_insertion_point(field_mutable:ric.logic.v3.RunAutomatonRequest.on_running)
  return on_running_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* RunAutomatonRequest::release_on_running() {
  // @@protoc_insertion_point(field_release:ric.logic.v3.RunAutomatonRequest.on_running)
  
  return on_running_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void RunAutomatonRequest::set_allocated_on_running(::std::string* on_running) {
  if (on_running != nullptr) {
    
  } else {
    
  }
  on_running_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), on_running);
  // @@protoc_insertion_point(field_set_allocated:ric.logic.v3.RunAutomatonRequest.on_running)
}

// map<string, .ric.logic.v3.AutomatonVarValue> vars = 7;
inline int RunAutomatonRequest::vars_size() const {
  return vars_.size();
}
inline void RunAutomatonRequest::clear_vars() {
  vars_.Clear();
}
inline const ::google::protobuf::Map< ::std::string, ::ric::logic::v3::AutomatonVarValue >&
RunAutomatonRequest::vars() const {
  // @@protoc_insertion_point(field_map:ric.logic.v3.RunAutomatonRequest.vars)
  return vars_.GetMap();
}
inline ::google::protobuf::Map< ::std::string, ::ric::logic::v3::AutomatonVarValue >*
RunAutomatonRequest::mutable_vars() {
  // @@protoc_insertion_point(field_mutable_map:ric.logic.v3.RunAutomatonRequest.vars)
  return vars_.MutableMap();
}

// -------------------------------------------------------------------

// StopAutomatonResponse

// .ric.logic.v3.AutomatonInfo automaton = 1;
inline bool StopAutomatonResponse::has_automaton() const {
  return this != internal_default_instance() && automaton_ != nullptr;
}
inline void StopAutomatonResponse::clear_automaton() {
  if (GetArenaNoVirtual() == nullptr && automaton_ != nullptr) {
    delete automaton_;
  }
  automaton_ = nullptr;
}
inline const ::ric::logic::v3::AutomatonInfo& StopAutomatonResponse::automaton() const {
  const ::ric::logic::v3::AutomatonInfo* p = automaton_;
  // @@protoc_insertion_point(field_get:ric.logic.v3.StopAutomatonResponse.automaton)
  return p != nullptr ? *p : *reinterpret_cast<const ::ric::logic::v3::AutomatonInfo*>(
      &::ric::logic::v3::_AutomatonInfo_default_instance_);
}
inline ::ric::logic::v3::AutomatonInfo* StopAutomatonResponse::release_automaton() {
  // @@protoc_insertion_point(field_release:ric.logic.v3.StopAutomatonResponse.automaton)
  
  ::ric::logic::v3::AutomatonInfo* temp = automaton_;
  automaton_ = nullptr;
  return temp;
}
inline ::ric::logic::v3::AutomatonInfo* StopAutomatonResponse::mutable_automaton() {
  
  if (automaton_ == nullptr) {
    auto* p = CreateMaybeMessage<::ric::logic::v3::AutomatonInfo>(GetArenaNoVirtual());
    automaton_ = p;
  }
  // @@protoc_insertion_point(field_mutable:ric.logic.v3.StopAutomatonResponse.automaton)
  return automaton_;
}
inline void StopAutomatonResponse::set_allocated_automaton(::ric::logic::v3::AutomatonInfo* automaton) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete automaton_;
  }
  if (automaton) {
    ::google::protobuf::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      automaton = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, automaton, submessage_arena);
    }
    
  } else {
    
  }
  automaton_ = automaton;
  // @@protoc_insertion_point(field_set_allocated:ric.logic.v3.StopAutomatonResponse.automaton)
}

// -------------------------------------------------------------------

// GetAutomatonsRequest

// repeated string object_ids = 1;
inline int GetAutomatonsRequest::object_ids_size() const {
  return object_ids_.size();
}
inline void GetAutomatonsRequest::clear_object_ids() {
  object_ids_.Clear();
}
inline const ::std::string& GetAutomatonsRequest::object_ids(int index) const {
  // @@protoc_insertion_point(field_get:ric.logic.v3.GetAutomatonsRequest.object_ids)
  return object_ids_.Get(index);
}
inline ::std::string* GetAutomatonsRequest::mutable_object_ids(int index) {
  // @@protoc_insertion_point(field_mutable:ric.logic.v3.GetAutomatonsRequest.object_ids)
  return object_ids_.Mutable(index);
}
inline void GetAutomatonsRequest::set_object_ids(int index, const ::std::string& value) {
  // @@protoc_insertion_point(field_set:ric.logic.v3.GetAutomatonsRequest.object_ids)
  object_ids_.Mutable(index)->assign(value);
}
#if LANG_CXX11
inline void GetAutomatonsRequest::set_object_ids(int index, ::std::string&& value) {
  // @@protoc_insertion_point(field_set:ric.logic.v3.GetAutomatonsRequest.object_ids)
  object_ids_.Mutable(index)->assign(std::move(value));
}
#endif
inline void GetAutomatonsRequest::set_object_ids(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  object_ids_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:ric.logic.v3.GetAutomatonsRequest.object_ids)
}
inline void GetAutomatonsRequest::set_object_ids(int index, const char* value, size_t size) {
  object_ids_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:ric.logic.v3.GetAutomatonsRequest.object_ids)
}
inline ::std::string* GetAutomatonsRequest::add_object_ids() {
  // @@protoc_insertion_point(field_add_mutable:ric.logic.v3.GetAutomatonsRequest.object_ids)
  return object_ids_.Add();
}
inline void GetAutomatonsRequest::add_object_ids(const ::std::string& value) {
  object_ids_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:ric.logic.v3.GetAutomatonsRequest.object_ids)
}
#if LANG_CXX11
inline void GetAutomatonsRequest::add_object_ids(::std::string&& value) {
  object_ids_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:ric.logic.v3.GetAutomatonsRequest.object_ids)
}
#endif
inline void GetAutomatonsRequest::add_object_ids(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  object_ids_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:ric.logic.v3.GetAutomatonsRequest.object_ids)
}
inline void GetAutomatonsRequest::add_object_ids(const char* value, size_t size) {
  object_ids_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:ric.logic.v3.GetAutomatonsRequest.object_ids)
}
inline const ::google::protobuf::RepeatedPtrField<::std::string>&
GetAutomatonsRequest::object_ids() const {
  // @@protoc_insertion_point(field_list:ric.logic.v3.GetAutomatonsRequest.object_ids)
  return object_ids_;
}
inline ::google::protobuf::RepeatedPtrField<::std::string>*
GetAutomatonsRequest::mutable_object_ids() {
  // @@protoc_insertion_point(field_mutable_list:ric.logic.v3.GetAutomatonsRequest.object_ids)
  return &object_ids_;
}

// repeated string automaton_ids = 2;
inline int GetAutomatonsRequest::automaton_ids_size() const {
  return automaton_ids_.size();
}
inline void GetAutomatonsRequest::clear_automaton_ids() {
  automaton_ids_.Clear();
}
inline const ::std::string& GetAutomatonsRequest::automaton_ids(int index) const {
  // @@protoc_insertion_point(field_get:ric.logic.v3.GetAutomatonsRequest.automaton_ids)
  return automaton_ids_.Get(index);
}
inline ::std::string* GetAutomatonsRequest::mutable_automaton_ids(int index) {
  // @@protoc_insertion_point(field_mutable:ric.logic.v3.GetAutomatonsRequest.automaton_ids)
  return automaton_ids_.Mutable(index);
}
inline void GetAutomatonsRequest::set_automaton_ids(int index, const ::std::string& value) {
  // @@protoc_insertion_point(field_set:ric.logic.v3.GetAutomatonsRequest.automaton_ids)
  automaton_ids_.Mutable(index)->assign(value);
}
#if LANG_CXX11
inline void GetAutomatonsRequest::set_automaton_ids(int index, ::std::string&& value) {
  // @@protoc_insertion_point(field_set:ric.logic.v3.GetAutomatonsRequest.automaton_ids)
  automaton_ids_.Mutable(index)->assign(std::move(value));
}
#endif
inline void GetAutomatonsRequest::set_automaton_ids(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  automaton_ids_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:ric.logic.v3.GetAutomatonsRequest.automaton_ids)
}
inline void GetAutomatonsRequest::set_automaton_ids(int index, const char* value, size_t size) {
  automaton_ids_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:ric.logic.v3.GetAutomatonsRequest.automaton_ids)
}
inline ::std::string* GetAutomatonsRequest::add_automaton_ids() {
  // @@protoc_insertion_point(field_add_mutable:ric.logic.v3.GetAutomatonsRequest.automaton_ids)
  return automaton_ids_.Add();
}
inline void GetAutomatonsRequest::add_automaton_ids(const ::std::string& value) {
  automaton_ids_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:ric.logic.v3.GetAutomatonsRequest.automaton_ids)
}
#if LANG_CXX11
inline void GetAutomatonsRequest::add_automaton_ids(::std::string&& value) {
  automaton_ids_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:ric.logic.v3.GetAutomatonsRequest.automaton_ids)
}
#endif
inline void GetAutomatonsRequest::add_automaton_ids(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  automaton_ids_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:ric.logic.v3.GetAutomatonsRequest.automaton_ids)
}
inline void GetAutomatonsRequest::add_automaton_ids(const char* value, size_t size) {
  automaton_ids_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:ric.logic.v3.GetAutomatonsRequest.automaton_ids)
}
inline const ::google::protobuf::RepeatedPtrField<::std::string>&
GetAutomatonsRequest::automaton_ids() const {
  // @@protoc_insertion_point(field_list:ric.logic.v3.GetAutomatonsRequest.automaton_ids)
  return automaton_ids_;
}
inline ::google::protobuf::RepeatedPtrField<::std::string>*
GetAutomatonsRequest::mutable_automaton_ids() {
  // @@protoc_insertion_point(field_mutable_list:ric.logic.v3.GetAutomatonsRequest.automaton_ids)
  return &automaton_ids_;
}

// bool with_logs = 3;
inline void GetAutomatonsRequest::clear_with_logs() {
  with_logs_ = false;
}
inline bool GetAutomatonsRequest::with_logs() const {
  // @@protoc_insertion_point(field_get:ric.logic.v3.GetAutomatonsRequest.with_logs)
  return with_logs_;
}
inline void GetAutomatonsRequest::set_with_logs(bool value) {
  
  with_logs_ = value;
  // @@protoc_insertion_point(field_set:ric.logic.v3.GetAutomatonsRequest.with_logs)
}

// bool watch = 4;
inline void GetAutomatonsRequest::clear_watch() {
  watch_ = false;
}
inline bool GetAutomatonsRequest::watch() const {
  // @@protoc_insertion_point(field_get:ric.logic.v3.GetAutomatonsRequest.watch)
  return watch_;
}
inline void GetAutomatonsRequest::set_watch(bool value) {
  
  watch_ = value;
  // @@protoc_insertion_point(field_set:ric.logic.v3.GetAutomatonsRequest.watch)
}

// -------------------------------------------------------------------

// GetAutomatonsResponse

// repeated .ric.logic.v3.AutomatonInfo automatons = 1;
inline int GetAutomatonsResponse::automatons_size() const {
  return automatons_.size();
}
inline void GetAutomatonsResponse::clear_automatons() {
  automatons_.Clear();
}
inline ::ric::logic::v3::AutomatonInfo* GetAutomatonsResponse::mutable_automatons(int index) {
  // @@protoc_insertion_point(field_mutable:ric.logic.v3.GetAutomatonsResponse.automatons)
  return automatons_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::ric::logic::v3::AutomatonInfo >*
GetAutomatonsResponse::mutable_automatons() {
  // @@protoc_insertion_point(field_mutable_list:ric.logic.v3.GetAutomatonsResponse.automatons)
  return &automatons_;
}
inline const ::ric::logic::v3::AutomatonInfo& GetAutomatonsResponse::automatons(int index) const {
  // @@protoc_insertion_point(field_get:ric.logic.v3.GetAutomatonsResponse.automatons)
  return automatons_.Get(index);
}
inline ::ric::logic::v3::AutomatonInfo* GetAutomatonsResponse::add_automatons() {
  // @@protoc_insertion_point(field_add:ric.logic.v3.GetAutomatonsResponse.automatons)
  return automatons_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::ric::logic::v3::AutomatonInfo >&
GetAutomatonsResponse::automatons() const {
  // @@protoc_insertion_point(field_list:ric.logic.v3.GetAutomatonsResponse.automatons)
  return automatons_;
}

// -------------------------------------------------------------------

// EmitEventRequest

// .ric.logic.v3.UserContext ctx = 1;
inline bool EmitEventRequest::has_ctx() const {
  return this != internal_default_instance() && ctx_ != nullptr;
}
inline void EmitEventRequest::clear_ctx() {
  if (GetArenaNoVirtual() == nullptr && ctx_ != nullptr) {
    delete ctx_;
  }
  ctx_ = nullptr;
}
inline const ::ric::logic::v3::UserContext& EmitEventRequest::ctx() const {
  const ::ric::logic::v3::UserContext* p = ctx_;
  // @@protoc_insertion_point(field_get:ric.logic.v3.EmitEventRequest.ctx)
  return p != nullptr ? *p : *reinterpret_cast<const ::ric::logic::v3::UserContext*>(
      &::ric::logic::v3::_UserContext_default_instance_);
}
inline ::ric::logic::v3::UserContext* EmitEventRequest::release_ctx() {
  // @@protoc_insertion_point(field_release:ric.logic.v3.EmitEventRequest.ctx)
  
  ::ric::logic::v3::UserContext* temp = ctx_;
  ctx_ = nullptr;
  return temp;
}
inline ::ric::logic::v3::UserContext* EmitEventRequest::mutable_ctx() {
  
  if (ctx_ == nullptr) {
    auto* p = CreateMaybeMessage<::ric::logic::v3::UserContext>(GetArenaNoVirtual());
    ctx_ = p;
  }
  // @@protoc_insertion_point(field_mutable:ric.logic.v3.EmitEventRequest.ctx)
  return ctx_;
}
inline void EmitEventRequest::set_allocated_ctx(::ric::logic::v3::UserContext* ctx) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete ctx_;
  }
  if (ctx) {
    ::google::protobuf::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      ctx = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, ctx, submessage_arena);
    }
    
  } else {
    
  }
  ctx_ = ctx;
  // @@protoc_insertion_point(field_set_allocated:ric.logic.v3.EmitEventRequest.ctx)
}

// string object_id = 2;
inline void EmitEventRequest::clear_object_id() {
  object_id_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& EmitEventRequest::object_id() const {
  // @@protoc_insertion_point(field_get:ric.logic.v3.EmitEventRequest.object_id)
  return object_id_.GetNoArena();
}
inline void EmitEventRequest::set_object_id(const ::std::string& value) {
  
  object_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:ric.logic.v3.EmitEventRequest.object_id)
}
#if LANG_CXX11
inline void EmitEventRequest::set_object_id(::std::string&& value) {
  
  object_id_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:ric.logic.v3.EmitEventRequest.object_id)
}
#endif
inline void EmitEventRequest::set_object_id(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  object_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:ric.logic.v3.EmitEventRequest.object_id)
}
inline void EmitEventRequest::set_object_id(const char* value, size_t size) {
  
  object_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:ric.logic.v3.EmitEventRequest.object_id)
}
inline ::std::string* EmitEventRequest::mutable_object_id() {
  
  // @@protoc_insertion_point(field_mutable:ric.logic.v3.EmitEventRequest.object_id)
  return object_id_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* EmitEventRequest::release_object_id() {
  // @@protoc_insertion_point(field_release:ric.logic.v3.EmitEventRequest.object_id)
  
  return object_id_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void EmitEventRequest::set_allocated_object_id(::std::string* object_id) {
  if (object_id != nullptr) {
    
  } else {
    
  }
  object_id_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), object_id);
  // @@protoc_insertion_point(field_set_allocated:ric.logic.v3.EmitEventRequest.object_id)
}

// string automaton_id = 3;
inline void EmitEventRequest::clear_automaton_id() {
  automaton_id_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& EmitEventRequest::automaton_id() const {
  // @@protoc_insertion_point(field_get:ric.logic.v3.EmitEventRequest.automaton_id)
  return automaton_id_.GetNoArena();
}
inline void EmitEventRequest::set_automaton_id(const ::std::string& value) {
  
  automaton_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:ric.logic.v3.EmitEventRequest.automaton_id)
}
#if LANG_CXX11
inline void EmitEventRequest::set_automaton_id(::std::string&& value) {
  
  automaton_id_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:ric.logic.v3.EmitEventRequest.automaton_id)
}
#endif
inline void EmitEventRequest::set_automaton_id(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  automaton_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:ric.logic.v3.EmitEventRequest.automaton_id)
}
inline void EmitEventRequest::set_automaton_id(const char* value, size_t size) {
  
  automaton_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:ric.logic.v3.EmitEventRequest.automaton_id)
}
inline ::std::string* EmitEventRequest::mutable_automaton_id() {
  
  // @@protoc_insertion_point(field_mutable:ric.logic.v3.EmitEventRequest.automaton_id)
  return automaton_id_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* EmitEventRequest::release_automaton_id() {
  // @@protoc_insertion_point(field_release:ric.logic.v3.EmitEventRequest.automaton_id)
  
  return automaton_id_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void EmitEventRequest::set_allocated_automaton_id(::std::string* automaton_id) {
  if (automaton_id != nullptr) {
    
  } else {
    
  }
  automaton_id_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), automaton_id);
  // @@protoc_insertion_point(field_set_allocated:ric.logic.v3.EmitEventRequest.automaton_id)
}

// string event = 4;
inline void EmitEventRequest::clear_event() {
  event_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& EmitEventRequest::event() const {
  // @@protoc_insertion_point(field_get:ric.logic.v3.EmitEventRequest.event)
  return event_.GetNoArena();
}
inline void EmitEventRequest::set_event(const ::std::string& value) {
  
  event_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:ric.logic.v3.EmitEventRequest.event)
}
#if LANG_CXX11
inline void EmitEventRequest::set_event(::std::string&& value) {
  
  event_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:ric.logic.v3.EmitEventRequest.event)
}
#endif
inline void EmitEventRequest::set_event(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  event_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:ric.logic.v3.EmitEventRequest.event)
}
inline void EmitEventRequest::set_event(const char* value, size_t size) {
  
  event_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:ric.logic.v3.EmitEventRequest.event)
}
inline ::std::string* EmitEventRequest::mutable_event() {
  
  // @@protoc_insertion_point(field_mutable:ric.logic.v3.EmitEventRequest.event)
  return event_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* EmitEventRequest::release_event() {
  // @@protoc_insertion_point(field_release:ric.logic.v3.EmitEventRequest.event)
  
  return event_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void EmitEventRequest::set_allocated_event(::std::string* event) {
  if (event != nullptr) {
    
  } else {
    
  }
  event_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), event);
  // @@protoc_insertion_point(field_set_allocated:ric.logic.v3.EmitEventRequest.event)
}

// string payload = 5;
inline void EmitEventRequest::clear_payload() {
  payload_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& EmitEventRequest::payload() const {
  // @@protoc_insertion_point(field_get:ric.logic.v3.EmitEventRequest.payload)
  return payload_.GetNoArena();
}
inline void EmitEventRequest::set_payload(const ::std::string& value) {
  
  payload_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:ric.logic.v3.EmitEventRequest.payload)
}
#if LANG_CXX11
inline void EmitEventRequest::set_payload(::std::string&& value) {
  
  payload_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:ric.logic.v3.EmitEventRequest.payload)
}
#endif
inline void EmitEventRequest::set_payload(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  payload_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:ric.logic.v3.EmitEventRequest.payload)
}
inline void EmitEventRequest::set_payload(const char* value, size_t size) {
  
  payload_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:ric.logic.v3.EmitEventRequest.payload)
}
inline ::std::string* EmitEventRequest::mutable_payload() {
  
  // @@protoc_insertion_point(field_mutable:ric.logic.v3.EmitEventRequest.payload)
  return payload_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* EmitEventRequest::release_payload() {
  // @@protoc_insertion_point(field_release:ric.logic.v3.EmitEventRequest.payload)
  
  return payload_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void EmitEventRequest::set_allocated_payload(::std::string* payload) {
  if (payload != nullptr) {
    
  } else {
    
  }
  payload_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), payload);
  // @@protoc_insertion_point(field_set_allocated:ric.logic.v3.EmitEventRequest.payload)
}

// -------------------------------------------------------------------

// EmitEventResponse

// -------------------------------------------------------------------

// WaitEventRequest

// .ric.logic.v3.UserContext ctx = 1;
inline bool WaitEventRequest::has_ctx() const {
  return this != internal_default_instance() && ctx_ != nullptr;
}
inline void WaitEventRequest::clear_ctx() {
  if (GetArenaNoVirtual() == nullptr && ctx_ != nullptr) {
    delete ctx_;
  }
  ctx_ = nullptr;
}
inline const ::ric::logic::v3::UserContext& WaitEventRequest::ctx() const {
  const ::ric::logic::v3::UserContext* p = ctx_;
  // @@protoc_insertion_point(field_get:ric.logic.v3.WaitEventRequest.ctx)
  return p != nullptr ? *p : *reinterpret_cast<const ::ric::logic::v3::UserContext*>(
      &::ric::logic::v3::_UserContext_default_instance_);
}
inline ::ric::logic::v3::UserContext* WaitEventRequest::release_ctx() {
  // @@protoc_insertion_point(field_release:ric.logic.v3.WaitEventRequest.ctx)
  
  ::ric::logic::v3::UserContext* temp = ctx_;
  ctx_ = nullptr;
  return temp;
}
inline ::ric::logic::v3::UserContext* WaitEventRequest::mutable_ctx() {
  
  if (ctx_ == nullptr) {
    auto* p = CreateMaybeMessage<::ric::logic::v3::UserContext>(GetArenaNoVirtual());
    ctx_ = p;
  }
  // @@protoc_insertion_point(field_mutable:ric.logic.v3.WaitEventRequest.ctx)
  return ctx_;
}
inline void WaitEventRequest::set_allocated_ctx(::ric::logic::v3::UserContext* ctx) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete ctx_;
  }
  if (ctx) {
    ::google::protobuf::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      ctx = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, ctx, submessage_arena);
    }
    
  } else {
    
  }
  ctx_ = ctx;
  // @@protoc_insertion_point(field_set_allocated:ric.logic.v3.WaitEventRequest.ctx)
}

// string object_id = 2;
inline void WaitEventRequest::clear_object_id() {
  object_id_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& WaitEventRequest::object_id() const {
  // @@protoc_insertion_point(field_get:ric.logic.v3.WaitEventRequest.object_id)
  return object_id_.GetNoArena();
}
inline void WaitEventRequest::set_object_id(const ::std::string& value) {
  
  object_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:ric.logic.v3.WaitEventRequest.object_id)
}
#if LANG_CXX11
inline void WaitEventRequest::set_object_id(::std::string&& value) {
  
  object_id_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:ric.logic.v3.WaitEventRequest.object_id)
}
#endif
inline void WaitEventRequest::set_object_id(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  object_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:ric.logic.v3.WaitEventRequest.object_id)
}
inline void WaitEventRequest::set_object_id(const char* value, size_t size) {
  
  object_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:ric.logic.v3.WaitEventRequest.object_id)
}
inline ::std::string* WaitEventRequest::mutable_object_id() {
  
  // @@protoc_insertion_point(field_mutable:ric.logic.v3.WaitEventRequest.object_id)
  return object_id_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* WaitEventRequest::release_object_id() {
  // @@protoc_insertion_point(field_release:ric.logic.v3.WaitEventRequest.object_id)
  
  return object_id_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void WaitEventRequest::set_allocated_object_id(::std::string* object_id) {
  if (object_id != nullptr) {
    
  } else {
    
  }
  object_id_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), object_id);
  // @@protoc_insertion_point(field_set_allocated:ric.logic.v3.WaitEventRequest.object_id)
}

// string automaton_id = 3;
inline void WaitEventRequest::clear_automaton_id() {
  automaton_id_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& WaitEventRequest::automaton_id() const {
  // @@protoc_insertion_point(field_get:ric.logic.v3.WaitEventRequest.automaton_id)
  return automaton_id_.GetNoArena();
}
inline void WaitEventRequest::set_automaton_id(const ::std::string& value) {
  
  automaton_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:ric.logic.v3.WaitEventRequest.automaton_id)
}
#if LANG_CXX11
inline void WaitEventRequest::set_automaton_id(::std::string&& value) {
  
  automaton_id_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:ric.logic.v3.WaitEventRequest.automaton_id)
}
#endif
inline void WaitEventRequest::set_automaton_id(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  automaton_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:ric.logic.v3.WaitEventRequest.automaton_id)
}
inline void WaitEventRequest::set_automaton_id(const char* value, size_t size) {
  
  automaton_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:ric.logic.v3.WaitEventRequest.automaton_id)
}
inline ::std::string* WaitEventRequest::mutable_automaton_id() {
  
  // @@protoc_insertion_point(field_mutable:ric.logic.v3.WaitEventRequest.automaton_id)
  return automaton_id_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* WaitEventRequest::release_automaton_id() {
  // @@protoc_insertion_point(field_release:ric.logic.v3.WaitEventRequest.automaton_id)
  
  return automaton_id_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void WaitEventRequest::set_allocated_automaton_id(::std::string* automaton_id) {
  if (automaton_id != nullptr) {
    
  } else {
    
  }
  automaton_id_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), automaton_id);
  // @@protoc_insertion_point(field_set_allocated:ric.logic.v3.WaitEventRequest.automaton_id)
}

// .ric.logic.v3.WaitCondition wait = 4;
inline bool WaitEventRequest::has_wait() const {
  return this != internal_default_instance() && wait_ != nullptr;
}
inline void WaitEventRequest::clear_wait() {
  if (GetArenaNoVirtual() == nullptr && wait_ != nullptr) {
    delete wait_;
  }
  wait_ = nullptr;
}
inline const ::ric::logic::v3::WaitCondition& WaitEventRequest::wait() const {
  const ::ric::logic::v3::WaitCondition* p = wait_;
  // @@protoc_insertion_point(field_get:ric.logic.v3.WaitEventRequest.wait)
  return p != nullptr ? *p : *reinterpret_cast<const ::ric::logic::v3::WaitCondition*>(
      &::ric::logic::v3::_WaitCondition_default_instance_);
}
inline ::ric::logic::v3::WaitCondition* WaitEventRequest::release_wait() {
  // @@protoc_insertion_point(field_release:ric.logic.v3.WaitEventRequest.wait)
  
  ::ric::logic::v3::WaitCondition* temp = wait_;
  wait_ = nullptr;
  return temp;
}
inline ::ric::logic::v3::WaitCondition* WaitEventRequest::mutable_wait() {
  
  if (wait_ == nullptr) {
    auto* p = CreateMaybeMessage<::ric::logic::v3::WaitCondition>(GetArenaNoVirtual());
    wait_ = p;
  }
  // @@protoc_insertion_point(field_mutable:ric.logic.v3.WaitEventRequest.wait)
  return wait_;
}
inline void WaitEventRequest::set_allocated_wait(::ric::logic::v3::WaitCondition* wait) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete wait_;
  }
  if (wait) {
    ::google::protobuf::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      wait = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, wait, submessage_arena);
    }
    
  } else {
    
  }
  wait_ = wait;
  // @@protoc_insertion_point(field_set_allocated:ric.logic.v3.WaitEventRequest.wait)
}

// -------------------------------------------------------------------

// WaitEventResponse

// -------------------------------------------------------------------

// GetRuntimeInfoRequest

// string object_id = 1;
inline void GetRuntimeInfoRequest::clear_object_id() {
  object_id_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& GetRuntimeInfoRequest::object_id() const {
  // @@protoc_insertion_point(field_get:ric.logic.v3.GetRuntimeInfoRequest.object_id)
  return object_id_.GetNoArena();
}
inline void GetRuntimeInfoRequest::set_object_id(const ::std::string& value) {
  
  object_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:ric.logic.v3.GetRuntimeInfoRequest.object_id)
}
#if LANG_CXX11
inline void GetRuntimeInfoRequest::set_object_id(::std::string&& value) {
  
  object_id_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:ric.logic.v3.GetRuntimeInfoRequest.object_id)
}
#endif
inline void GetRuntimeInfoRequest::set_object_id(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  object_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:ric.logic.v3.GetRuntimeInfoRequest.object_id)
}
inline void GetRuntimeInfoRequest::set_object_id(const char* value, size_t size) {
  
  object_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:ric.logic.v3.GetRuntimeInfoRequest.object_id)
}
inline ::std::string* GetRuntimeInfoRequest::mutable_object_id() {
  
  // @@protoc_insertion_point(field_mutable:ric.logic.v3.GetRuntimeInfoRequest.object_id)
  return object_id_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* GetRuntimeInfoRequest::release_object_id() {
  // @@protoc_insertion_point(field_release:ric.logic.v3.GetRuntimeInfoRequest.object_id)
  
  return object_id_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void GetRuntimeInfoRequest::set_allocated_object_id(::std::string* object_id) {
  if (object_id != nullptr) {
    
  } else {
    
  }
  object_id_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), object_id);
  // @@protoc_insertion_point(field_set_allocated:ric.logic.v3.GetRuntimeInfoRequest.object_id)
}

// string automaton_id = 2;
inline void GetRuntimeInfoRequest::clear_automaton_id() {
  automaton_id_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& GetRuntimeInfoRequest::automaton_id() const {
  // @@protoc_insertion_point(field_get:ric.logic.v3.GetRuntimeInfoRequest.automaton_id)
  return automaton_id_.GetNoArena();
}
inline void GetRuntimeInfoRequest::set_automaton_id(const ::std::string& value) {
  
  automaton_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:ric.logic.v3.GetRuntimeInfoRequest.automaton_id)
}
#if LANG_CXX11
inline void GetRuntimeInfoRequest::set_automaton_id(::std::string&& value) {
  
  automaton_id_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:ric.logic.v3.GetRuntimeInfoRequest.automaton_id)
}
#endif
inline void GetRuntimeInfoRequest::set_automaton_id(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  automaton_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:ric.logic.v3.GetRuntimeInfoRequest.automaton_id)
}
inline void GetRuntimeInfoRequest::set_automaton_id(const char* value, size_t size) {
  
  automaton_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:ric.logic.v3.GetRuntimeInfoRequest.automaton_id)
}
inline ::std::string* GetRuntimeInfoRequest::mutable_automaton_id() {
  
  // @@protoc_insertion_point(field_mutable:ric.logic.v3.GetRuntimeInfoRequest.automaton_id)
  return automaton_id_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* GetRuntimeInfoRequest::release_automaton_id() {
  // @@protoc_insertion_point(field_release:ric.logic.v3.GetRuntimeInfoRequest.automaton_id)
  
  return automaton_id_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void GetRuntimeInfoRequest::set_allocated_automaton_id(::std::string* automaton_id) {
  if (automaton_id != nullptr) {
    
  } else {
    
  }
  automaton_id_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), automaton_id);
  // @@protoc_insertion_point(field_set_allocated:ric.logic.v3.GetRuntimeInfoRequest.automaton_id)
}

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// UpdateAutomatonVarsRequest

// .ric.logic.v3.UserContext ctx = 1;
inline bool UpdateAutomatonVarsRequest::has_ctx() const {
  return this != internal_default_instance() && ctx_ != nullptr;
}
inline void UpdateAutomatonVarsRequest::clear_ctx() {
  if (GetArenaNoVirtual() == nullptr && ctx_ != nullptr) {
    delete ctx_;
  }
  ctx_ = nullptr;
}
inline const ::ric::logic::v3::UserContext& UpdateAutomatonVarsRequest::ctx() const {
  const ::ric::logic::v3::UserContext* p = ctx_;
  // @@protoc_insertion_point(field_get:ric.logic.v3.UpdateAutomatonVarsRequest.ctx)
  return p != nullptr ? *p : *reinterpret_cast<const ::ric::logic::v3::UserContext*>(
      &::ric::logic::v3::_UserContext_default_instance_);
}
inline ::ric::logic::v3::UserContext* UpdateAutomatonVarsRequest::release_ctx() {
  // @@protoc_insertion_point(field_release:ric.logic.v3.UpdateAutomatonVarsRequest.ctx)
  
  ::ric::logic::v3::UserContext* temp = ctx_;
  ctx_ = nullptr;
  return temp;
}
inline ::ric::logic::v3::UserContext* UpdateAutomatonVarsRequest::mutable_ctx() {
  
  if (ctx_ == nullptr) {
    auto* p = CreateMaybeMessage<::ric::logic::v3::UserContext>(GetArenaNoVirtual());
    ctx_ = p;
  }
  // @@protoc_insertion_point(field_mutable:ric.logic.v3.UpdateAutomatonVarsRequest.ctx)
  return ctx_;
}
inline void UpdateAutomatonVarsRequest::set_allocated_ctx(::ric::logic::v3::UserContext* ctx) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete ctx_;
  }
  if (ctx) {
    ::google::protobuf::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      ctx = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, ctx, submessage_arena);
    }
    
  } else {
    
  }
  ctx_ = ctx;
  // @@protoc_insertion_point(field_set_allocated:ric.logic.v3.UpdateAutomatonVarsRequest.ctx)
}

// string object_id = 2;
inline void UpdateAutomatonVarsRequest::clear_object_id() {
  object_id_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& UpdateAutomatonVarsRequest::object_id() const {
  // @@protoc_insertion_point(field_get:ric.logic.v3.UpdateAutomatonVarsRequest.object_id)
  return object_id_.GetNoArena();
}
inline void UpdateAutomatonVarsRequest::set_object_id(const ::std::string& value) {
  
  object_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:ric.logic.v3.UpdateAutomatonVarsRequest.object_id)
}
#if LANG_CXX11
inline void UpdateAutomatonVarsRequest::set_object_id(::std::string&& value) {
  
  object_id_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:ric.logic.v3.UpdateAutomatonVarsRequest.object_id)
}
#endif
inline void UpdateAutomatonVarsRequest::set_object_id(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  object_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:ric.logic.v3.UpdateAutomatonVarsRequest.object_id)
}
inline void UpdateAutomatonVarsRequest::set_object_id(const char* value, size_t size) {
  
  object_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:ric.logic.v3.UpdateAutomatonVarsRequest.object_id)
}
inline ::std::string* UpdateAutomatonVarsRequest::mutable_object_id() {
  
  // @@protoc_insertion_point(field_mutable:ric.logic.v3.UpdateAutomatonVarsRequest.object_id)
  return object_id_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* UpdateAutomatonVarsRequest::release_object_id() {
  // @@protoc_insertion_point(field_release:ric.logic.v3.UpdateAutomatonVarsRequest.object_id)
  
  return object_id_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void UpdateAutomatonVarsRequest::set_allocated_object_id(::std::string* object_id) {
  if (object_id != nullptr) {
    
  } else {
    
  }
  object_id_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), object_id);
  // @@protoc_insertion_point(field_set_allocated:ric.logic.v3.UpdateAutomatonVarsRequest.object_id)
}

// string automaton_id = 3;
inline void UpdateAutomatonVarsRequest::clear_automaton_id() {
  automaton_id_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& UpdateAutomatonVarsRequest::automaton_id() const {
  // @@protoc_insertion_point(field_get:ric.logic.v3.UpdateAutomatonVarsRequest.automaton_id)
  return automaton_id_.GetNoArena();
}
inline void UpdateAutomatonVarsRequest::set_automaton_id(const ::std::string& value) {
  
  automaton_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:ric.logic.v3.UpdateAutomatonVarsRequest.automaton_id)
}
#if LANG_CXX11
inline void UpdateAutomatonVarsRequest::set_automaton_id(::std::string&& value) {
  
  automaton_id_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:ric.logic.v3.UpdateAutomatonVarsRequest.automaton_id)
}
#endif
inline void UpdateAutomatonVarsRequest::set_automaton_id(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  automaton_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:ric.logic.v3.UpdateAutomatonVarsRequest.automaton_id)
}
inline void UpdateAutomatonVarsRequest::set_automaton_id(const char* value, size_t size) {
  
  automaton_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:ric.logic.v3.UpdateAutomatonVarsRequest.automaton_id)
}
inline ::std::string* UpdateAutomatonVarsRequest::mutable_automaton_id() {
  
  // @@protoc_insertion_point(field_mutable:ric.logic.v3.UpdateAutomatonVarsRequest.automaton_id)
  return automaton_id_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* UpdateAutomatonVarsRequest::release_automaton_id() {
  // @@protoc_insertion_point(field_release:ric.logic.v3.UpdateAutomatonVarsRequest.automaton_id)
  
  return automaton_id_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void UpdateAutomatonVarsRequest::set_allocated_automaton_id(::std::string* automaton_id) {
  if (automaton_id != nullptr) {
    
  } else {
    
  }
  automaton_id_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), automaton_id);
  // @@protoc_insertion_point(field_set_allocated:ric.logic.v3.UpdateAutomatonVarsRequest.automaton_id)
}

// map<string, .ric.logic.v3.AutomatonVarValue> vars = 4;
inline int UpdateAutomatonVarsRequest::vars_size() const {
  return vars_.size();
}
inline void UpdateAutomatonVarsRequest::clear_vars() {
  vars_.Clear();
}
inline const ::google::protobuf::Map< ::std::string, ::ric::logic::v3::AutomatonVarValue >&
UpdateAutomatonVarsRequest::vars() const {
  // @@protoc_insertion_point(field_map:ric.logic.v3.UpdateAutomatonVarsRequest.vars)
  return vars_.GetMap();
}
inline ::google::protobuf::Map< ::std::string, ::ric::logic::v3::AutomatonVarValue >*
UpdateAutomatonVarsRequest::mutable_vars() {
  // @@protoc_insertion_point(field_mutable_map:ric.logic.v3.UpdateAutomatonVarsRequest.vars)
  return vars_.MutableMap();
}

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// UpdateAutomatonVarsResponse

// map<string, .ric.logic.v3.AutomatonVarValue> vars = 1;
inline int UpdateAutomatonVarsResponse::vars_size() const {
  return vars_.size();
}
inline void UpdateAutomatonVarsResponse::clear_vars() {
  vars_.Clear();
}
inline const ::google::protobuf::Map< ::std::string, ::ric::logic::v3::AutomatonVarValue >&
UpdateAutomatonVarsResponse::vars() const {
  // @@protoc_insertion_point(field_map:ric.logic.v3.UpdateAutomatonVarsResponse.vars)
  return vars_.GetMap();
}
inline ::google::protobuf::Map< ::std::string, ::ric::logic::v3::AutomatonVarValue >*
UpdateAutomatonVarsResponse::mutable_vars() {
  // @@protoc_insertion_point(field_mutable_map:ric.logic.v3.UpdateAutomatonVarsResponse.vars)
  return vars_.MutableMap();
}

// -------------------------------------------------------------------

// TouchEventSubscriptionRequest

// .ric.logic.v3.UserContext ctx = 1;
inline bool TouchEventSubscriptionRequest::has_ctx() const {
  return this != internal_default_instance() && ctx_ != nullptr;
}
inline void TouchEventSubscriptionRequest::clear_ctx() {
  if (GetArenaNoVirtual() == nullptr && ctx_ != nullptr) {
    delete ctx_;
  }
  ctx_ = nullptr;
}
inline const ::ric::logic::v3::UserContext& TouchEventSubscriptionRequest::ctx() const {
  const ::ric::logic::v3::UserContext* p = ctx_;
  // @@protoc_insertion_point(field_get:ric.logic.v3.TouchEventSubscriptionRequest.ctx)
  return p != nullptr ? *p : *reinterpret_cast<const ::ric::logic::v3::UserContext*>(
      &::ric::logic::v3::_UserContext_default_instance_);
}
inline ::ric::logic::v3::UserContext* TouchEventSubscriptionRequest::release_ctx() {
  // @@protoc_insertion_point(field_release:ric.logic.v3.TouchEventSubscriptionRequest.ctx)
  
  ::ric::logic::v3::UserContext* temp = ctx_;
  ctx_ = nullptr;
  return temp;
}
inline ::ric::logic::v3::UserContext* TouchEventSubscriptionRequest::mutable_ctx() {
  
  if (ctx_ == nullptr) {
    auto* p = CreateMaybeMessage<::ric::logic::v3::UserContext>(GetArenaNoVirtual());
    ctx_ = p;
  }
  // @@protoc_insertion_point(field_mutable:ric.logic.v3.TouchEventSubscriptionRequest.ctx)
  return ctx_;
}
inline void TouchEventSubscriptionRequest::set_allocated_ctx(::ric::logic::v3::UserContext* ctx) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete ctx_;
  }
  if (ctx) {
    ::google::protobuf::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      ctx = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, ctx, submessage_arena);
    }
    
  } else {
    
  }
  ctx_ = ctx;
  // @@protoc_insertion_point(field_set_allocated:ric.logic.v3.TouchEventSubscriptionRequest.ctx)
}

// string object_id = 2;
inline void TouchEventSubscriptionRequest::clear_object_id() {
  object_id_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& TouchEventSubscriptionRequest::object_id() const {
  // @@protoc_insertion_point(field_get:ric.logic.v3.TouchEventSubscriptionRequest.object_id)
  return object_id_.GetNoArena();
}
inline void TouchEventSubscriptionRequest::set_object_id(const ::std::string& value) {
  
  object_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:ric.logic.v3.TouchEventSubscriptionRequest.object_id)
}
#if LANG_CXX11
inline void TouchEventSubscriptionRequest::set_object_id(::std::string&& value) {
  
  object_id_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:ric.logic.v3.TouchEventSubscriptionRequest.object_id)
}
#endif
inline void TouchEventSubscriptionRequest::set_object_id(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  object_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:ric.logic.v3.TouchEventSubscriptionRequest.object_id)
}
inline void TouchEventSubscriptionRequest::set_object_id(const char* value, size_t size) {
  
  object_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:ric.logic.v3.TouchEventSubscriptionRequest.object_id)
}
inline ::std::string* TouchEventSubscriptionRequest::mutable_object_id() {
  
  // @@protoc_insertion_point(field_mutable:ric.logic.v3.TouchEventSubscriptionRequest.object_id)
  return object_id_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* TouchEventSubscriptionRequest::release_object_id() {
  // @@protoc_insertion_point(field_release:ric.logic.v3.TouchEventSubscriptionRequest.object_id)
  
  return object_id_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void TouchEventSubscriptionRequest::set_allocated_object_id(::std::string* object_id) {
  if (object_id != nullptr) {
    
  } else {
    
  }
  object_id_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), object_id);
  // @@protoc_insertion_point(field_set_allocated:ric.logic.v3.TouchEventSubscriptionRequest.object_id)
}

// string automaton_id = 3;
inline void TouchEventSubscriptionRequest::clear_automaton_id() {
  automaton_id_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& TouchEventSubscriptionRequest::automaton_id() const {
  // @@protoc_insertion_point(field_get:ric.logic.v3.TouchEventSubscriptionRequest.automaton_id)
  return automaton_id_.GetNoArena();
}
inline void TouchEventSubscriptionRequest::set_automaton_id(const ::std::string& value) {
  
  automaton_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:ric.logic.v3.TouchEventSubscriptionRequest.automaton_id)
}
#if LANG_CXX11
inline void TouchEventSubscriptionRequest::set_automaton_id(::std::string&& value) {
  
  automaton_id_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:ric.logic.v3.TouchEventSubscriptionRequest.automaton_id)
}
#endif
inline void TouchEventSubscriptionRequest::set_automaton_id(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  automaton_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:ric.logic.v3.TouchEventSubscriptionRequest.automaton_id)
}
inline void TouchEventSubscriptionRequest::set_automaton_id(const char* value, size_t size) {
  
  automaton_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:ric.logic.v3.TouchEventSubscriptionRequest.automaton_id)
}
inline ::std::string* TouchEventSubscriptionRequest::mutable_automaton_id() {
  
  // @@protoc_insertion_point(field_mutable:ric.logic.v3.TouchEventSubscriptionRequest.automaton_id)
  return automaton_id_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* TouchEventSubscriptionRequest::release_automaton_id() {
  // @@protoc_insertion_point(field_release:ric.logic.v3.TouchEventSubscriptionRequest.automaton_id)
  
  return automaton_id_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void TouchEventSubscriptionRequest::set_allocated_automaton_id(::std::string* automaton_id) {
  if (automaton_id != nullptr) {
    
  } else {
    
  }
  automaton_id_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), automaton_id);
  // @@protoc_insertion_point(field_set_allocated:ric.logic.v3.TouchEventSubscriptionRequest.automaton_id)
}

// int32 ttl = 4;
inline void TouchEventSubscriptionRequest::clear_ttl() {
  ttl_ = 0;
}
inline ::google::protobuf::int32 TouchEventSubscriptionRequest::ttl() const {
  // @@protoc_insertion_point(field_get:ric.logic.v3.TouchEventSubscriptionRequest.ttl)
  return ttl_;
}
inline void TouchEventSubscriptionRequest::set_ttl(::google::protobuf::int32 value) {
  
  ttl_ = value;
  // @@protoc_insertion_point(field_set:ric.logic.v3.TouchEventSubscriptionRequest.ttl)
}

// -------------------------------------------------------------------

// TouchEventSubscriptionResponse

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace v3
}  // namespace logic
}  // namespace ric

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // PROTOBUF_INCLUDED_ric_2dlogic_2dv3_2friclogicv3_2eproto
