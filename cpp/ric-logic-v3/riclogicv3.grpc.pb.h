// Generated by the gRPC C++ plugin.
// If you make any local change, they will be lost.
// source: ric-logic-v3/riclogicv3.proto
#ifndef GRPC_ric_2dlogic_2dv3_2friclogicv3_2eproto__INCLUDED
#define GRPC_ric_2dlogic_2dv3_2friclogicv3_2eproto__INCLUDED

#include "ric-logic-v3/riclogicv3.pb.h"

#include <functional>
#include <grpcpp/impl/codegen/async_generic_service.h>
#include <grpcpp/impl/codegen/async_stream.h>
#include <grpcpp/impl/codegen/async_unary_call.h>
#include <grpcpp/impl/codegen/client_callback.h>
#include <grpcpp/impl/codegen/method_handler_impl.h>
#include <grpcpp/impl/codegen/proto_utils.h>
#include <grpcpp/impl/codegen/rpc_method.h>
#include <grpcpp/impl/codegen/server_callback.h>
#include <grpcpp/impl/codegen/service_type.h>
#include <grpcpp/impl/codegen/status.h>
#include <grpcpp/impl/codegen/stub_options.h>
#include <grpcpp/impl/codegen/sync_stream.h>

namespace grpc {
class CompletionQueue;
class Channel;
class ServerCompletionQueue;
class ServerContext;
}  // namespace grpc

namespace ric {
namespace logic {
namespace v3 {

class RicLogicV3 final {
 public:
  static constexpr char const* service_full_name() {
    return "ric.logic.v3.RicLogicV3";
  }
  class StubInterface {
   public:
    virtual ~StubInterface() {}
    virtual ::grpc::Status GetInstanceInfo(::grpc::ClientContext* context, const ::ric::logic::v3::GetInstanceInfoRequest& request, ::ric::logic::v3::GetInstanceInfoResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::ric::logic::v3::GetInstanceInfoResponse>> AsyncGetInstanceInfo(::grpc::ClientContext* context, const ::ric::logic::v3::GetInstanceInfoRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::ric::logic::v3::GetInstanceInfoResponse>>(AsyncGetInstanceInfoRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::ric::logic::v3::GetInstanceInfoResponse>> PrepareAsyncGetInstanceInfo(::grpc::ClientContext* context, const ::ric::logic::v3::GetInstanceInfoRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::ric::logic::v3::GetInstanceInfoResponse>>(PrepareAsyncGetInstanceInfoRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientReaderInterface< ::ric::logic::v3::AutomatonInfo>> GetAutomatons(::grpc::ClientContext* context, const ::ric::logic::v3::GetAutomatonsRequest& request) {
      return std::unique_ptr< ::grpc::ClientReaderInterface< ::ric::logic::v3::AutomatonInfo>>(GetAutomatonsRaw(context, request));
    }
    std::unique_ptr< ::grpc::ClientAsyncReaderInterface< ::ric::logic::v3::AutomatonInfo>> AsyncGetAutomatons(::grpc::ClientContext* context, const ::ric::logic::v3::GetAutomatonsRequest& request, ::grpc::CompletionQueue* cq, void* tag) {
      return std::unique_ptr< ::grpc::ClientAsyncReaderInterface< ::ric::logic::v3::AutomatonInfo>>(AsyncGetAutomatonsRaw(context, request, cq, tag));
    }
    std::unique_ptr< ::grpc::ClientAsyncReaderInterface< ::ric::logic::v3::AutomatonInfo>> PrepareAsyncGetAutomatons(::grpc::ClientContext* context, const ::ric::logic::v3::GetAutomatonsRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncReaderInterface< ::ric::logic::v3::AutomatonInfo>>(PrepareAsyncGetAutomatonsRaw(context, request, cq));
    }
    virtual ::grpc::Status StartAutomaton(::grpc::ClientContext* context, const ::ric::logic::v3::StartAutomatonRequest& request, ::ric::logic::v3::StartAutomatonResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::ric::logic::v3::StartAutomatonResponse>> AsyncStartAutomaton(::grpc::ClientContext* context, const ::ric::logic::v3::StartAutomatonRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::ric::logic::v3::StartAutomatonResponse>>(AsyncStartAutomatonRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::ric::logic::v3::StartAutomatonResponse>> PrepareAsyncStartAutomaton(::grpc::ClientContext* context, const ::ric::logic::v3::StartAutomatonRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::ric::logic::v3::StartAutomatonResponse>>(PrepareAsyncStartAutomatonRaw(context, request, cq));
    }
    virtual ::grpc::Status StartAutomatonMulti(::grpc::ClientContext* context, const ::ric::logic::v3::StartAutomatonMultiRequest& request, ::ric::logic::v3::StartAutomatonResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::ric::logic::v3::StartAutomatonResponse>> AsyncStartAutomatonMulti(::grpc::ClientContext* context, const ::ric::logic::v3::StartAutomatonMultiRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::ric::logic::v3::StartAutomatonResponse>>(AsyncStartAutomatonMultiRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::ric::logic::v3::StartAutomatonResponse>> PrepareAsyncStartAutomatonMulti(::grpc::ClientContext* context, const ::ric::logic::v3::StartAutomatonMultiRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::ric::logic::v3::StartAutomatonResponse>>(PrepareAsyncStartAutomatonMultiRaw(context, request, cq));
    }
    virtual ::grpc::Status StopAutomaton(::grpc::ClientContext* context, const ::ric::logic::v3::StopAutomatonRequest& request, ::ric::logic::v3::StopAutomatonResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::ric::logic::v3::StopAutomatonResponse>> AsyncStopAutomaton(::grpc::ClientContext* context, const ::ric::logic::v3::StopAutomatonRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::ric::logic::v3::StopAutomatonResponse>>(AsyncStopAutomatonRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::ric::logic::v3::StopAutomatonResponse>> PrepareAsyncStopAutomaton(::grpc::ClientContext* context, const ::ric::logic::v3::StopAutomatonRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::ric::logic::v3::StopAutomatonResponse>>(PrepareAsyncStopAutomatonRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientReaderInterface< ::ric::logic::v3::AutomatonInfo>> RunAutomaton(::grpc::ClientContext* context, const ::ric::logic::v3::RunAutomatonRequest& request) {
      return std::unique_ptr< ::grpc::ClientReaderInterface< ::ric::logic::v3::AutomatonInfo>>(RunAutomatonRaw(context, request));
    }
    std::unique_ptr< ::grpc::ClientAsyncReaderInterface< ::ric::logic::v3::AutomatonInfo>> AsyncRunAutomaton(::grpc::ClientContext* context, const ::ric::logic::v3::RunAutomatonRequest& request, ::grpc::CompletionQueue* cq, void* tag) {
      return std::unique_ptr< ::grpc::ClientAsyncReaderInterface< ::ric::logic::v3::AutomatonInfo>>(AsyncRunAutomatonRaw(context, request, cq, tag));
    }
    std::unique_ptr< ::grpc::ClientAsyncReaderInterface< ::ric::logic::v3::AutomatonInfo>> PrepareAsyncRunAutomaton(::grpc::ClientContext* context, const ::ric::logic::v3::RunAutomatonRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncReaderInterface< ::ric::logic::v3::AutomatonInfo>>(PrepareAsyncRunAutomatonRaw(context, request, cq));
    }
    virtual ::grpc::Status EmitEvent(::grpc::ClientContext* context, const ::ric::logic::v3::EmitEventRequest& request, ::ric::logic::v3::EmitEventResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::ric::logic::v3::EmitEventResponse>> AsyncEmitEvent(::grpc::ClientContext* context, const ::ric::logic::v3::EmitEventRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::ric::logic::v3::EmitEventResponse>>(AsyncEmitEventRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::ric::logic::v3::EmitEventResponse>> PrepareAsyncEmitEvent(::grpc::ClientContext* context, const ::ric::logic::v3::EmitEventRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::ric::logic::v3::EmitEventResponse>>(PrepareAsyncEmitEventRaw(context, request, cq));
    }
    virtual ::grpc::Status WaitEvent(::grpc::ClientContext* context, const ::ric::logic::v3::WaitEventRequest& request, ::ric::logic::v3::WaitEventResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::ric::logic::v3::WaitEventResponse>> AsyncWaitEvent(::grpc::ClientContext* context, const ::ric::logic::v3::WaitEventRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::ric::logic::v3::WaitEventResponse>>(AsyncWaitEventRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::ric::logic::v3::WaitEventResponse>> PrepareAsyncWaitEvent(::grpc::ClientContext* context, const ::ric::logic::v3::WaitEventRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::ric::logic::v3::WaitEventResponse>>(PrepareAsyncWaitEventRaw(context, request, cq));
    }
    virtual ::grpc::Status UpdateAutomatonVars(::grpc::ClientContext* context, const ::ric::logic::v3::UpdateAutomatonVarsRequest& request, ::ric::logic::v3::UpdateAutomatonVarsResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::ric::logic::v3::UpdateAutomatonVarsResponse>> AsyncUpdateAutomatonVars(::grpc::ClientContext* context, const ::ric::logic::v3::UpdateAutomatonVarsRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::ric::logic::v3::UpdateAutomatonVarsResponse>>(AsyncUpdateAutomatonVarsRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::ric::logic::v3::UpdateAutomatonVarsResponse>> PrepareAsyncUpdateAutomatonVars(::grpc::ClientContext* context, const ::ric::logic::v3::UpdateAutomatonVarsRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::ric::logic::v3::UpdateAutomatonVarsResponse>>(PrepareAsyncUpdateAutomatonVarsRaw(context, request, cq));
    }
    virtual ::grpc::Status TouchEventSubscription(::grpc::ClientContext* context, const ::ric::logic::v3::TouchEventSubscriptionRequest& request, ::ric::logic::v3::TouchEventSubscriptionResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::ric::logic::v3::TouchEventSubscriptionResponse>> AsyncTouchEventSubscription(::grpc::ClientContext* context, const ::ric::logic::v3::TouchEventSubscriptionRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::ric::logic::v3::TouchEventSubscriptionResponse>>(AsyncTouchEventSubscriptionRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::ric::logic::v3::TouchEventSubscriptionResponse>> PrepareAsyncTouchEventSubscription(::grpc::ClientContext* context, const ::ric::logic::v3::TouchEventSubscriptionRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::ric::logic::v3::TouchEventSubscriptionResponse>>(PrepareAsyncTouchEventSubscriptionRaw(context, request, cq));
    }
    class experimental_async_interface {
     public:
      virtual ~experimental_async_interface() {}
      virtual void GetInstanceInfo(::grpc::ClientContext* context, const ::ric::logic::v3::GetInstanceInfoRequest* request, ::ric::logic::v3::GetInstanceInfoResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void GetInstanceInfo(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::ric::logic::v3::GetInstanceInfoResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void GetAutomatons(::grpc::ClientContext* context, ::ric::logic::v3::GetAutomatonsRequest* request, ::grpc::experimental::ClientReadReactor< ::ric::logic::v3::AutomatonInfo>* reactor) = 0;
      virtual void StartAutomaton(::grpc::ClientContext* context, const ::ric::logic::v3::StartAutomatonRequest* request, ::ric::logic::v3::StartAutomatonResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void StartAutomaton(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::ric::logic::v3::StartAutomatonResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void StartAutomatonMulti(::grpc::ClientContext* context, const ::ric::logic::v3::StartAutomatonMultiRequest* request, ::ric::logic::v3::StartAutomatonResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void StartAutomatonMulti(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::ric::logic::v3::StartAutomatonResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void StopAutomaton(::grpc::ClientContext* context, const ::ric::logic::v3::StopAutomatonRequest* request, ::ric::logic::v3::StopAutomatonResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void StopAutomaton(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::ric::logic::v3::StopAutomatonResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void RunAutomaton(::grpc::ClientContext* context, ::ric::logic::v3::RunAutomatonRequest* request, ::grpc::experimental::ClientReadReactor< ::ric::logic::v3::AutomatonInfo>* reactor) = 0;
      virtual void EmitEvent(::grpc::ClientContext* context, const ::ric::logic::v3::EmitEventRequest* request, ::ric::logic::v3::EmitEventResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void EmitEvent(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::ric::logic::v3::EmitEventResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void WaitEvent(::grpc::ClientContext* context, const ::ric::logic::v3::WaitEventRequest* request, ::ric::logic::v3::WaitEventResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void WaitEvent(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::ric::logic::v3::WaitEventResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void UpdateAutomatonVars(::grpc::ClientContext* context, const ::ric::logic::v3::UpdateAutomatonVarsRequest* request, ::ric::logic::v3::UpdateAutomatonVarsResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void UpdateAutomatonVars(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::ric::logic::v3::UpdateAutomatonVarsResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void TouchEventSubscription(::grpc::ClientContext* context, const ::ric::logic::v3::TouchEventSubscriptionRequest* request, ::ric::logic::v3::TouchEventSubscriptionResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void TouchEventSubscription(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::ric::logic::v3::TouchEventSubscriptionResponse* response, std::function<void(::grpc::Status)>) = 0;
    };
    virtual class experimental_async_interface* experimental_async() { return nullptr; }
  private:
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::ric::logic::v3::GetInstanceInfoResponse>* AsyncGetInstanceInfoRaw(::grpc::ClientContext* context, const ::ric::logic::v3::GetInstanceInfoRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::ric::logic::v3::GetInstanceInfoResponse>* PrepareAsyncGetInstanceInfoRaw(::grpc::ClientContext* context, const ::ric::logic::v3::GetInstanceInfoRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientReaderInterface< ::ric::logic::v3::AutomatonInfo>* GetAutomatonsRaw(::grpc::ClientContext* context, const ::ric::logic::v3::GetAutomatonsRequest& request) = 0;
    virtual ::grpc::ClientAsyncReaderInterface< ::ric::logic::v3::AutomatonInfo>* AsyncGetAutomatonsRaw(::grpc::ClientContext* context, const ::ric::logic::v3::GetAutomatonsRequest& request, ::grpc::CompletionQueue* cq, void* tag) = 0;
    virtual ::grpc::ClientAsyncReaderInterface< ::ric::logic::v3::AutomatonInfo>* PrepareAsyncGetAutomatonsRaw(::grpc::ClientContext* context, const ::ric::logic::v3::GetAutomatonsRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::ric::logic::v3::StartAutomatonResponse>* AsyncStartAutomatonRaw(::grpc::ClientContext* context, const ::ric::logic::v3::StartAutomatonRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::ric::logic::v3::StartAutomatonResponse>* PrepareAsyncStartAutomatonRaw(::grpc::ClientContext* context, const ::ric::logic::v3::StartAutomatonRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::ric::logic::v3::StartAutomatonResponse>* AsyncStartAutomatonMultiRaw(::grpc::ClientContext* context, const ::ric::logic::v3::StartAutomatonMultiRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::ric::logic::v3::StartAutomatonResponse>* PrepareAsyncStartAutomatonMultiRaw(::grpc::ClientContext* context, const ::ric::logic::v3::StartAutomatonMultiRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::ric::logic::v3::StopAutomatonResponse>* AsyncStopAutomatonRaw(::grpc::ClientContext* context, const ::ric::logic::v3::StopAutomatonRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::ric::logic::v3::StopAutomatonResponse>* PrepareAsyncStopAutomatonRaw(::grpc::ClientContext* context, const ::ric::logic::v3::StopAutomatonRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientReaderInterface< ::ric::logic::v3::AutomatonInfo>* RunAutomatonRaw(::grpc::ClientContext* context, const ::ric::logic::v3::RunAutomatonRequest& request) = 0;
    virtual ::grpc::ClientAsyncReaderInterface< ::ric::logic::v3::AutomatonInfo>* AsyncRunAutomatonRaw(::grpc::ClientContext* context, const ::ric::logic::v3::RunAutomatonRequest& request, ::grpc::CompletionQueue* cq, void* tag) = 0;
    virtual ::grpc::ClientAsyncReaderInterface< ::ric::logic::v3::AutomatonInfo>* PrepareAsyncRunAutomatonRaw(::grpc::ClientContext* context, const ::ric::logic::v3::RunAutomatonRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::ric::logic::v3::EmitEventResponse>* AsyncEmitEventRaw(::grpc::ClientContext* context, const ::ric::logic::v3::EmitEventRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::ric::logic::v3::EmitEventResponse>* PrepareAsyncEmitEventRaw(::grpc::ClientContext* context, const ::ric::logic::v3::EmitEventRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::ric::logic::v3::WaitEventResponse>* AsyncWaitEventRaw(::grpc::ClientContext* context, const ::ric::logic::v3::WaitEventRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::ric::logic::v3::WaitEventResponse>* PrepareAsyncWaitEventRaw(::grpc::ClientContext* context, const ::ric::logic::v3::WaitEventRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::ric::logic::v3::UpdateAutomatonVarsResponse>* AsyncUpdateAutomatonVarsRaw(::grpc::ClientContext* context, const ::ric::logic::v3::UpdateAutomatonVarsRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::ric::logic::v3::UpdateAutomatonVarsResponse>* PrepareAsyncUpdateAutomatonVarsRaw(::grpc::ClientContext* context, const ::ric::logic::v3::UpdateAutomatonVarsRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::ric::logic::v3::TouchEventSubscriptionResponse>* AsyncTouchEventSubscriptionRaw(::grpc::ClientContext* context, const ::ric::logic::v3::TouchEventSubscriptionRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::ric::logic::v3::TouchEventSubscriptionResponse>* PrepareAsyncTouchEventSubscriptionRaw(::grpc::ClientContext* context, const ::ric::logic::v3::TouchEventSubscriptionRequest& request, ::grpc::CompletionQueue* cq) = 0;
  };
  class Stub final : public StubInterface {
   public:
    Stub(const std::shared_ptr< ::grpc::ChannelInterface>& channel);
    ::grpc::Status GetInstanceInfo(::grpc::ClientContext* context, const ::ric::logic::v3::GetInstanceInfoRequest& request, ::ric::logic::v3::GetInstanceInfoResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::ric::logic::v3::GetInstanceInfoResponse>> AsyncGetInstanceInfo(::grpc::ClientContext* context, const ::ric::logic::v3::GetInstanceInfoRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::ric::logic::v3::GetInstanceInfoResponse>>(AsyncGetInstanceInfoRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::ric::logic::v3::GetInstanceInfoResponse>> PrepareAsyncGetInstanceInfo(::grpc::ClientContext* context, const ::ric::logic::v3::GetInstanceInfoRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::ric::logic::v3::GetInstanceInfoResponse>>(PrepareAsyncGetInstanceInfoRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientReader< ::ric::logic::v3::AutomatonInfo>> GetAutomatons(::grpc::ClientContext* context, const ::ric::logic::v3::GetAutomatonsRequest& request) {
      return std::unique_ptr< ::grpc::ClientReader< ::ric::logic::v3::AutomatonInfo>>(GetAutomatonsRaw(context, request));
    }
    std::unique_ptr< ::grpc::ClientAsyncReader< ::ric::logic::v3::AutomatonInfo>> AsyncGetAutomatons(::grpc::ClientContext* context, const ::ric::logic::v3::GetAutomatonsRequest& request, ::grpc::CompletionQueue* cq, void* tag) {
      return std::unique_ptr< ::grpc::ClientAsyncReader< ::ric::logic::v3::AutomatonInfo>>(AsyncGetAutomatonsRaw(context, request, cq, tag));
    }
    std::unique_ptr< ::grpc::ClientAsyncReader< ::ric::logic::v3::AutomatonInfo>> PrepareAsyncGetAutomatons(::grpc::ClientContext* context, const ::ric::logic::v3::GetAutomatonsRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncReader< ::ric::logic::v3::AutomatonInfo>>(PrepareAsyncGetAutomatonsRaw(context, request, cq));
    }
    ::grpc::Status StartAutomaton(::grpc::ClientContext* context, const ::ric::logic::v3::StartAutomatonRequest& request, ::ric::logic::v3::StartAutomatonResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::ric::logic::v3::StartAutomatonResponse>> AsyncStartAutomaton(::grpc::ClientContext* context, const ::ric::logic::v3::StartAutomatonRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::ric::logic::v3::StartAutomatonResponse>>(AsyncStartAutomatonRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::ric::logic::v3::StartAutomatonResponse>> PrepareAsyncStartAutomaton(::grpc::ClientContext* context, const ::ric::logic::v3::StartAutomatonRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::ric::logic::v3::StartAutomatonResponse>>(PrepareAsyncStartAutomatonRaw(context, request, cq));
    }
    ::grpc::Status StartAutomatonMulti(::grpc::ClientContext* context, const ::ric::logic::v3::StartAutomatonMultiRequest& request, ::ric::logic::v3::StartAutomatonResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::ric::logic::v3::StartAutomatonResponse>> AsyncStartAutomatonMulti(::grpc::ClientContext* context, const ::ric::logic::v3::StartAutomatonMultiRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::ric::logic::v3::StartAutomatonResponse>>(AsyncStartAutomatonMultiRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::ric::logic::v3::StartAutomatonResponse>> PrepareAsyncStartAutomatonMulti(::grpc::ClientContext* context, const ::ric::logic::v3::StartAutomatonMultiRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::ric::logic::v3::StartAutomatonResponse>>(PrepareAsyncStartAutomatonMultiRaw(context, request, cq));
    }
    ::grpc::Status StopAutomaton(::grpc::ClientContext* context, const ::ric::logic::v3::StopAutomatonRequest& request, ::ric::logic::v3::StopAutomatonResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::ric::logic::v3::StopAutomatonResponse>> AsyncStopAutomaton(::grpc::ClientContext* context, const ::ric::logic::v3::StopAutomatonRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::ric::logic::v3::StopAutomatonResponse>>(AsyncStopAutomatonRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::ric::logic::v3::StopAutomatonResponse>> PrepareAsyncStopAutomaton(::grpc::ClientContext* context, const ::ric::logic::v3::StopAutomatonRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::ric::logic::v3::StopAutomatonResponse>>(PrepareAsyncStopAutomatonRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientReader< ::ric::logic::v3::AutomatonInfo>> RunAutomaton(::grpc::ClientContext* context, const ::ric::logic::v3::RunAutomatonRequest& request) {
      return std::unique_ptr< ::grpc::ClientReader< ::ric::logic::v3::AutomatonInfo>>(RunAutomatonRaw(context, request));
    }
    std::unique_ptr< ::grpc::ClientAsyncReader< ::ric::logic::v3::AutomatonInfo>> AsyncRunAutomaton(::grpc::ClientContext* context, const ::ric::logic::v3::RunAutomatonRequest& request, ::grpc::CompletionQueue* cq, void* tag) {
      return std::unique_ptr< ::grpc::ClientAsyncReader< ::ric::logic::v3::AutomatonInfo>>(AsyncRunAutomatonRaw(context, request, cq, tag));
    }
    std::unique_ptr< ::grpc::ClientAsyncReader< ::ric::logic::v3::AutomatonInfo>> PrepareAsyncRunAutomaton(::grpc::ClientContext* context, const ::ric::logic::v3::RunAutomatonRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncReader< ::ric::logic::v3::AutomatonInfo>>(PrepareAsyncRunAutomatonRaw(context, request, cq));
    }
    ::grpc::Status EmitEvent(::grpc::ClientContext* context, const ::ric::logic::v3::EmitEventRequest& request, ::ric::logic::v3::EmitEventResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::ric::logic::v3::EmitEventResponse>> AsyncEmitEvent(::grpc::ClientContext* context, const ::ric::logic::v3::EmitEventRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::ric::logic::v3::EmitEventResponse>>(AsyncEmitEventRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::ric::logic::v3::EmitEventResponse>> PrepareAsyncEmitEvent(::grpc::ClientContext* context, const ::ric::logic::v3::EmitEventRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::ric::logic::v3::EmitEventResponse>>(PrepareAsyncEmitEventRaw(context, request, cq));
    }
    ::grpc::Status WaitEvent(::grpc::ClientContext* context, const ::ric::logic::v3::WaitEventRequest& request, ::ric::logic::v3::WaitEventResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::ric::logic::v3::WaitEventResponse>> AsyncWaitEvent(::grpc::ClientContext* context, const ::ric::logic::v3::WaitEventRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::ric::logic::v3::WaitEventResponse>>(AsyncWaitEventRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::ric::logic::v3::WaitEventResponse>> PrepareAsyncWaitEvent(::grpc::ClientContext* context, const ::ric::logic::v3::WaitEventRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::ric::logic::v3::WaitEventResponse>>(PrepareAsyncWaitEventRaw(context, request, cq));
    }
    ::grpc::Status UpdateAutomatonVars(::grpc::ClientContext* context, const ::ric::logic::v3::UpdateAutomatonVarsRequest& request, ::ric::logic::v3::UpdateAutomatonVarsResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::ric::logic::v3::UpdateAutomatonVarsResponse>> AsyncUpdateAutomatonVars(::grpc::ClientContext* context, const ::ric::logic::v3::UpdateAutomatonVarsRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::ric::logic::v3::UpdateAutomatonVarsResponse>>(AsyncUpdateAutomatonVarsRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::ric::logic::v3::UpdateAutomatonVarsResponse>> PrepareAsyncUpdateAutomatonVars(::grpc::ClientContext* context, const ::ric::logic::v3::UpdateAutomatonVarsRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::ric::logic::v3::UpdateAutomatonVarsResponse>>(PrepareAsyncUpdateAutomatonVarsRaw(context, request, cq));
    }
    ::grpc::Status TouchEventSubscription(::grpc::ClientContext* context, const ::ric::logic::v3::TouchEventSubscriptionRequest& request, ::ric::logic::v3::TouchEventSubscriptionResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::ric::logic::v3::TouchEventSubscriptionResponse>> AsyncTouchEventSubscription(::grpc::ClientContext* context, const ::ric::logic::v3::TouchEventSubscriptionRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::ric::logic::v3::TouchEventSubscriptionResponse>>(AsyncTouchEventSubscriptionRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::ric::logic::v3::TouchEventSubscriptionResponse>> PrepareAsyncTouchEventSubscription(::grpc::ClientContext* context, const ::ric::logic::v3::TouchEventSubscriptionRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::ric::logic::v3::TouchEventSubscriptionResponse>>(PrepareAsyncTouchEventSubscriptionRaw(context, request, cq));
    }
    class experimental_async final :
      public StubInterface::experimental_async_interface {
     public:
      void GetInstanceInfo(::grpc::ClientContext* context, const ::ric::logic::v3::GetInstanceInfoRequest* request, ::ric::logic::v3::GetInstanceInfoResponse* response, std::function<void(::grpc::Status)>) override;
      void GetInstanceInfo(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::ric::logic::v3::GetInstanceInfoResponse* response, std::function<void(::grpc::Status)>) override;
      void GetAutomatons(::grpc::ClientContext* context, ::ric::logic::v3::GetAutomatonsRequest* request, ::grpc::experimental::ClientReadReactor< ::ric::logic::v3::AutomatonInfo>* reactor) override;
      void StartAutomaton(::grpc::ClientContext* context, const ::ric::logic::v3::StartAutomatonRequest* request, ::ric::logic::v3::StartAutomatonResponse* response, std::function<void(::grpc::Status)>) override;
      void StartAutomaton(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::ric::logic::v3::StartAutomatonResponse* response, std::function<void(::grpc::Status)>) override;
      void StartAutomatonMulti(::grpc::ClientContext* context, const ::ric::logic::v3::StartAutomatonMultiRequest* request, ::ric::logic::v3::StartAutomatonResponse* response, std::function<void(::grpc::Status)>) override;
      void StartAutomatonMulti(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::ric::logic::v3::StartAutomatonResponse* response, std::function<void(::grpc::Status)>) override;
      void StopAutomaton(::grpc::ClientContext* context, const ::ric::logic::v3::StopAutomatonRequest* request, ::ric::logic::v3::StopAutomatonResponse* response, std::function<void(::grpc::Status)>) override;
      void StopAutomaton(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::ric::logic::v3::StopAutomatonResponse* response, std::function<void(::grpc::Status)>) override;
      void RunAutomaton(::grpc::ClientContext* context, ::ric::logic::v3::RunAutomatonRequest* request, ::grpc::experimental::ClientReadReactor< ::ric::logic::v3::AutomatonInfo>* reactor) override;
      void EmitEvent(::grpc::ClientContext* context, const ::ric::logic::v3::EmitEventRequest* request, ::ric::logic::v3::EmitEventResponse* response, std::function<void(::grpc::Status)>) override;
      void EmitEvent(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::ric::logic::v3::EmitEventResponse* response, std::function<void(::grpc::Status)>) override;
      void WaitEvent(::grpc::ClientContext* context, const ::ric::logic::v3::WaitEventRequest* request, ::ric::logic::v3::WaitEventResponse* response, std::function<void(::grpc::Status)>) override;
      void WaitEvent(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::ric::logic::v3::WaitEventResponse* response, std::function<void(::grpc::Status)>) override;
      void UpdateAutomatonVars(::grpc::ClientContext* context, const ::ric::logic::v3::UpdateAutomatonVarsRequest* request, ::ric::logic::v3::UpdateAutomatonVarsResponse* response, std::function<void(::grpc::Status)>) override;
      void UpdateAutomatonVars(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::ric::logic::v3::UpdateAutomatonVarsResponse* response, std::function<void(::grpc::Status)>) override;
      void TouchEventSubscription(::grpc::ClientContext* context, const ::ric::logic::v3::TouchEventSubscriptionRequest* request, ::ric::logic::v3::TouchEventSubscriptionResponse* response, std::function<void(::grpc::Status)>) override;
      void TouchEventSubscription(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::ric::logic::v3::TouchEventSubscriptionResponse* response, std::function<void(::grpc::Status)>) override;
     private:
      friend class Stub;
      explicit experimental_async(Stub* stub): stub_(stub) { }
      Stub* stub() { return stub_; }
      Stub* stub_;
    };
    class experimental_async_interface* experimental_async() override { return &async_stub_; }

   private:
    std::shared_ptr< ::grpc::ChannelInterface> channel_;
    class experimental_async async_stub_{this};
    ::grpc::ClientAsyncResponseReader< ::ric::logic::v3::GetInstanceInfoResponse>* AsyncGetInstanceInfoRaw(::grpc::ClientContext* context, const ::ric::logic::v3::GetInstanceInfoRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::ric::logic::v3::GetInstanceInfoResponse>* PrepareAsyncGetInstanceInfoRaw(::grpc::ClientContext* context, const ::ric::logic::v3::GetInstanceInfoRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientReader< ::ric::logic::v3::AutomatonInfo>* GetAutomatonsRaw(::grpc::ClientContext* context, const ::ric::logic::v3::GetAutomatonsRequest& request) override;
    ::grpc::ClientAsyncReader< ::ric::logic::v3::AutomatonInfo>* AsyncGetAutomatonsRaw(::grpc::ClientContext* context, const ::ric::logic::v3::GetAutomatonsRequest& request, ::grpc::CompletionQueue* cq, void* tag) override;
    ::grpc::ClientAsyncReader< ::ric::logic::v3::AutomatonInfo>* PrepareAsyncGetAutomatonsRaw(::grpc::ClientContext* context, const ::ric::logic::v3::GetAutomatonsRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::ric::logic::v3::StartAutomatonResponse>* AsyncStartAutomatonRaw(::grpc::ClientContext* context, const ::ric::logic::v3::StartAutomatonRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::ric::logic::v3::StartAutomatonResponse>* PrepareAsyncStartAutomatonRaw(::grpc::ClientContext* context, const ::ric::logic::v3::StartAutomatonRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::ric::logic::v3::StartAutomatonResponse>* AsyncStartAutomatonMultiRaw(::grpc::ClientContext* context, const ::ric::logic::v3::StartAutomatonMultiRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::ric::logic::v3::StartAutomatonResponse>* PrepareAsyncStartAutomatonMultiRaw(::grpc::ClientContext* context, const ::ric::logic::v3::StartAutomatonMultiRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::ric::logic::v3::StopAutomatonResponse>* AsyncStopAutomatonRaw(::grpc::ClientContext* context, const ::ric::logic::v3::StopAutomatonRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::ric::logic::v3::StopAutomatonResponse>* PrepareAsyncStopAutomatonRaw(::grpc::ClientContext* context, const ::ric::logic::v3::StopAutomatonRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientReader< ::ric::logic::v3::AutomatonInfo>* RunAutomatonRaw(::grpc::ClientContext* context, const ::ric::logic::v3::RunAutomatonRequest& request) override;
    ::grpc::ClientAsyncReader< ::ric::logic::v3::AutomatonInfo>* AsyncRunAutomatonRaw(::grpc::ClientContext* context, const ::ric::logic::v3::RunAutomatonRequest& request, ::grpc::CompletionQueue* cq, void* tag) override;
    ::grpc::ClientAsyncReader< ::ric::logic::v3::AutomatonInfo>* PrepareAsyncRunAutomatonRaw(::grpc::ClientContext* context, const ::ric::logic::v3::RunAutomatonRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::ric::logic::v3::EmitEventResponse>* AsyncEmitEventRaw(::grpc::ClientContext* context, const ::ric::logic::v3::EmitEventRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::ric::logic::v3::EmitEventResponse>* PrepareAsyncEmitEventRaw(::grpc::ClientContext* context, const ::ric::logic::v3::EmitEventRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::ric::logic::v3::WaitEventResponse>* AsyncWaitEventRaw(::grpc::ClientContext* context, const ::ric::logic::v3::WaitEventRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::ric::logic::v3::WaitEventResponse>* PrepareAsyncWaitEventRaw(::grpc::ClientContext* context, const ::ric::logic::v3::WaitEventRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::ric::logic::v3::UpdateAutomatonVarsResponse>* AsyncUpdateAutomatonVarsRaw(::grpc::ClientContext* context, const ::ric::logic::v3::UpdateAutomatonVarsRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::ric::logic::v3::UpdateAutomatonVarsResponse>* PrepareAsyncUpdateAutomatonVarsRaw(::grpc::ClientContext* context, const ::ric::logic::v3::UpdateAutomatonVarsRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::ric::logic::v3::TouchEventSubscriptionResponse>* AsyncTouchEventSubscriptionRaw(::grpc::ClientContext* context, const ::ric::logic::v3::TouchEventSubscriptionRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::ric::logic::v3::TouchEventSubscriptionResponse>* PrepareAsyncTouchEventSubscriptionRaw(::grpc::ClientContext* context, const ::ric::logic::v3::TouchEventSubscriptionRequest& request, ::grpc::CompletionQueue* cq) override;
    const ::grpc::internal::RpcMethod rpcmethod_GetInstanceInfo_;
    const ::grpc::internal::RpcMethod rpcmethod_GetAutomatons_;
    const ::grpc::internal::RpcMethod rpcmethod_StartAutomaton_;
    const ::grpc::internal::RpcMethod rpcmethod_StartAutomatonMulti_;
    const ::grpc::internal::RpcMethod rpcmethod_StopAutomaton_;
    const ::grpc::internal::RpcMethod rpcmethod_RunAutomaton_;
    const ::grpc::internal::RpcMethod rpcmethod_EmitEvent_;
    const ::grpc::internal::RpcMethod rpcmethod_WaitEvent_;
    const ::grpc::internal::RpcMethod rpcmethod_UpdateAutomatonVars_;
    const ::grpc::internal::RpcMethod rpcmethod_TouchEventSubscription_;
  };
  static std::unique_ptr<Stub> NewStub(const std::shared_ptr< ::grpc::ChannelInterface>& channel, const ::grpc::StubOptions& options = ::grpc::StubOptions());

  class Service : public ::grpc::Service {
   public:
    Service();
    virtual ~Service();
    virtual ::grpc::Status GetInstanceInfo(::grpc::ServerContext* context, const ::ric::logic::v3::GetInstanceInfoRequest* request, ::ric::logic::v3::GetInstanceInfoResponse* response);
    virtual ::grpc::Status GetAutomatons(::grpc::ServerContext* context, const ::ric::logic::v3::GetAutomatonsRequest* request, ::grpc::ServerWriter< ::ric::logic::v3::AutomatonInfo>* writer);
    virtual ::grpc::Status StartAutomaton(::grpc::ServerContext* context, const ::ric::logic::v3::StartAutomatonRequest* request, ::ric::logic::v3::StartAutomatonResponse* response);
    virtual ::grpc::Status StartAutomatonMulti(::grpc::ServerContext* context, const ::ric::logic::v3::StartAutomatonMultiRequest* request, ::ric::logic::v3::StartAutomatonResponse* response);
    virtual ::grpc::Status StopAutomaton(::grpc::ServerContext* context, const ::ric::logic::v3::StopAutomatonRequest* request, ::ric::logic::v3::StopAutomatonResponse* response);
    virtual ::grpc::Status RunAutomaton(::grpc::ServerContext* context, const ::ric::logic::v3::RunAutomatonRequest* request, ::grpc::ServerWriter< ::ric::logic::v3::AutomatonInfo>* writer);
    virtual ::grpc::Status EmitEvent(::grpc::ServerContext* context, const ::ric::logic::v3::EmitEventRequest* request, ::ric::logic::v3::EmitEventResponse* response);
    virtual ::grpc::Status WaitEvent(::grpc::ServerContext* context, const ::ric::logic::v3::WaitEventRequest* request, ::ric::logic::v3::WaitEventResponse* response);
    virtual ::grpc::Status UpdateAutomatonVars(::grpc::ServerContext* context, const ::ric::logic::v3::UpdateAutomatonVarsRequest* request, ::ric::logic::v3::UpdateAutomatonVarsResponse* response);
    virtual ::grpc::Status TouchEventSubscription(::grpc::ServerContext* context, const ::ric::logic::v3::TouchEventSubscriptionRequest* request, ::ric::logic::v3::TouchEventSubscriptionResponse* response);
  };
  template <class BaseClass>
  class WithAsyncMethod_GetInstanceInfo : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithAsyncMethod_GetInstanceInfo() {
      ::grpc::Service::MarkMethodAsync(0);
    }
    ~WithAsyncMethod_GetInstanceInfo() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetInstanceInfo(::grpc::ServerContext* context, const ::ric::logic::v3::GetInstanceInfoRequest* request, ::ric::logic::v3::GetInstanceInfoResponse* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetInstanceInfo(::grpc::ServerContext* context, ::ric::logic::v3::GetInstanceInfoRequest* request, ::grpc::ServerAsyncResponseWriter< ::ric::logic::v3::GetInstanceInfoResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(0, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_GetAutomatons : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithAsyncMethod_GetAutomatons() {
      ::grpc::Service::MarkMethodAsync(1);
    }
    ~WithAsyncMethod_GetAutomatons() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetAutomatons(::grpc::ServerContext* context, const ::ric::logic::v3::GetAutomatonsRequest* request, ::grpc::ServerWriter< ::ric::logic::v3::AutomatonInfo>* writer) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetAutomatons(::grpc::ServerContext* context, ::ric::logic::v3::GetAutomatonsRequest* request, ::grpc::ServerAsyncWriter< ::ric::logic::v3::AutomatonInfo>* writer, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncServerStreaming(1, context, request, writer, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_StartAutomaton : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithAsyncMethod_StartAutomaton() {
      ::grpc::Service::MarkMethodAsync(2);
    }
    ~WithAsyncMethod_StartAutomaton() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status StartAutomaton(::grpc::ServerContext* context, const ::ric::logic::v3::StartAutomatonRequest* request, ::ric::logic::v3::StartAutomatonResponse* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestStartAutomaton(::grpc::ServerContext* context, ::ric::logic::v3::StartAutomatonRequest* request, ::grpc::ServerAsyncResponseWriter< ::ric::logic::v3::StartAutomatonResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(2, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_StartAutomatonMulti : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithAsyncMethod_StartAutomatonMulti() {
      ::grpc::Service::MarkMethodAsync(3);
    }
    ~WithAsyncMethod_StartAutomatonMulti() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status StartAutomatonMulti(::grpc::ServerContext* context, const ::ric::logic::v3::StartAutomatonMultiRequest* request, ::ric::logic::v3::StartAutomatonResponse* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestStartAutomatonMulti(::grpc::ServerContext* context, ::ric::logic::v3::StartAutomatonMultiRequest* request, ::grpc::ServerAsyncResponseWriter< ::ric::logic::v3::StartAutomatonResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(3, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_StopAutomaton : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithAsyncMethod_StopAutomaton() {
      ::grpc::Service::MarkMethodAsync(4);
    }
    ~WithAsyncMethod_StopAutomaton() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status StopAutomaton(::grpc::ServerContext* context, const ::ric::logic::v3::StopAutomatonRequest* request, ::ric::logic::v3::StopAutomatonResponse* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestStopAutomaton(::grpc::ServerContext* context, ::ric::logic::v3::StopAutomatonRequest* request, ::grpc::ServerAsyncResponseWriter< ::ric::logic::v3::StopAutomatonResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(4, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_RunAutomaton : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithAsyncMethod_RunAutomaton() {
      ::grpc::Service::MarkMethodAsync(5);
    }
    ~WithAsyncMethod_RunAutomaton() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status RunAutomaton(::grpc::ServerContext* context, const ::ric::logic::v3::RunAutomatonRequest* request, ::grpc::ServerWriter< ::ric::logic::v3::AutomatonInfo>* writer) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestRunAutomaton(::grpc::ServerContext* context, ::ric::logic::v3::RunAutomatonRequest* request, ::grpc::ServerAsyncWriter< ::ric::logic::v3::AutomatonInfo>* writer, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncServerStreaming(5, context, request, writer, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_EmitEvent : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithAsyncMethod_EmitEvent() {
      ::grpc::Service::MarkMethodAsync(6);
    }
    ~WithAsyncMethod_EmitEvent() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status EmitEvent(::grpc::ServerContext* context, const ::ric::logic::v3::EmitEventRequest* request, ::ric::logic::v3::EmitEventResponse* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestEmitEvent(::grpc::ServerContext* context, ::ric::logic::v3::EmitEventRequest* request, ::grpc::ServerAsyncResponseWriter< ::ric::logic::v3::EmitEventResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(6, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_WaitEvent : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithAsyncMethod_WaitEvent() {
      ::grpc::Service::MarkMethodAsync(7);
    }
    ~WithAsyncMethod_WaitEvent() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status WaitEvent(::grpc::ServerContext* context, const ::ric::logic::v3::WaitEventRequest* request, ::ric::logic::v3::WaitEventResponse* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestWaitEvent(::grpc::ServerContext* context, ::ric::logic::v3::WaitEventRequest* request, ::grpc::ServerAsyncResponseWriter< ::ric::logic::v3::WaitEventResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(7, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_UpdateAutomatonVars : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithAsyncMethod_UpdateAutomatonVars() {
      ::grpc::Service::MarkMethodAsync(8);
    }
    ~WithAsyncMethod_UpdateAutomatonVars() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status UpdateAutomatonVars(::grpc::ServerContext* context, const ::ric::logic::v3::UpdateAutomatonVarsRequest* request, ::ric::logic::v3::UpdateAutomatonVarsResponse* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestUpdateAutomatonVars(::grpc::ServerContext* context, ::ric::logic::v3::UpdateAutomatonVarsRequest* request, ::grpc::ServerAsyncResponseWriter< ::ric::logic::v3::UpdateAutomatonVarsResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(8, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_TouchEventSubscription : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithAsyncMethod_TouchEventSubscription() {
      ::grpc::Service::MarkMethodAsync(9);
    }
    ~WithAsyncMethod_TouchEventSubscription() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status TouchEventSubscription(::grpc::ServerContext* context, const ::ric::logic::v3::TouchEventSubscriptionRequest* request, ::ric::logic::v3::TouchEventSubscriptionResponse* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestTouchEventSubscription(::grpc::ServerContext* context, ::ric::logic::v3::TouchEventSubscriptionRequest* request, ::grpc::ServerAsyncResponseWriter< ::ric::logic::v3::TouchEventSubscriptionResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(9, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  typedef WithAsyncMethod_GetInstanceInfo<WithAsyncMethod_GetAutomatons<WithAsyncMethod_StartAutomaton<WithAsyncMethod_StartAutomatonMulti<WithAsyncMethod_StopAutomaton<WithAsyncMethod_RunAutomaton<WithAsyncMethod_EmitEvent<WithAsyncMethod_WaitEvent<WithAsyncMethod_UpdateAutomatonVars<WithAsyncMethod_TouchEventSubscription<Service > > > > > > > > > > AsyncService;
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_GetInstanceInfo : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    ExperimentalWithCallbackMethod_GetInstanceInfo() {
      ::grpc::Service::experimental().MarkMethodCallback(0,
        new ::grpc::internal::CallbackUnaryHandler< ::ric::logic::v3::GetInstanceInfoRequest, ::ric::logic::v3::GetInstanceInfoResponse>(
          [this](::grpc::ServerContext* context,
                 const ::ric::logic::v3::GetInstanceInfoRequest* request,
                 ::ric::logic::v3::GetInstanceInfoResponse* response,
                 ::grpc::experimental::ServerCallbackRpcController* controller) {
                   return this->GetInstanceInfo(context, request, response, controller);
                 }));
    }
    ~ExperimentalWithCallbackMethod_GetInstanceInfo() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetInstanceInfo(::grpc::ServerContext* context, const ::ric::logic::v3::GetInstanceInfoRequest* request, ::ric::logic::v3::GetInstanceInfoResponse* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual void GetInstanceInfo(::grpc::ServerContext* context, const ::ric::logic::v3::GetInstanceInfoRequest* request, ::ric::logic::v3::GetInstanceInfoResponse* response, ::grpc::experimental::ServerCallbackRpcController* controller) { controller->Finish(::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "")); }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_GetAutomatons : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    ExperimentalWithCallbackMethod_GetAutomatons() {
      ::grpc::Service::experimental().MarkMethodCallback(1,
        new ::grpc::internal::CallbackServerStreamingHandler< ::ric::logic::v3::GetAutomatonsRequest, ::ric::logic::v3::AutomatonInfo>(
          [this] { return this->GetAutomatons(); }));
    }
    ~ExperimentalWithCallbackMethod_GetAutomatons() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetAutomatons(::grpc::ServerContext* context, const ::ric::logic::v3::GetAutomatonsRequest* request, ::grpc::ServerWriter< ::ric::logic::v3::AutomatonInfo>* writer) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::experimental::ServerWriteReactor< ::ric::logic::v3::GetAutomatonsRequest, ::ric::logic::v3::AutomatonInfo>* GetAutomatons() {
      return new ::grpc::internal::UnimplementedWriteReactor<
        ::ric::logic::v3::GetAutomatonsRequest, ::ric::logic::v3::AutomatonInfo>;}
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_StartAutomaton : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    ExperimentalWithCallbackMethod_StartAutomaton() {
      ::grpc::Service::experimental().MarkMethodCallback(2,
        new ::grpc::internal::CallbackUnaryHandler< ::ric::logic::v3::StartAutomatonRequest, ::ric::logic::v3::StartAutomatonResponse>(
          [this](::grpc::ServerContext* context,
                 const ::ric::logic::v3::StartAutomatonRequest* request,
                 ::ric::logic::v3::StartAutomatonResponse* response,
                 ::grpc::experimental::ServerCallbackRpcController* controller) {
                   return this->StartAutomaton(context, request, response, controller);
                 }));
    }
    ~ExperimentalWithCallbackMethod_StartAutomaton() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status StartAutomaton(::grpc::ServerContext* context, const ::ric::logic::v3::StartAutomatonRequest* request, ::ric::logic::v3::StartAutomatonResponse* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual void StartAutomaton(::grpc::ServerContext* context, const ::ric::logic::v3::StartAutomatonRequest* request, ::ric::logic::v3::StartAutomatonResponse* response, ::grpc::experimental::ServerCallbackRpcController* controller) { controller->Finish(::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "")); }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_StartAutomatonMulti : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    ExperimentalWithCallbackMethod_StartAutomatonMulti() {
      ::grpc::Service::experimental().MarkMethodCallback(3,
        new ::grpc::internal::CallbackUnaryHandler< ::ric::logic::v3::StartAutomatonMultiRequest, ::ric::logic::v3::StartAutomatonResponse>(
          [this](::grpc::ServerContext* context,
                 const ::ric::logic::v3::StartAutomatonMultiRequest* request,
                 ::ric::logic::v3::StartAutomatonResponse* response,
                 ::grpc::experimental::ServerCallbackRpcController* controller) {
                   return this->StartAutomatonMulti(context, request, response, controller);
                 }));
    }
    ~ExperimentalWithCallbackMethod_StartAutomatonMulti() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status StartAutomatonMulti(::grpc::ServerContext* context, const ::ric::logic::v3::StartAutomatonMultiRequest* request, ::ric::logic::v3::StartAutomatonResponse* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual void StartAutomatonMulti(::grpc::ServerContext* context, const ::ric::logic::v3::StartAutomatonMultiRequest* request, ::ric::logic::v3::StartAutomatonResponse* response, ::grpc::experimental::ServerCallbackRpcController* controller) { controller->Finish(::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "")); }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_StopAutomaton : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    ExperimentalWithCallbackMethod_StopAutomaton() {
      ::grpc::Service::experimental().MarkMethodCallback(4,
        new ::grpc::internal::CallbackUnaryHandler< ::ric::logic::v3::StopAutomatonRequest, ::ric::logic::v3::StopAutomatonResponse>(
          [this](::grpc::ServerContext* context,
                 const ::ric::logic::v3::StopAutomatonRequest* request,
                 ::ric::logic::v3::StopAutomatonResponse* response,
                 ::grpc::experimental::ServerCallbackRpcController* controller) {
                   return this->StopAutomaton(context, request, response, controller);
                 }));
    }
    ~ExperimentalWithCallbackMethod_StopAutomaton() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status StopAutomaton(::grpc::ServerContext* context, const ::ric::logic::v3::StopAutomatonRequest* request, ::ric::logic::v3::StopAutomatonResponse* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual void StopAutomaton(::grpc::ServerContext* context, const ::ric::logic::v3::StopAutomatonRequest* request, ::ric::logic::v3::StopAutomatonResponse* response, ::grpc::experimental::ServerCallbackRpcController* controller) { controller->Finish(::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "")); }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_RunAutomaton : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    ExperimentalWithCallbackMethod_RunAutomaton() {
      ::grpc::Service::experimental().MarkMethodCallback(5,
        new ::grpc::internal::CallbackServerStreamingHandler< ::ric::logic::v3::RunAutomatonRequest, ::ric::logic::v3::AutomatonInfo>(
          [this] { return this->RunAutomaton(); }));
    }
    ~ExperimentalWithCallbackMethod_RunAutomaton() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status RunAutomaton(::grpc::ServerContext* context, const ::ric::logic::v3::RunAutomatonRequest* request, ::grpc::ServerWriter< ::ric::logic::v3::AutomatonInfo>* writer) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::experimental::ServerWriteReactor< ::ric::logic::v3::RunAutomatonRequest, ::ric::logic::v3::AutomatonInfo>* RunAutomaton() {
      return new ::grpc::internal::UnimplementedWriteReactor<
        ::ric::logic::v3::RunAutomatonRequest, ::ric::logic::v3::AutomatonInfo>;}
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_EmitEvent : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    ExperimentalWithCallbackMethod_EmitEvent() {
      ::grpc::Service::experimental().MarkMethodCallback(6,
        new ::grpc::internal::CallbackUnaryHandler< ::ric::logic::v3::EmitEventRequest, ::ric::logic::v3::EmitEventResponse>(
          [this](::grpc::ServerContext* context,
                 const ::ric::logic::v3::EmitEventRequest* request,
                 ::ric::logic::v3::EmitEventResponse* response,
                 ::grpc::experimental::ServerCallbackRpcController* controller) {
                   return this->EmitEvent(context, request, response, controller);
                 }));
    }
    ~ExperimentalWithCallbackMethod_EmitEvent() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status EmitEvent(::grpc::ServerContext* context, const ::ric::logic::v3::EmitEventRequest* request, ::ric::logic::v3::EmitEventResponse* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual void EmitEvent(::grpc::ServerContext* context, const ::ric::logic::v3::EmitEventRequest* request, ::ric::logic::v3::EmitEventResponse* response, ::grpc::experimental::ServerCallbackRpcController* controller) { controller->Finish(::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "")); }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_WaitEvent : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    ExperimentalWithCallbackMethod_WaitEvent() {
      ::grpc::Service::experimental().MarkMethodCallback(7,
        new ::grpc::internal::CallbackUnaryHandler< ::ric::logic::v3::WaitEventRequest, ::ric::logic::v3::WaitEventResponse>(
          [this](::grpc::ServerContext* context,
                 const ::ric::logic::v3::WaitEventRequest* request,
                 ::ric::logic::v3::WaitEventResponse* response,
                 ::grpc::experimental::ServerCallbackRpcController* controller) {
                   return this->WaitEvent(context, request, response, controller);
                 }));
    }
    ~ExperimentalWithCallbackMethod_WaitEvent() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status WaitEvent(::grpc::ServerContext* context, const ::ric::logic::v3::WaitEventRequest* request, ::ric::logic::v3::WaitEventResponse* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual void WaitEvent(::grpc::ServerContext* context, const ::ric::logic::v3::WaitEventRequest* request, ::ric::logic::v3::WaitEventResponse* response, ::grpc::experimental::ServerCallbackRpcController* controller) { controller->Finish(::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "")); }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_UpdateAutomatonVars : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    ExperimentalWithCallbackMethod_UpdateAutomatonVars() {
      ::grpc::Service::experimental().MarkMethodCallback(8,
        new ::grpc::internal::CallbackUnaryHandler< ::ric::logic::v3::UpdateAutomatonVarsRequest, ::ric::logic::v3::UpdateAutomatonVarsResponse>(
          [this](::grpc::ServerContext* context,
                 const ::ric::logic::v3::UpdateAutomatonVarsRequest* request,
                 ::ric::logic::v3::UpdateAutomatonVarsResponse* response,
                 ::grpc::experimental::ServerCallbackRpcController* controller) {
                   return this->UpdateAutomatonVars(context, request, response, controller);
                 }));
    }
    ~ExperimentalWithCallbackMethod_UpdateAutomatonVars() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status UpdateAutomatonVars(::grpc::ServerContext* context, const ::ric::logic::v3::UpdateAutomatonVarsRequest* request, ::ric::logic::v3::UpdateAutomatonVarsResponse* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual void UpdateAutomatonVars(::grpc::ServerContext* context, const ::ric::logic::v3::UpdateAutomatonVarsRequest* request, ::ric::logic::v3::UpdateAutomatonVarsResponse* response, ::grpc::experimental::ServerCallbackRpcController* controller) { controller->Finish(::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "")); }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_TouchEventSubscription : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    ExperimentalWithCallbackMethod_TouchEventSubscription() {
      ::grpc::Service::experimental().MarkMethodCallback(9,
        new ::grpc::internal::CallbackUnaryHandler< ::ric::logic::v3::TouchEventSubscriptionRequest, ::ric::logic::v3::TouchEventSubscriptionResponse>(
          [this](::grpc::ServerContext* context,
                 const ::ric::logic::v3::TouchEventSubscriptionRequest* request,
                 ::ric::logic::v3::TouchEventSubscriptionResponse* response,
                 ::grpc::experimental::ServerCallbackRpcController* controller) {
                   return this->TouchEventSubscription(context, request, response, controller);
                 }));
    }
    ~ExperimentalWithCallbackMethod_TouchEventSubscription() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status TouchEventSubscription(::grpc::ServerContext* context, const ::ric::logic::v3::TouchEventSubscriptionRequest* request, ::ric::logic::v3::TouchEventSubscriptionResponse* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual void TouchEventSubscription(::grpc::ServerContext* context, const ::ric::logic::v3::TouchEventSubscriptionRequest* request, ::ric::logic::v3::TouchEventSubscriptionResponse* response, ::grpc::experimental::ServerCallbackRpcController* controller) { controller->Finish(::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "")); }
  };
  typedef ExperimentalWithCallbackMethod_GetInstanceInfo<ExperimentalWithCallbackMethod_GetAutomatons<ExperimentalWithCallbackMethod_StartAutomaton<ExperimentalWithCallbackMethod_StartAutomatonMulti<ExperimentalWithCallbackMethod_StopAutomaton<ExperimentalWithCallbackMethod_RunAutomaton<ExperimentalWithCallbackMethod_EmitEvent<ExperimentalWithCallbackMethod_WaitEvent<ExperimentalWithCallbackMethod_UpdateAutomatonVars<ExperimentalWithCallbackMethod_TouchEventSubscription<Service > > > > > > > > > > ExperimentalCallbackService;
  template <class BaseClass>
  class WithGenericMethod_GetInstanceInfo : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithGenericMethod_GetInstanceInfo() {
      ::grpc::Service::MarkMethodGeneric(0);
    }
    ~WithGenericMethod_GetInstanceInfo() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetInstanceInfo(::grpc::ServerContext* context, const ::ric::logic::v3::GetInstanceInfoRequest* request, ::ric::logic::v3::GetInstanceInfoResponse* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_GetAutomatons : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithGenericMethod_GetAutomatons() {
      ::grpc::Service::MarkMethodGeneric(1);
    }
    ~WithGenericMethod_GetAutomatons() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetAutomatons(::grpc::ServerContext* context, const ::ric::logic::v3::GetAutomatonsRequest* request, ::grpc::ServerWriter< ::ric::logic::v3::AutomatonInfo>* writer) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_StartAutomaton : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithGenericMethod_StartAutomaton() {
      ::grpc::Service::MarkMethodGeneric(2);
    }
    ~WithGenericMethod_StartAutomaton() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status StartAutomaton(::grpc::ServerContext* context, const ::ric::logic::v3::StartAutomatonRequest* request, ::ric::logic::v3::StartAutomatonResponse* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_StartAutomatonMulti : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithGenericMethod_StartAutomatonMulti() {
      ::grpc::Service::MarkMethodGeneric(3);
    }
    ~WithGenericMethod_StartAutomatonMulti() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status StartAutomatonMulti(::grpc::ServerContext* context, const ::ric::logic::v3::StartAutomatonMultiRequest* request, ::ric::logic::v3::StartAutomatonResponse* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_StopAutomaton : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithGenericMethod_StopAutomaton() {
      ::grpc::Service::MarkMethodGeneric(4);
    }
    ~WithGenericMethod_StopAutomaton() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status StopAutomaton(::grpc::ServerContext* context, const ::ric::logic::v3::StopAutomatonRequest* request, ::ric::logic::v3::StopAutomatonResponse* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_RunAutomaton : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithGenericMethod_RunAutomaton() {
      ::grpc::Service::MarkMethodGeneric(5);
    }
    ~WithGenericMethod_RunAutomaton() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status RunAutomaton(::grpc::ServerContext* context, const ::ric::logic::v3::RunAutomatonRequest* request, ::grpc::ServerWriter< ::ric::logic::v3::AutomatonInfo>* writer) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_EmitEvent : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithGenericMethod_EmitEvent() {
      ::grpc::Service::MarkMethodGeneric(6);
    }
    ~WithGenericMethod_EmitEvent() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status EmitEvent(::grpc::ServerContext* context, const ::ric::logic::v3::EmitEventRequest* request, ::ric::logic::v3::EmitEventResponse* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_WaitEvent : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithGenericMethod_WaitEvent() {
      ::grpc::Service::MarkMethodGeneric(7);
    }
    ~WithGenericMethod_WaitEvent() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status WaitEvent(::grpc::ServerContext* context, const ::ric::logic::v3::WaitEventRequest* request, ::ric::logic::v3::WaitEventResponse* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_UpdateAutomatonVars : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithGenericMethod_UpdateAutomatonVars() {
      ::grpc::Service::MarkMethodGeneric(8);
    }
    ~WithGenericMethod_UpdateAutomatonVars() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status UpdateAutomatonVars(::grpc::ServerContext* context, const ::ric::logic::v3::UpdateAutomatonVarsRequest* request, ::ric::logic::v3::UpdateAutomatonVarsResponse* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_TouchEventSubscription : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithGenericMethod_TouchEventSubscription() {
      ::grpc::Service::MarkMethodGeneric(9);
    }
    ~WithGenericMethod_TouchEventSubscription() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status TouchEventSubscription(::grpc::ServerContext* context, const ::ric::logic::v3::TouchEventSubscriptionRequest* request, ::ric::logic::v3::TouchEventSubscriptionResponse* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithRawMethod_GetInstanceInfo : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithRawMethod_GetInstanceInfo() {
      ::grpc::Service::MarkMethodRaw(0);
    }
    ~WithRawMethod_GetInstanceInfo() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetInstanceInfo(::grpc::ServerContext* context, const ::ric::logic::v3::GetInstanceInfoRequest* request, ::ric::logic::v3::GetInstanceInfoResponse* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetInstanceInfo(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(0, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_GetAutomatons : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithRawMethod_GetAutomatons() {
      ::grpc::Service::MarkMethodRaw(1);
    }
    ~WithRawMethod_GetAutomatons() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetAutomatons(::grpc::ServerContext* context, const ::ric::logic::v3::GetAutomatonsRequest* request, ::grpc::ServerWriter< ::ric::logic::v3::AutomatonInfo>* writer) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetAutomatons(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncWriter< ::grpc::ByteBuffer>* writer, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncServerStreaming(1, context, request, writer, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_StartAutomaton : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithRawMethod_StartAutomaton() {
      ::grpc::Service::MarkMethodRaw(2);
    }
    ~WithRawMethod_StartAutomaton() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status StartAutomaton(::grpc::ServerContext* context, const ::ric::logic::v3::StartAutomatonRequest* request, ::ric::logic::v3::StartAutomatonResponse* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestStartAutomaton(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(2, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_StartAutomatonMulti : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithRawMethod_StartAutomatonMulti() {
      ::grpc::Service::MarkMethodRaw(3);
    }
    ~WithRawMethod_StartAutomatonMulti() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status StartAutomatonMulti(::grpc::ServerContext* context, const ::ric::logic::v3::StartAutomatonMultiRequest* request, ::ric::logic::v3::StartAutomatonResponse* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestStartAutomatonMulti(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(3, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_StopAutomaton : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithRawMethod_StopAutomaton() {
      ::grpc::Service::MarkMethodRaw(4);
    }
    ~WithRawMethod_StopAutomaton() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status StopAutomaton(::grpc::ServerContext* context, const ::ric::logic::v3::StopAutomatonRequest* request, ::ric::logic::v3::StopAutomatonResponse* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestStopAutomaton(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(4, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_RunAutomaton : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithRawMethod_RunAutomaton() {
      ::grpc::Service::MarkMethodRaw(5);
    }
    ~WithRawMethod_RunAutomaton() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status RunAutomaton(::grpc::ServerContext* context, const ::ric::logic::v3::RunAutomatonRequest* request, ::grpc::ServerWriter< ::ric::logic::v3::AutomatonInfo>* writer) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestRunAutomaton(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncWriter< ::grpc::ByteBuffer>* writer, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncServerStreaming(5, context, request, writer, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_EmitEvent : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithRawMethod_EmitEvent() {
      ::grpc::Service::MarkMethodRaw(6);
    }
    ~WithRawMethod_EmitEvent() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status EmitEvent(::grpc::ServerContext* context, const ::ric::logic::v3::EmitEventRequest* request, ::ric::logic::v3::EmitEventResponse* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestEmitEvent(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(6, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_WaitEvent : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithRawMethod_WaitEvent() {
      ::grpc::Service::MarkMethodRaw(7);
    }
    ~WithRawMethod_WaitEvent() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status WaitEvent(::grpc::ServerContext* context, const ::ric::logic::v3::WaitEventRequest* request, ::ric::logic::v3::WaitEventResponse* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestWaitEvent(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(7, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_UpdateAutomatonVars : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithRawMethod_UpdateAutomatonVars() {
      ::grpc::Service::MarkMethodRaw(8);
    }
    ~WithRawMethod_UpdateAutomatonVars() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status UpdateAutomatonVars(::grpc::ServerContext* context, const ::ric::logic::v3::UpdateAutomatonVarsRequest* request, ::ric::logic::v3::UpdateAutomatonVarsResponse* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestUpdateAutomatonVars(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(8, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_TouchEventSubscription : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithRawMethod_TouchEventSubscription() {
      ::grpc::Service::MarkMethodRaw(9);
    }
    ~WithRawMethod_TouchEventSubscription() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status TouchEventSubscription(::grpc::ServerContext* context, const ::ric::logic::v3::TouchEventSubscriptionRequest* request, ::ric::logic::v3::TouchEventSubscriptionResponse* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestTouchEventSubscription(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(9, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_GetInstanceInfo : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    ExperimentalWithRawCallbackMethod_GetInstanceInfo() {
      ::grpc::Service::experimental().MarkMethodRawCallback(0,
        new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
          [this](::grpc::ServerContext* context,
                 const ::grpc::ByteBuffer* request,
                 ::grpc::ByteBuffer* response,
                 ::grpc::experimental::ServerCallbackRpcController* controller) {
                   this->GetInstanceInfo(context, request, response, controller);
                 }));
    }
    ~ExperimentalWithRawCallbackMethod_GetInstanceInfo() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetInstanceInfo(::grpc::ServerContext* context, const ::ric::logic::v3::GetInstanceInfoRequest* request, ::ric::logic::v3::GetInstanceInfoResponse* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual void GetInstanceInfo(::grpc::ServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response, ::grpc::experimental::ServerCallbackRpcController* controller) { controller->Finish(::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "")); }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_GetAutomatons : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    ExperimentalWithRawCallbackMethod_GetAutomatons() {
      ::grpc::Service::experimental().MarkMethodRawCallback(1,
        new ::grpc::internal::CallbackServerStreamingHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
          [this] { return this->GetAutomatons(); }));
    }
    ~ExperimentalWithRawCallbackMethod_GetAutomatons() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetAutomatons(::grpc::ServerContext* context, const ::ric::logic::v3::GetAutomatonsRequest* request, ::grpc::ServerWriter< ::ric::logic::v3::AutomatonInfo>* writer) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::experimental::ServerWriteReactor< ::grpc::ByteBuffer, ::grpc::ByteBuffer>* GetAutomatons() {
      return new ::grpc::internal::UnimplementedWriteReactor<
        ::grpc::ByteBuffer, ::grpc::ByteBuffer>;}
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_StartAutomaton : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    ExperimentalWithRawCallbackMethod_StartAutomaton() {
      ::grpc::Service::experimental().MarkMethodRawCallback(2,
        new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
          [this](::grpc::ServerContext* context,
                 const ::grpc::ByteBuffer* request,
                 ::grpc::ByteBuffer* response,
                 ::grpc::experimental::ServerCallbackRpcController* controller) {
                   this->StartAutomaton(context, request, response, controller);
                 }));
    }
    ~ExperimentalWithRawCallbackMethod_StartAutomaton() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status StartAutomaton(::grpc::ServerContext* context, const ::ric::logic::v3::StartAutomatonRequest* request, ::ric::logic::v3::StartAutomatonResponse* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual void StartAutomaton(::grpc::ServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response, ::grpc::experimental::ServerCallbackRpcController* controller) { controller->Finish(::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "")); }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_StartAutomatonMulti : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    ExperimentalWithRawCallbackMethod_StartAutomatonMulti() {
      ::grpc::Service::experimental().MarkMethodRawCallback(3,
        new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
          [this](::grpc::ServerContext* context,
                 const ::grpc::ByteBuffer* request,
                 ::grpc::ByteBuffer* response,
                 ::grpc::experimental::ServerCallbackRpcController* controller) {
                   this->StartAutomatonMulti(context, request, response, controller);
                 }));
    }
    ~ExperimentalWithRawCallbackMethod_StartAutomatonMulti() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status StartAutomatonMulti(::grpc::ServerContext* context, const ::ric::logic::v3::StartAutomatonMultiRequest* request, ::ric::logic::v3::StartAutomatonResponse* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual void StartAutomatonMulti(::grpc::ServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response, ::grpc::experimental::ServerCallbackRpcController* controller) { controller->Finish(::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "")); }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_StopAutomaton : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    ExperimentalWithRawCallbackMethod_StopAutomaton() {
      ::grpc::Service::experimental().MarkMethodRawCallback(4,
        new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
          [this](::grpc::ServerContext* context,
                 const ::grpc::ByteBuffer* request,
                 ::grpc::ByteBuffer* response,
                 ::grpc::experimental::ServerCallbackRpcController* controller) {
                   this->StopAutomaton(context, request, response, controller);
                 }));
    }
    ~ExperimentalWithRawCallbackMethod_StopAutomaton() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status StopAutomaton(::grpc::ServerContext* context, const ::ric::logic::v3::StopAutomatonRequest* request, ::ric::logic::v3::StopAutomatonResponse* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual void StopAutomaton(::grpc::ServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response, ::grpc::experimental::ServerCallbackRpcController* controller) { controller->Finish(::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "")); }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_RunAutomaton : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    ExperimentalWithRawCallbackMethod_RunAutomaton() {
      ::grpc::Service::experimental().MarkMethodRawCallback(5,
        new ::grpc::internal::CallbackServerStreamingHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
          [this] { return this->RunAutomaton(); }));
    }
    ~ExperimentalWithRawCallbackMethod_RunAutomaton() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status RunAutomaton(::grpc::ServerContext* context, const ::ric::logic::v3::RunAutomatonRequest* request, ::grpc::ServerWriter< ::ric::logic::v3::AutomatonInfo>* writer) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::experimental::ServerWriteReactor< ::grpc::ByteBuffer, ::grpc::ByteBuffer>* RunAutomaton() {
      return new ::grpc::internal::UnimplementedWriteReactor<
        ::grpc::ByteBuffer, ::grpc::ByteBuffer>;}
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_EmitEvent : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    ExperimentalWithRawCallbackMethod_EmitEvent() {
      ::grpc::Service::experimental().MarkMethodRawCallback(6,
        new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
          [this](::grpc::ServerContext* context,
                 const ::grpc::ByteBuffer* request,
                 ::grpc::ByteBuffer* response,
                 ::grpc::experimental::ServerCallbackRpcController* controller) {
                   this->EmitEvent(context, request, response, controller);
                 }));
    }
    ~ExperimentalWithRawCallbackMethod_EmitEvent() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status EmitEvent(::grpc::ServerContext* context, const ::ric::logic::v3::EmitEventRequest* request, ::ric::logic::v3::EmitEventResponse* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual void EmitEvent(::grpc::ServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response, ::grpc::experimental::ServerCallbackRpcController* controller) { controller->Finish(::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "")); }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_WaitEvent : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    ExperimentalWithRawCallbackMethod_WaitEvent() {
      ::grpc::Service::experimental().MarkMethodRawCallback(7,
        new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
          [this](::grpc::ServerContext* context,
                 const ::grpc::ByteBuffer* request,
                 ::grpc::ByteBuffer* response,
                 ::grpc::experimental::ServerCallbackRpcController* controller) {
                   this->WaitEvent(context, request, response, controller);
                 }));
    }
    ~ExperimentalWithRawCallbackMethod_WaitEvent() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status WaitEvent(::grpc::ServerContext* context, const ::ric::logic::v3::WaitEventRequest* request, ::ric::logic::v3::WaitEventResponse* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual void WaitEvent(::grpc::ServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response, ::grpc::experimental::ServerCallbackRpcController* controller) { controller->Finish(::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "")); }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_UpdateAutomatonVars : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    ExperimentalWithRawCallbackMethod_UpdateAutomatonVars() {
      ::grpc::Service::experimental().MarkMethodRawCallback(8,
        new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
          [this](::grpc::ServerContext* context,
                 const ::grpc::ByteBuffer* request,
                 ::grpc::ByteBuffer* response,
                 ::grpc::experimental::ServerCallbackRpcController* controller) {
                   this->UpdateAutomatonVars(context, request, response, controller);
                 }));
    }
    ~ExperimentalWithRawCallbackMethod_UpdateAutomatonVars() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status UpdateAutomatonVars(::grpc::ServerContext* context, const ::ric::logic::v3::UpdateAutomatonVarsRequest* request, ::ric::logic::v3::UpdateAutomatonVarsResponse* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual void UpdateAutomatonVars(::grpc::ServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response, ::grpc::experimental::ServerCallbackRpcController* controller) { controller->Finish(::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "")); }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_TouchEventSubscription : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    ExperimentalWithRawCallbackMethod_TouchEventSubscription() {
      ::grpc::Service::experimental().MarkMethodRawCallback(9,
        new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
          [this](::grpc::ServerContext* context,
                 const ::grpc::ByteBuffer* request,
                 ::grpc::ByteBuffer* response,
                 ::grpc::experimental::ServerCallbackRpcController* controller) {
                   this->TouchEventSubscription(context, request, response, controller);
                 }));
    }
    ~ExperimentalWithRawCallbackMethod_TouchEventSubscription() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status TouchEventSubscription(::grpc::ServerContext* context, const ::ric::logic::v3::TouchEventSubscriptionRequest* request, ::ric::logic::v3::TouchEventSubscriptionResponse* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual void TouchEventSubscription(::grpc::ServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response, ::grpc::experimental::ServerCallbackRpcController* controller) { controller->Finish(::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "")); }
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_GetInstanceInfo : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithStreamedUnaryMethod_GetInstanceInfo() {
      ::grpc::Service::MarkMethodStreamed(0,
        new ::grpc::internal::StreamedUnaryHandler< ::ric::logic::v3::GetInstanceInfoRequest, ::ric::logic::v3::GetInstanceInfoResponse>(std::bind(&WithStreamedUnaryMethod_GetInstanceInfo<BaseClass>::StreamedGetInstanceInfo, this, std::placeholders::_1, std::placeholders::_2)));
    }
    ~WithStreamedUnaryMethod_GetInstanceInfo() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status GetInstanceInfo(::grpc::ServerContext* context, const ::ric::logic::v3::GetInstanceInfoRequest* request, ::ric::logic::v3::GetInstanceInfoResponse* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedGetInstanceInfo(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::ric::logic::v3::GetInstanceInfoRequest,::ric::logic::v3::GetInstanceInfoResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_StartAutomaton : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithStreamedUnaryMethod_StartAutomaton() {
      ::grpc::Service::MarkMethodStreamed(2,
        new ::grpc::internal::StreamedUnaryHandler< ::ric::logic::v3::StartAutomatonRequest, ::ric::logic::v3::StartAutomatonResponse>(std::bind(&WithStreamedUnaryMethod_StartAutomaton<BaseClass>::StreamedStartAutomaton, this, std::placeholders::_1, std::placeholders::_2)));
    }
    ~WithStreamedUnaryMethod_StartAutomaton() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status StartAutomaton(::grpc::ServerContext* context, const ::ric::logic::v3::StartAutomatonRequest* request, ::ric::logic::v3::StartAutomatonResponse* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedStartAutomaton(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::ric::logic::v3::StartAutomatonRequest,::ric::logic::v3::StartAutomatonResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_StartAutomatonMulti : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithStreamedUnaryMethod_StartAutomatonMulti() {
      ::grpc::Service::MarkMethodStreamed(3,
        new ::grpc::internal::StreamedUnaryHandler< ::ric::logic::v3::StartAutomatonMultiRequest, ::ric::logic::v3::StartAutomatonResponse>(std::bind(&WithStreamedUnaryMethod_StartAutomatonMulti<BaseClass>::StreamedStartAutomatonMulti, this, std::placeholders::_1, std::placeholders::_2)));
    }
    ~WithStreamedUnaryMethod_StartAutomatonMulti() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status StartAutomatonMulti(::grpc::ServerContext* context, const ::ric::logic::v3::StartAutomatonMultiRequest* request, ::ric::logic::v3::StartAutomatonResponse* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedStartAutomatonMulti(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::ric::logic::v3::StartAutomatonMultiRequest,::ric::logic::v3::StartAutomatonResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_StopAutomaton : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithStreamedUnaryMethod_StopAutomaton() {
      ::grpc::Service::MarkMethodStreamed(4,
        new ::grpc::internal::StreamedUnaryHandler< ::ric::logic::v3::StopAutomatonRequest, ::ric::logic::v3::StopAutomatonResponse>(std::bind(&WithStreamedUnaryMethod_StopAutomaton<BaseClass>::StreamedStopAutomaton, this, std::placeholders::_1, std::placeholders::_2)));
    }
    ~WithStreamedUnaryMethod_StopAutomaton() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status StopAutomaton(::grpc::ServerContext* context, const ::ric::logic::v3::StopAutomatonRequest* request, ::ric::logic::v3::StopAutomatonResponse* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedStopAutomaton(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::ric::logic::v3::StopAutomatonRequest,::ric::logic::v3::StopAutomatonResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_EmitEvent : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithStreamedUnaryMethod_EmitEvent() {
      ::grpc::Service::MarkMethodStreamed(6,
        new ::grpc::internal::StreamedUnaryHandler< ::ric::logic::v3::EmitEventRequest, ::ric::logic::v3::EmitEventResponse>(std::bind(&WithStreamedUnaryMethod_EmitEvent<BaseClass>::StreamedEmitEvent, this, std::placeholders::_1, std::placeholders::_2)));
    }
    ~WithStreamedUnaryMethod_EmitEvent() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status EmitEvent(::grpc::ServerContext* context, const ::ric::logic::v3::EmitEventRequest* request, ::ric::logic::v3::EmitEventResponse* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedEmitEvent(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::ric::logic::v3::EmitEventRequest,::ric::logic::v3::EmitEventResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_WaitEvent : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithStreamedUnaryMethod_WaitEvent() {
      ::grpc::Service::MarkMethodStreamed(7,
        new ::grpc::internal::StreamedUnaryHandler< ::ric::logic::v3::WaitEventRequest, ::ric::logic::v3::WaitEventResponse>(std::bind(&WithStreamedUnaryMethod_WaitEvent<BaseClass>::StreamedWaitEvent, this, std::placeholders::_1, std::placeholders::_2)));
    }
    ~WithStreamedUnaryMethod_WaitEvent() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status WaitEvent(::grpc::ServerContext* context, const ::ric::logic::v3::WaitEventRequest* request, ::ric::logic::v3::WaitEventResponse* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedWaitEvent(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::ric::logic::v3::WaitEventRequest,::ric::logic::v3::WaitEventResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_UpdateAutomatonVars : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithStreamedUnaryMethod_UpdateAutomatonVars() {
      ::grpc::Service::MarkMethodStreamed(8,
        new ::grpc::internal::StreamedUnaryHandler< ::ric::logic::v3::UpdateAutomatonVarsRequest, ::ric::logic::v3::UpdateAutomatonVarsResponse>(std::bind(&WithStreamedUnaryMethod_UpdateAutomatonVars<BaseClass>::StreamedUpdateAutomatonVars, this, std::placeholders::_1, std::placeholders::_2)));
    }
    ~WithStreamedUnaryMethod_UpdateAutomatonVars() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status UpdateAutomatonVars(::grpc::ServerContext* context, const ::ric::logic::v3::UpdateAutomatonVarsRequest* request, ::ric::logic::v3::UpdateAutomatonVarsResponse* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedUpdateAutomatonVars(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::ric::logic::v3::UpdateAutomatonVarsRequest,::ric::logic::v3::UpdateAutomatonVarsResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_TouchEventSubscription : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithStreamedUnaryMethod_TouchEventSubscription() {
      ::grpc::Service::MarkMethodStreamed(9,
        new ::grpc::internal::StreamedUnaryHandler< ::ric::logic::v3::TouchEventSubscriptionRequest, ::ric::logic::v3::TouchEventSubscriptionResponse>(std::bind(&WithStreamedUnaryMethod_TouchEventSubscription<BaseClass>::StreamedTouchEventSubscription, this, std::placeholders::_1, std::placeholders::_2)));
    }
    ~WithStreamedUnaryMethod_TouchEventSubscription() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status TouchEventSubscription(::grpc::ServerContext* context, const ::ric::logic::v3::TouchEventSubscriptionRequest* request, ::ric::logic::v3::TouchEventSubscriptionResponse* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedTouchEventSubscription(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::ric::logic::v3::TouchEventSubscriptionRequest,::ric::logic::v3::TouchEventSubscriptionResponse>* server_unary_streamer) = 0;
  };
  typedef WithStreamedUnaryMethod_GetInstanceInfo<WithStreamedUnaryMethod_StartAutomaton<WithStreamedUnaryMethod_StartAutomatonMulti<WithStreamedUnaryMethod_StopAutomaton<WithStreamedUnaryMethod_EmitEvent<WithStreamedUnaryMethod_WaitEvent<WithStreamedUnaryMethod_UpdateAutomatonVars<WithStreamedUnaryMethod_TouchEventSubscription<Service > > > > > > > > StreamedUnaryService;
  template <class BaseClass>
  class WithSplitStreamingMethod_GetAutomatons : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithSplitStreamingMethod_GetAutomatons() {
      ::grpc::Service::MarkMethodStreamed(1,
        new ::grpc::internal::SplitServerStreamingHandler< ::ric::logic::v3::GetAutomatonsRequest, ::ric::logic::v3::AutomatonInfo>(std::bind(&WithSplitStreamingMethod_GetAutomatons<BaseClass>::StreamedGetAutomatons, this, std::placeholders::_1, std::placeholders::_2)));
    }
    ~WithSplitStreamingMethod_GetAutomatons() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status GetAutomatons(::grpc::ServerContext* context, const ::ric::logic::v3::GetAutomatonsRequest* request, ::grpc::ServerWriter< ::ric::logic::v3::AutomatonInfo>* writer) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with split streamed
    virtual ::grpc::Status StreamedGetAutomatons(::grpc::ServerContext* context, ::grpc::ServerSplitStreamer< ::ric::logic::v3::GetAutomatonsRequest,::ric::logic::v3::AutomatonInfo>* server_split_streamer) = 0;
  };
  template <class BaseClass>
  class WithSplitStreamingMethod_RunAutomaton : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithSplitStreamingMethod_RunAutomaton() {
      ::grpc::Service::MarkMethodStreamed(5,
        new ::grpc::internal::SplitServerStreamingHandler< ::ric::logic::v3::RunAutomatonRequest, ::ric::logic::v3::AutomatonInfo>(std::bind(&WithSplitStreamingMethod_RunAutomaton<BaseClass>::StreamedRunAutomaton, this, std::placeholders::_1, std::placeholders::_2)));
    }
    ~WithSplitStreamingMethod_RunAutomaton() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status RunAutomaton(::grpc::ServerContext* context, const ::ric::logic::v3::RunAutomatonRequest* request, ::grpc::ServerWriter< ::ric::logic::v3::AutomatonInfo>* writer) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with split streamed
    virtual ::grpc::Status StreamedRunAutomaton(::grpc::ServerContext* context, ::grpc::ServerSplitStreamer< ::ric::logic::v3::RunAutomatonRequest,::ric::logic::v3::AutomatonInfo>* server_split_streamer) = 0;
  };
  typedef WithSplitStreamingMethod_GetAutomatons<WithSplitStreamingMethod_RunAutomaton<Service > > SplitStreamedService;
  typedef WithStreamedUnaryMethod_GetInstanceInfo<WithSplitStreamingMethod_GetAutomatons<WithStreamedUnaryMethod_StartAutomaton<WithStreamedUnaryMethod_StartAutomatonMulti<WithStreamedUnaryMethod_StopAutomaton<WithSplitStreamingMethod_RunAutomaton<WithStreamedUnaryMethod_EmitEvent<WithStreamedUnaryMethod_WaitEvent<WithStreamedUnaryMethod_UpdateAutomatonVars<WithStreamedUnaryMethod_TouchEventSubscription<Service > > > > > > > > > > StreamedService;
};

}  // namespace v3
}  // namespace logic
}  // namespace ric


#endif  // GRPC_ric_2dlogic_2dv3_2friclogicv3_2eproto__INCLUDED
